var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import jsep from 'jsep';
import UITypes from './UITypes';
import dayjs from 'dayjs';
import { SqlUiFactory } from './sqlUi';
import { dateFormats } from './dateTimeHelper';
export const StringOperators = ['||', '&'];
export const ArithmeticOperators = ['+', '-', '*', '/'];
export const ComparisonOperators = [
    '==',
    '=',
    '<',
    '>',
    '<=',
    '>=',
    '!=',
];
// opening and closing string code
const OCURLY_CODE = 123; // '{'
const CCURLY_CODE = 125; // '}'
export const jsepCurlyHook = {
    name: 'curly',
    init(jsep) {
        // Match identifier in following pattern: {abc-cde}
        jsep.hooks.add('gobble-token', function escapedIdentifier(env) {
            // check if the current token is an opening curly bracket
            if (this.code === OCURLY_CODE) {
                const patternIndex = this.index;
                // move to the next character until we find a closing curly bracket
                while (this.index < this.expr.length) {
                    ++this.index;
                    if (this.code === CCURLY_CODE) {
                        let identifier = this.expr.slice(patternIndex, ++this.index);
                        // if starting with double curley brace then check for ending double curley brace
                        // if found include with the identifier
                        if (identifier.startsWith('{{') &&
                            this.expr.slice(patternIndex, this.index + 1).endsWith('}')) {
                            identifier = this.expr.slice(patternIndex, ++this.index);
                        }
                        env.node = {
                            type: jsep.IDENTIFIER,
                            name: /^{{.*}}$/.test(identifier)
                                ? // start would be the position of the first curly bracket
                                    // add 2 to point to the first character for expressions like {{col1}}
                                    identifier.slice(2, -2)
                                : // start would be the position of the first curly bracket
                                    // add 1 to point to the first character for expressions like {col1}
                                    identifier.slice(1, -1),
                            raw: identifier,
                        };
                        // env.node = this.gobbleTokenProperty(env.node);
                        return env.node;
                    }
                }
                this.throwError('Unclosed }');
            }
        });
    },
};
function validateDateWithUnknownFormat(v) {
    for (const format of dateFormats) {
        if (dayjs(v, format, true).isValid()) {
            return true;
        }
        for (const timeFormat of ['HH:mm', 'HH:mm:ss', 'HH:mm:ss.SSS']) {
            if (dayjs(v, `${format} ${timeFormat}`, true).isValid()) {
                return true;
            }
        }
    }
    return false;
}
export function substituteColumnAliasWithIdInFormula(formula, columns) {
    return __awaiter(this, void 0, void 0, function* () {
        const substituteId = (pt) => __awaiter(this, void 0, void 0, function* () {
            if (pt.type === 'CallExpression') {
                for (const arg of pt.arguments || []) {
                    yield substituteId(arg);
                }
            }
            else if (pt.type === 'Literal') {
                return;
            }
            else if (pt.type === 'Identifier') {
                const colNameOrId = pt.name;
                const column = columns.find((c) => c.id === colNameOrId ||
                    c.column_name === colNameOrId ||
                    c.title === colNameOrId);
                pt.name = '{' + column.id + '}';
            }
            else if (pt.type === 'BinaryExpression') {
                yield substituteId(pt.left);
                yield substituteId(pt.right);
            }
        });
        // register jsep curly hook
        jsep.plugins.register(jsepCurlyHook);
        const parsedFormula = jsep(formula);
        yield substituteId(parsedFormula);
        return jsepTreeToFormula(parsedFormula);
    });
}
export var FormulaErrorType;
(function (FormulaErrorType) {
    FormulaErrorType["NOT_AVAILABLE"] = "NOT_AVAILABLE";
    FormulaErrorType["NOT_SUPPORTED"] = "NOT_SUPPORTED";
    FormulaErrorType["MIN_ARG"] = "MIN_ARG";
    FormulaErrorType["MAX_ARG"] = "MAX_ARG";
    FormulaErrorType["TYPE_MISMATCH"] = "TYPE_MISMATCH";
    FormulaErrorType["INVALID_ARG"] = "INVALID_ARG";
    FormulaErrorType["INVALID_ARG_TYPE"] = "INVALID_ARG_TYPE";
    FormulaErrorType["INVALID_ARG_VALUE"] = "INVALID_ARG_VALUE";
    FormulaErrorType["INVALID_ARG_COUNT"] = "INVALID_ARG_COUNT";
    FormulaErrorType["CIRCULAR_REFERENCE"] = "CIRCULAR_REFERENCE";
    FormulaErrorType["INVALID_FUNCTION_NAME"] = "INVALID_FUNCTION_NAME";
    FormulaErrorType["INVALID_COLUMN"] = "INVALID_COLUMN";
})(FormulaErrorType || (FormulaErrorType = {}));
export function substituteColumnIdWithAliasInFormula(formula, columns, rawFormula) {
    const substituteId = (pt, ptRaw) => {
        var _a;
        if (pt.type === 'CallExpression') {
            let i = 0;
            for (const arg of pt.arguments || []) {
                substituteId(arg, (_a = ptRaw === null || ptRaw === void 0 ? void 0 : ptRaw.arguments) === null || _a === void 0 ? void 0 : _a[i++]);
            }
        }
        else if (pt.type === 'Literal') {
            return;
        }
        else if (pt.type === 'Identifier') {
            const colNameOrId = pt === null || pt === void 0 ? void 0 : pt.name;
            const column = columns.find((c) => c.id === colNameOrId ||
                c.column_name === colNameOrId ||
                c.title === colNameOrId);
            pt.name = (column === null || column === void 0 ? void 0 : column.title) || (ptRaw === null || ptRaw === void 0 ? void 0 : ptRaw.name) || (pt === null || pt === void 0 ? void 0 : pt.name);
        }
        else if (pt.type === 'BinaryExpression') {
            substituteId(pt.left, ptRaw === null || ptRaw === void 0 ? void 0 : ptRaw.left);
            substituteId(pt.right, ptRaw === null || ptRaw === void 0 ? void 0 : ptRaw.right);
        }
    };
    // register jsep curly hook
    jsep.plugins.register(jsepCurlyHook);
    const parsedFormula = jsep(formula);
    const parsedRawFormula = rawFormula && jsep(rawFormula);
    substituteId(parsedFormula, parsedRawFormula);
    return jsepTreeToFormula(parsedFormula);
}
// isCallExpId - is the identifier part of a call expression
// in case of call expression, we don't want to wrap the identifier in curly brackets
export function jsepTreeToFormula(node, isCallExpId = false) {
    if (node.type === 'BinaryExpression' || node.type === 'LogicalExpression') {
        return ('(' +
            jsepTreeToFormula(node.left) +
            ' ' +
            node.operator +
            ' ' +
            jsepTreeToFormula(node.right) +
            ')');
    }
    if (node.type === 'UnaryExpression') {
        return node.operator + jsepTreeToFormula(node.argument);
    }
    if (node.type === 'MemberExpression') {
        return (jsepTreeToFormula(node.object) +
            '[' +
            jsepTreeToFormula(node.property) +
            ']');
    }
    if (node.type === 'Identifier') {
        if (!isCallExpId)
            return '{' + node.name + '}';
        return node.name;
    }
    if (node.type === 'Literal') {
        if (typeof node.value === 'string') {
            return String.raw `"${escapeLiteral(node.raw.slice(1, -1))}"`;
        }
        return '' + node.value;
    }
    if (node.type === 'CallExpression') {
        return (jsepTreeToFormula(node.callee, true) +
            '(' +
            node.arguments.map((argPt) => jsepTreeToFormula(argPt)).join(', ') +
            ')');
    }
    if (node.type === 'ArrayExpression') {
        return ('[' +
            node.elements.map((elePt) => jsepTreeToFormula(elePt)).join(', ') +
            ']');
    }
    if (node.type === 'Compound') {
        return node.body.map((e) => jsepTreeToFormula(e)).join(' ');
    }
    if (node.type === 'ConditionalExpression') {
        return (jsepTreeToFormula(node.test) +
            ' ? ' +
            jsepTreeToFormula(node.consequent) +
            ' : ' +
            jsepTreeToFormula(node.alternate));
    }
    return '';
}
function escapeLiteral(v) {
    return (v
        // replace \ to \\, escape only unescaped \
        .replace(/([^\\]|^)\\(?!\\)/g, `$1\\\\`)
        // replace " to \"
        .replace(/([^\\]|^)"/g, `$1\\"`)
        // replace ' to \'
        .replace(/([^\\]|^)'/g, `$1\\'`));
}
export var FormulaDataTypes;
(function (FormulaDataTypes) {
    FormulaDataTypes["NUMERIC"] = "numeric";
    FormulaDataTypes["STRING"] = "string";
    FormulaDataTypes["DATE"] = "date";
    FormulaDataTypes["LOGICAL"] = "logical";
    FormulaDataTypes["ARRAY"] = "array";
    FormulaDataTypes["COND_EXP"] = "conditional_expression";
    FormulaDataTypes["NULL"] = "null";
    FormulaDataTypes["BOOLEAN"] = "boolean";
    FormulaDataTypes["INTERVAL"] = "interval";
    FormulaDataTypes["UNKNOWN"] = "unknown";
})(FormulaDataTypes || (FormulaDataTypes = {}));
export var JSEPNode;
(function (JSEPNode) {
    JSEPNode["COMPOUND"] = "Compound";
    JSEPNode["IDENTIFIER"] = "Identifier";
    JSEPNode["MEMBER_EXP"] = "MemberExpression";
    JSEPNode["LITERAL"] = "Literal";
    JSEPNode["THIS_EXP"] = "ThisExpression";
    JSEPNode["CALL_EXP"] = "CallExpression";
    JSEPNode["UNARY_EXP"] = "UnaryExpression";
    JSEPNode["BINARY_EXP"] = "BinaryExpression";
    JSEPNode["ARRAY_EXP"] = "ArrayExpression";
})(JSEPNode || (JSEPNode = {}));
export const formulas = {
    AVG: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#avg',
        validation: {
            args: {
                min: 1,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Average of input parameters',
        syntax: 'AVG(value1, [value2, ...])',
        examples: [
            'AVG(10, 5) => 7.5',
            'AVG({column1}, {column2})',
            'AVG({column1}, {column2}, {column3})',
        ],
        returnType: FormulaDataTypes.NUMERIC,
    },
    ADD: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#add',
        validation: {
            args: {
                min: 1,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Sum of input parameters',
        syntax: 'ADD(value1, [value2, ...])',
        examples: [
            'ADD(5, 5) => 10',
            'ADD({column1}, {column2})',
            'ADD({column1}, {column2}, {column3})',
        ],
        returnType: FormulaDataTypes.NUMERIC,
    },
    DATEADD: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/date-functions#dateadd',
        validation: {
            args: {
                rqd: 3,
                type: FormulaDataTypes.DATE,
            },
            custom: (_argTypes, parsedTree) => {
                if (parsedTree.arguments[0].type === JSEPNode.LITERAL) {
                    if (!validateDateWithUnknownFormat(parsedTree.arguments[0].value)) {
                        throw new FormulaError(FormulaErrorType.TYPE_MISMATCH, { key: 'msg.formula.firstParamDateAddHaveDate' }, 'First parameter of DATEADD should be a date');
                    }
                }
                if (parsedTree.arguments[1].type === JSEPNode.LITERAL) {
                    if (typeof parsedTree.arguments[1].value !== 'number') {
                        throw new FormulaError(FormulaErrorType.TYPE_MISMATCH, { key: 'msg.formula.secondParamDateAddHaveNumber' }, 'Second parameter of DATEADD should be a number');
                    }
                }
                if (parsedTree.arguments[2].type === JSEPNode.LITERAL) {
                    if (!['day', 'week', 'month', 'year'].includes(parsedTree.arguments[2].value)) {
                        throw new FormulaError(FormulaErrorType.TYPE_MISMATCH, { key: 'msg.formula.thirdParamDateAddHaveDate' }, "Third parameter of DATEADD should be one of 'day', 'week', 'month', 'year'");
                    }
                }
            },
        },
        description: 'Adds "count" units to Datetime.',
        syntax: 'DATEADD(date | datetime, count, ["day" | "week" | "month" | "year"])',
        examples: [
            'DATEADD({column1}, 2, "day")',
            'DATEADD({column1}, -2, "day")',
            'DATEADD({column1}, 2, "week")',
            'DATEADD({column1}, -2, "week")',
            'DATEADD({column1}, 2, "month")',
            'DATEADD({column1}, -2, "month")',
            'DATEADD({column1}, 2, "year")',
            'DATEADD({column1}, -2, "year")',
        ],
        returnType: FormulaDataTypes.DATE,
    },
    DATESTR: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/date-functions#datestr',
        validation: {
            args: {
                rqd: 1,
            },
        },
        syntax: 'DATESTR(date | datetime)',
        description: 'Formats input field into a string in "YYYY-MM-DD" format',
        examples: ['DATESTR({column1})'],
        returnType: FormulaDataTypes.STRING,
    },
    DAY: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/date-functions#day',
        validation: {
            args: {
                rqd: 1,
            },
        },
        syntax: 'DAY(date | datetime)',
        description: 'Extract day from a date field (1-31)',
        examples: ['DAY({column1})'],
        returnType: FormulaDataTypes.STRING,
    },
    MONTH: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/date-functions#month',
        validation: {
            args: {
                rqd: 1,
            },
        },
        syntax: 'MONTH(date | datetime)',
        description: 'Extract month from a date field (1-12)',
        examples: ['MONTH({column1})'],
        returnType: FormulaDataTypes.STRING,
    },
    YEAR: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/date-functions#year',
        validation: {
            args: {
                rqd: 1,
            },
        },
        syntax: 'YEAR(date | datetime)',
        description: 'Extract year from a date field',
        examples: ['YEAR({column1})'],
        returnType: FormulaDataTypes.STRING,
    },
    HOUR: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/date-functions#hour',
        validation: {
            args: {
                rqd: 1,
            },
        },
        syntax: 'DAY(time | datetime)',
        description: 'Extract hour from a time field (0-23)',
        examples: ['HOUR({column1})'],
        returnType: FormulaDataTypes.STRING,
    },
    DATETIME_DIFF: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/date-functions#datetime_diff',
        validation: {
            args: {
                min: 2,
                max: 3,
                type: FormulaDataTypes.DATE,
            },
            custom: (_argTypes, parsedTree) => {
                if (parsedTree.arguments[0].type === JSEPNode.LITERAL) {
                    if (!validateDateWithUnknownFormat(parsedTree.arguments[0].value)) {
                        throw new FormulaError(FormulaErrorType.TYPE_MISMATCH, { key: 'msg.formula.firstParamDateDiffHaveDate' }, 'First parameter of DATETIME_DIFF should be a date');
                    }
                }
                if (parsedTree.arguments[1].type === JSEPNode.LITERAL) {
                    if (!validateDateWithUnknownFormat(parsedTree.arguments[1].value)) {
                        throw new FormulaError(FormulaErrorType.TYPE_MISMATCH, { key: 'msg.formula.secondParamDateDiffHaveDate' }, 'Second parameter of DATETIME_DIFF should be a date');
                    }
                }
                if (parsedTree.arguments[2] &&
                    parsedTree.arguments[2].type === JSEPNode.LITERAL) {
                    if (![
                        'milliseconds',
                        'ms',
                        'seconds',
                        's',
                        'minutes',
                        'm',
                        'hours',
                        'h',
                        'days',
                        'd',
                        'weeks',
                        'w',
                        'months',
                        'M',
                        'quarters',
                        'Q',
                        'years',
                        'y',
                    ].includes(parsedTree.arguments[2].value)) {
                        throw new FormulaError(FormulaErrorType.TYPE_MISMATCH, { key: 'msg.formula.thirdParamDateDiffHaveDate' }, "Third parameter of DATETIME_DIFF should be one of 'milliseconds', 'ms', 'seconds', 's', 'minutes', 'm', 'hours', 'h', 'days', 'd', 'weeks', 'w', 'months', 'M', 'quarters', 'Q', 'years', 'y'");
                    }
                }
            },
        },
        description: 'Calculate the difference of two given date / datetime fields in specified units.',
        syntax: 'DATETIME_DIFF(date | datetime, date | datetime, ["milliseconds" | "ms" | "seconds" | "s" | "minutes" | "m" | "hours" | "h" | "days" | "d" | "weeks" | "w" | "months" | "M" | "quarters" | "Q" | "years" | "y"])',
        examples: [
            'DATEDIFF({column1}, {column2})',
            'DATEDIFF({column1}, {column2}, "seconds")',
            'DATEDIFF({column1}, {column2}, "s")',
            'DATEDIFF({column1}, {column2}, "years")',
            'DATEDIFF({column1}, {column2}, "y")',
            'DATEDIFF({column1}, {column2}, "minutes")',
            'DATEDIFF({column1}, {column2}, "m")',
            'DATEDIFF({column1}, {column2}, "days")',
            'DATEDIFF({column1}, {column2}, "d")',
        ],
        returnType: FormulaDataTypes.NUMERIC,
    },
    AND: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/conditional-expressions#and',
        validation: {
            args: {
                min: 1,
            },
        },
        description: 'Result is TRUE if all conditions are met',
        syntax: 'AND(expr1, [expr2, ...])',
        examples: ['AND(5 > 2, 5 < 10) => 1', 'AND({column1} > 2, {column2} < 10)'],
        returnType: FormulaDataTypes.COND_EXP,
    },
    OR: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/conditional-expressions#or',
        validation: {
            args: {
                min: 1,
            },
        },
        description: 'Result is TRUE if at least one condition is met',
        syntax: 'OR(expr1, [expr2, ...])',
        examples: ['OR(5 > 2, 5 < 10) => 1', 'OR({column1} > 2, {column2} < 10)'],
        returnType: FormulaDataTypes.COND_EXP,
    },
    CONCAT: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#concat',
        validation: {
            args: {
                min: 1,
            },
        },
        description: 'Concatenate input parameters into a single string',
        syntax: 'CONCAT(str1, [str2, ...])',
        examples: [
            'CONCAT("AA", "BB", "CC") => "AABBCC"',
            'CONCAT({column1}, {column2}, {column3})',
        ],
        returnType: FormulaDataTypes.STRING,
    },
    TRIM: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#trim',
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.STRING,
            },
        },
        description: 'Remove trailing and leading whitespaces from input parameter',
        syntax: 'TRIM(str)',
        examples: [
            'TRIM("         HELLO WORLD  ") => "HELLO WORLD"',
            'TRIM({column1})',
        ],
        returnType: FormulaDataTypes.STRING,
    },
    UPPER: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#upper',
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.STRING,
            },
        },
        description: 'Converts the input parameter to an upper-case string.',
        syntax: 'UPPER(str)',
        examples: ['UPPER("nocodb") => "NOCODB"', 'UPPER({column1})'],
        returnType: FormulaDataTypes.STRING,
    },
    LOWER: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#lower',
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.STRING,
            },
        },
        description: 'Converts the input parameter to an lower-case string.',
        syntax: 'LOWER(str)',
        examples: ['LOWER("NOCODB") => "nocodb"', 'LOWER({column1})'],
        returnType: FormulaDataTypes.STRING,
    },
    LEN: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#len',
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.STRING,
            },
        },
        description: 'Calculate the character length of the input parameter.',
        syntax: 'LEN(value)',
        examples: ['LEN("NocoDB") => 6', 'LEN({column1})'],
        returnType: FormulaDataTypes.NUMERIC,
    },
    MIN: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#min',
        validation: {
            args: {
                min: 1,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Find the minimum value among the input parameters.',
        syntax: 'MIN(value1, [value2, ...])',
        examples: ['MIN(1000, 2000) => 1000', 'MIN({column1}, {column2})'],
        returnType: FormulaDataTypes.NUMERIC,
    },
    MAX: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#max',
        validation: {
            args: {
                min: 1,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Find the maximum value among the input parameters.',
        syntax: 'MAX(value1, [value2, ...])',
        examples: ['MAX(1000, 2000) => 2000', 'MAX({column1}, {column2})'],
        returnType: FormulaDataTypes.NUMERIC,
    },
    CEILING: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#ceiling',
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Rounds the input parameter to the next largest integer value.',
        syntax: 'CEILING(value)',
        examples: ['CEILING(1.01) => 2', 'CEILING({column1})'],
        returnType: FormulaDataTypes.NUMERIC,
    },
    FLOOR: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#floor',
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Round down the input parameter to the nearest integer.',
        syntax: 'FLOOR(value)',
        examples: ['FLOOR(3.1415) => 3', 'FLOOR({column1})'],
        returnType: FormulaDataTypes.NUMERIC,
    },
    ROUND: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#round',
        validation: {
            args: {
                min: 1,
                max: 2,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Rounds the number to a specified decimal places or the nearest integer if precision is not specified',
        syntax: 'ROUND(value, precision), ROUND(value)',
        examples: [
            'ROUND(3.1415) => 3',
            'ROUND(3.1415, 2) => 3.14',
            'ROUND({column1}, 3)',
        ],
        returnType: FormulaDataTypes.NUMERIC,
    },
    MOD: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#mod',
        validation: {
            args: {
                rqd: 2,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Calculate the remainder resulting from integer division of input parameters.',
        syntax: 'MOD(value1, value2)',
        examples: ['MOD(1024, 1000) => 24', 'MOD({column}, 2)'],
        returnType: FormulaDataTypes.NUMERIC,
    },
    REPEAT: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#repeat',
        validation: {
            args: {
                rqd: 2,
            },
            custom(argTypes, parsedTree) {
                var _a, _b;
                if (argTypes[1] !== FormulaDataTypes.NUMERIC) {
                    throw new FormulaError(FormulaErrorType.INVALID_ARG, {
                        key: 'msg.formula.typeIsExpected',
                        type: 'Numeric',
                        calleeName: (_b = (_a = parsedTree.callee) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.toUpperCase(),
                        position: 2,
                    }, 'The REPEAT function requires a numeric as the parameter at position 2');
                }
            },
        },
        description: 'Concatenate the specified number of copies of the input parameter string.',
        syntax: 'REPEAT(str, count)',
        examples: ['REPEAT("A", 5) => "AAAAA"', 'REPEAT({column}, 5)'],
        returnType: FormulaDataTypes.STRING,
    },
    LOG: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#log',
        validation: {
            args: {
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Compute the logarithm of the input parameter to the specified base (default = e).',
        syntax: 'LOG([base], value)',
        examples: ['LOG(2, 1024) => 10', 'LOG(2, {column1})'],
        returnType: FormulaDataTypes.NUMERIC,
    },
    EXP: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#exp',
        validation: {
            args: {
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Compute the exponential value of the input parameter (e raised to the power specified)',
        syntax: 'EXP(power)',
        examples: ['EXP(1) => 2.718281828459045', 'EXP({column1})'],
        returnType: FormulaDataTypes.NUMERIC,
    },
    POWER: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#power',
        validation: {
            args: {
                rqd: 2,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Compute base raised to the exponent power.',
        syntax: 'POWER(base, exponent)',
        examples: ['POWER(2, 10) => 1024', 'POWER({column1}, 10)'],
        returnType: FormulaDataTypes.NUMERIC,
    },
    SQRT: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#sqrt',
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Calculate the square root of the input parameter.',
        syntax: 'SQRT(value)',
        examples: ['SQRT(100) => 10', 'SQRT({column1})'],
        returnType: FormulaDataTypes.NUMERIC,
    },
    ABS: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#abs',
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Obtain the absolute value of the input parameter.',
        syntax: 'ABS(value)',
        examples: ['ABS({column1})'],
        returnType: FormulaDataTypes.NUMERIC,
    },
    NOW: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/date-functions#now',
        validation: {
            args: {
                rqd: 0,
                type: FormulaDataTypes.DATE,
            },
        },
        description: 'Retrieve the current time and day.',
        syntax: 'NOW()',
        examples: ['NOW() => 2022-05-19 17:20:43'],
        returnType: FormulaDataTypes.DATE,
    },
    REPLACE: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#replace',
        validation: {
            args: {
                rqd: 3,
                type: FormulaDataTypes.STRING,
            },
        },
        description: 'Replace all occurrences of "searchStr" with "replaceStr" in the given string.',
        syntax: 'REPLACE(str, searchStr, replaceStr)',
        examples: [
            'REPLACE("AABBCC", "AA", "BB") => "BBBBCC"',
            'REPLACE({column1}, {column2}, {column3})',
        ],
        returnType: FormulaDataTypes.STRING,
    },
    SEARCH: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#search',
        validation: {
            args: {
                rqd: 2,
                type: FormulaDataTypes.STRING,
            },
        },
        description: 'Retrieve the index of the specified "searchStr" if found; otherwise, returns 0.',
        syntax: 'SEARCH(str, searchStr)',
        examples: [
            'SEARCH("HELLO WORLD", "WORLD") => 7',
            'SEARCH({column1}, "abc")',
        ],
        returnType: FormulaDataTypes.NUMERIC,
    },
    INT: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#int',
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Obtain the integer value of the input parameter',
        syntax: 'INT(value)',
        examples: ['INT(3.1415) => 3', 'INT({column1})'],
        returnType: FormulaDataTypes.NUMERIC,
    },
    RIGHT: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#right',
        validation: {
            args: {
                rqd: 2,
                type: [FormulaDataTypes.STRING, FormulaDataTypes.NUMERIC],
            },
        },
        description: 'Retrieve the last n characters from the input string.',
        syntax: 'RIGHT(str, n)',
        examples: ['RIGHT("HELLO WORLD", 5) => WORLD', 'RIGHT({column1}, 3)'],
        returnType: FormulaDataTypes.STRING,
    },
    LEFT: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#left',
        validation: {
            args: {
                rqd: 2,
                type: [FormulaDataTypes.STRING, FormulaDataTypes.NUMERIC],
            },
        },
        description: 'Retrieve the first n characters from the input string.',
        syntax: 'LEFT(str, n)',
        examples: ['LEFT({column1}, 2)', 'LEFT("ABCD", 2) => "AB"'],
        returnType: FormulaDataTypes.STRING,
    },
    SUBSTR: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#substr',
        validation: {
            args: {
                min: 2,
                max: 3,
                type: [
                    FormulaDataTypes.STRING,
                    FormulaDataTypes.NUMERIC,
                    FormulaDataTypes.NUMERIC,
                ],
            },
        },
        description: 'Extracts a substring of length "n" from the input string, starting from the specified position.',
        syntax: '	SUBTR(str, position, [n])',
        examples: [
            'SUBSTR("HELLO WORLD", 7) => WORLD',
            'SUBSTR("HELLO WORLD", 7, 3) => WOR',
            'SUBSTR({column1}, 7, 5)',
        ],
        returnType: FormulaDataTypes.STRING,
    },
    MID: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#mid',
        validation: {
            args: {
                rqd: 3,
                type: [
                    FormulaDataTypes.STRING,
                    FormulaDataTypes.NUMERIC,
                    FormulaDataTypes.NUMERIC,
                ],
            },
        },
        description: 'Extracts a substring; an alias for SUBSTR.',
        syntax: 'MID(str, position, [count])',
        examples: ['MID("NocoDB", 3, 2) => "co"', 'MID({column1}, 3, 2)'],
        returnType: FormulaDataTypes.STRING,
    },
    ISBLANK: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#isblank',
        validation: {
            args: {
                rqd: 1,
            },
        },
        description: 'Check if the input parameter is blank.',
        syntax: 'ISBLANK(value)',
        examples: ['ISBLANK({column1}) => false', 'ISBLANK("") => true'],
        returnType: FormulaDataTypes.BOOLEAN,
    },
    ISNOTBLANK: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#isnotblank',
        validation: {
            args: {
                rqd: 1,
            },
        },
        description: 'Check if the input parameter is not blank.',
        syntax: 'ISNOTBLANK(value)',
        examples: ['ISNOTBLANK({column1}) => true', 'ISNOTBLANK("") => false'],
        returnType: FormulaDataTypes.BOOLEAN,
    },
    IF: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/conditional-expressions#if',
        validation: {
            args: {
                min: 2,
                max: 3,
            },
        },
        description: 'Evaluate successCase if the expression is TRUE, else the failureCase.',
        syntax: 'IF(expr, successCase, failureCase)',
        examples: [
            'IF(5 > 1, "YES", "NO") => "YES"',
            'IF({column} > 1, "YES", "NO")',
        ],
        returnType: (argTypes) => {
            // extract all return types except NULL, since null can be returned by any type
            const returnValueTypes = new Set(argTypes.slice(1).filter((type) => type !== FormulaDataTypes.NULL));
            // if there are more than one return types or if there is a string return type
            // return type as string else return the type
            if (returnValueTypes.size > 1 ||
                returnValueTypes.has(FormulaDataTypes.STRING)) {
                return FormulaDataTypes.STRING;
            }
            else if (returnValueTypes.has(FormulaDataTypes.NUMERIC)) {
                return FormulaDataTypes.NUMERIC;
            }
            else if (returnValueTypes.has(FormulaDataTypes.BOOLEAN)) {
                return FormulaDataTypes.BOOLEAN;
            }
            else if (returnValueTypes.has(FormulaDataTypes.DATE)) {
                return FormulaDataTypes.DATE;
            }
            // if none of the above conditions are met, return the first return argument type
            return argTypes[1];
        },
    },
    SWITCH: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/conditional-expressions#switch',
        validation: {
            args: {
                min: 3,
            },
            custom: (_argTypes, _parseTree) => {
                // Todo: Add validation for switch
            },
        },
        description: 'Evaluate case value based on expression output; if no match is found, evaluate default case.',
        syntax: 'SWITCH(expr, [pattern, value, ..., default])',
        examples: [
            'SWITCH(1, 1, "One", 2, "Two", "N/A") => "One""',
            'SWITCH(2, 1, "One", 2, "Two", "N/A") => "Two"',
            'SWITCH(3, 1, "One", 2, "Two", "N/A") => "N/A"',
            'SWITCH({column1}, 1, "One", 2, "Two", "N/A")',
        ],
        returnType: (argTypes) => {
            // extract all return types except NULL, since null can be returned by any type
            const returnValueTypes = new Set(argTypes.slice(2).filter((_, i) => i % 2 === 0));
            // if there are more than one return types or if there is a string return type
            // return type as string else return the type
            if (returnValueTypes.size > 1 ||
                returnValueTypes.has(FormulaDataTypes.STRING)) {
                return FormulaDataTypes.STRING;
            }
            else if (returnValueTypes.has(FormulaDataTypes.NUMERIC)) {
                return FormulaDataTypes.NUMERIC;
            }
            else if (returnValueTypes.has(FormulaDataTypes.BOOLEAN)) {
                return FormulaDataTypes.BOOLEAN;
            }
            else if (returnValueTypes.has(FormulaDataTypes.DATE)) {
                return FormulaDataTypes.DATE;
            }
            // if none of the above conditions are met, return the first return argument type
            return argTypes[1];
        },
    },
    URL: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#url',
        validation: {
            args: {
                min: 1,
                max: 2,
                type: [FormulaDataTypes.STRING, FormulaDataTypes.STRING],
            },
        },
        description: 'Verify and convert to a hyperlink if the input is a valid URL.',
        syntax: 'URL(string, [label])',
        examples: [
            'URL("https://github.com/nocodb/nocodb")',
            'URL({column1})',
            'URL("https://github.com/nocodb/nocodb", "NocoDB")',
            'URL({column1}, {column1})',
        ],
        returnType: FormulaDataTypes.STRING,
    },
    URLENCODE: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#urlencode',
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.STRING,
            },
        },
        description: 'Percent-encode the input parameter for use in URLs',
        syntax: 'URLENCODE(str)',
        examples: [
            'URLENCODE("Hello, world") => "Hello%2C%20world"',
            'URLENCODE({column1})',
        ],
        returnType: FormulaDataTypes.STRING,
    },
    WEEKDAY: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/date-functions#weekday',
        validation: {
            args: {
                min: 1,
                max: 2,
                type: FormulaDataTypes.NUMERIC,
            },
            custom(_argTypes, parsedTree) {
                if (parsedTree.arguments[0].type === JSEPNode.LITERAL) {
                    if (!validateDateWithUnknownFormat(parsedTree.arguments[0].value)) {
                        throw new FormulaError(FormulaErrorType.TYPE_MISMATCH, { key: 'msg.formula.firstParamWeekDayHaveDate' }, 'First parameter of WEEKDAY should be a date');
                    }
                }
                // if second argument is present and literal then validate it
                if (parsedTree.arguments[1] &&
                    parsedTree.arguments[1].type === JSEPNode.LITERAL) {
                    const value = parsedTree.arguments[1].value;
                    if (typeof value !== 'string' ||
                        ![
                            'sunday',
                            'monday',
                            'tuesday',
                            'wednesday',
                            'thursday',
                            'friday',
                            'saturday',
                        ].includes(value.toLowerCase())) {
                        throw new FormulaError(FormulaErrorType.TYPE_MISMATCH, { key: 'msg.formula.secondParamWeekDayHaveDate' }, 'Second parameter of WEEKDAY should be day of week string');
                    }
                }
            },
        },
        description: 'Retrieve the day of the week as an integer (0-6), starting from Monday by default.',
        syntax: 'WEEKDAY(date, [startDayOfWeek])',
        examples: ['WEEKDAY("2021-06-09")', 'WEEKDAY(NOW(), "sunday")'],
        returnType: FormulaDataTypes.NUMERIC,
    },
    TRUE: {
        validation: {
            args: {
                max: 0,
            },
        },
        description: 'Returns 1',
        syntax: 'TRUE()',
        examples: ['TRUE()'],
        returnType: FormulaDataTypes.NUMERIC,
        // TODO: Add docs url
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/logical-functions#true',
    },
    FALSE: {
        validation: {
            args: {
                max: 0,
            },
        },
        description: 'Returns 0',
        syntax: 'FALSE()',
        examples: ['FALSE()'],
        returnType: FormulaDataTypes.NUMERIC,
        // TODO: Add docs url
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/logical-functions#false',
    },
    ARRAYUNIQUE: {
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.ARRAY,
            },
        },
        description: 'Return unique items from the given array',
        syntax: 'ARRAYUNIQUE(value)',
        examples: ['ARRAYUNIQUE({column})'],
        returnType: FormulaDataTypes.ARRAY,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/array-functions#arrayunique',
    },
    ARRAYSORT: {
        validation: {
            args: {
                min: 1,
                max: 2,
            },
        },
        description: 'Sort an array result',
        syntax: 'ARRAYSORT(value, [direction])',
        examples: ['ARRAYSORT({column}, "desc")'],
        returnType: FormulaDataTypes.ARRAY,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/array-functions#arraysort',
    },
    ARRAYCOMPACT: {
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.ARRAY,
            },
        },
        description: 'Removes empty strings and null values from the array',
        syntax: 'ARRAYCOMPACT(value)',
        examples: ['ARRAYCOMPACT({column})'],
        returnType: FormulaDataTypes.ARRAY,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/array-functions#arraycompact',
    },
    ARRAYSLICE: {
        validation: {
            args: {
                min: 2,
                max: 3,
            },
        },
        description: 'Removes empty strings and null values from the array',
        syntax: 'ARRAYSLICE(value, start, [end])',
        examples: ['ARRAYSLICE({column})'],
        returnType: FormulaDataTypes.ARRAY,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/array-functions#arrayslice',
    },
    REGEX_MATCH: {
        validation: {
            args: {
                rqd: 2,
                type: FormulaDataTypes.STRING,
            },
        },
        description: 'Verifies whether the input text matches a regular expression, returning 1 for a match and 0 otherwise.',
        syntax: 'REGEX_MATCH(string, regex)',
        examples: ['REGEX_MATCH({title}, "abc.*")'],
        returnType: FormulaDataTypes.NUMERIC,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#regex_match',
    },
    REGEX_EXTRACT: {
        validation: {
            args: {
                rqd: 2,
                type: FormulaDataTypes.STRING,
            },
        },
        description: 'Retrieve the first match of a regular expression in a string.',
        syntax: 'REGEX_EXTRACT(string, regex)',
        examples: ['REGEX_EXTRACT({title}, "abc.*")'],
        returnType: FormulaDataTypes.STRING,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#regex_extract',
    },
    REGEX_REPLACE: {
        validation: {
            args: {
                rqd: 3,
                type: FormulaDataTypes.STRING,
            },
        },
        description: 'Replace all occurrences of a regular expression in a string with a specified replacement string.',
        syntax: 'REGEX_MATCH(string, regex, replacement)',
        examples: ['REGEX_EXTRACT({title}, "abc.*", "abcd")'],
        returnType: FormulaDataTypes.STRING,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#regex_replace',
    },
    BLANK: {
        validation: {
            args: {
                rqd: 0,
            },
        },
        description: 'Yields a null value.',
        syntax: 'BLANK()',
        examples: ['BLANK()'],
        returnType: FormulaDataTypes.NULL,
        // TODO: Add docs url
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/logical-functions#blank',
    },
    XOR: {
        validation: {
            args: {
                min: 1,
            },
            // todo: validation for boolean
        },
        description: 'Verifies whether an odd number of arguments are true, returning true if so, and false otherwise.',
        syntax: 'XOR(expression, [exp2, ...])',
        examples: ['XOR(TRUE(), FALSE(), TRUE())'],
        returnType: FormulaDataTypes.BOOLEAN,
        // TODO: Add docs url
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/logical-functions#xor',
    },
    EVEN: {
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Rounds up the specified value to the nearest even integer that is greater than or equal to the specified value',
        syntax: 'EVEN(value)',
        examples: ['EVEN({column})'],
        returnType: FormulaDataTypes.NUMERIC,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#even',
    },
    ODD: {
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Rounds up the specified value to the nearest odd integer that is greater than or equal to the specified value',
        syntax: 'ODD(value)',
        examples: ['ODD({column})'],
        returnType: FormulaDataTypes.NUMERIC,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#odd',
    },
    RECORD_ID: {
        validation: {
            args: {
                rqd: 0,
            },
        },
        description: 'Retrieve the record ID of the current record.',
        syntax: 'RECORD_ID()',
        examples: ['RECORD_ID()'],
        // todo: resolve return type based on the args
        returnType: () => {
            return FormulaDataTypes.STRING;
        },
    },
    COUNTA: {
        validation: {
            args: {
                min: 1,
            },
        },
        description: 'Counts non-empty arguments',
        syntax: 'COUNTA(value1, [value2, ...])',
        examples: ['COUNTA({field1}, {field2})'],
        returnType: FormulaDataTypes.NUMERIC,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#counta',
    },
    COUNT: {
        validation: {
            args: {
                min: 1,
            },
        },
        description: 'Counts numerical arguments',
        syntax: 'COUNT(value1, [value2, ...])',
        examples: ['COUNT({field1}, {field2})'],
        returnType: FormulaDataTypes.NUMERIC,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#count',
    },
    COUNTALL: {
        validation: {
            args: {
                min: 1,
            },
        },
        description: 'Counts the number of arguments',
        syntax: 'COUNTALL(value1, [value2, ...])',
        examples: ['COUNTALL({field1}, {field2})'],
        returnType: FormulaDataTypes.NUMERIC,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#countall',
    },
    ROUNDDOWN: {
        validation: {
            args: {
                min: 1,
                max: 2,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Rounds down the value after the decimal point to the specified number of decimal places given by "precision" (default is 0).',
        syntax: 'ROUNDDOWN(value, [precision])',
        examples: ['ROUNDDOWN({field1})', 'ROUNDDOWN({field1}, 2)'],
        returnType: FormulaDataTypes.NUMERIC,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#rounddown',
    },
    ROUNDUP: {
        validation: {
            args: {
                min: 1,
                max: 2,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Rounds up the value after the decimal point to the specified number of decimal places given by "precision" (default is 0).',
        syntax: 'ROUNDUP(value, [precision])',
        examples: ['ROUNDUP({field1})', 'ROUNDUP({field1}, 2)'],
        returnType: FormulaDataTypes.NUMERIC,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#roundup',
    },
    VALUE: {
        validation: {
            args: {
                rqd: 1,
            },
        },
        description: 'Extracts the numeric value from a string, handling % or - appropriately, and returns the resulting numeric value.',
        syntax: 'VALUE(value)',
        examples: ['VALUE({field})', 'VALUE("abc10000%")', 'VALUE("$10000")'],
        returnType: FormulaDataTypes.NUMERIC,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#value',
    },
    JSON_EXTRACT: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/json-functions#json_extract',
        validation: {
            args: {
                min: 2,
                max: 2,
                type: [FormulaDataTypes.STRING, FormulaDataTypes.STRING],
            },
        },
        description: 'Extracts a value from a JSON string using a jq-like syntax',
        syntax: 'JSON_EXTRACT(json_string, path)',
        examples: [
            'JSON_EXTRACT(\'{"a": {"b": "c"}}\', \'.a.b\') => "c"',
            "JSON_EXTRACT({json_column}, '.key')",
        ],
        returnType: FormulaDataTypes.STRING,
    },
    // Disabling these functions for now; these act as alias for CreatedAt & UpdatedAt fields;
    // Issue: Error noticed if CreatedAt & UpdatedAt fields are removed from the table after creating these formulas
    //
    // CREATED_TIME: {
    //   validation: {
    //     args: {
    //       rqd: 0,
    //     },
    //   },
    //   description: 'Returns the created time of the current record if it exists',
    //   syntax: 'CREATED_TIME()',
    //   examples: ['CREATED_TIME()'],
    // },
    // LAST_MODIFIED_TIME: {
    //   validation: {
    //     args: {
    //       rqd: 0,
    //     },
    //   },
    //   description: 'Returns the last modified time of the current record if it exists',
    //   syntax: ' LAST_MODIFIED_TIME()',
    //   examples: [' LAST_MODIFIED_TIME()'],
    // },
};
export class FormulaError extends Error {
    constructor(type, extra, message = 'Formula Error') {
        super(message);
        this.type = type;
        this.extra = extra;
    }
}
function extractColumnIdentifierType(_a) {
    return __awaiter(this, arguments, void 0, function* ({ col, columns, getMeta, clientOrSqlUi, }) {
        const res = {};
        const sqlUI = typeof clientOrSqlUi === 'string'
            ? SqlUiFactory.create({ client: clientOrSqlUi })
            : clientOrSqlUi;
        switch (col === null || col === void 0 ? void 0 : col.uidt) {
            // string
            case UITypes.SingleLineText:
            case UITypes.LongText:
            case UITypes.MultiSelect:
            case UITypes.SingleSelect:
            case UITypes.PhoneNumber:
            case UITypes.Email:
            case UITypes.URL:
            case UITypes.User:
            case UITypes.CreatedBy:
            case UITypes.LastModifiedBy:
                res.dataType = FormulaDataTypes.STRING;
                break;
            // numeric
            case UITypes.Year:
            case UITypes.Number:
            case UITypes.Decimal:
            case UITypes.Rating:
            case UITypes.Count:
            case UITypes.AutoNumber:
                res.dataType = FormulaDataTypes.NUMERIC;
                break;
            // date
            case UITypes.Date:
            case UITypes.DateTime:
            case UITypes.CreatedTime:
            case UITypes.LastModifiedTime:
                res.dataType = FormulaDataTypes.DATE;
                break;
            case UITypes.Currency:
            case UITypes.Percent:
            case UITypes.Duration:
            case UITypes.Links:
                res.dataType = FormulaDataTypes.NUMERIC;
                break;
            case UITypes.Rollup:
                {
                    const rollupFunction = col.colOptions.rollup_function;
                    if ([
                        'count',
                        'avg',
                        'sum',
                        'countDistinct',
                        'sumDistinct',
                        'avgDistinct',
                    ].includes(rollupFunction)) {
                        // these functions produce a numeric value, which can be used in numeric functions
                        res.dataType = FormulaDataTypes.NUMERIC;
                    }
                    else {
                        const relationColumnOpt = columns.find((column) => column.id === col.colOptions.fk_relation_column_id);
                        // the value is based on the foreign rollup column type
                        const refTableMeta = yield getMeta(relationColumnOpt.colOptions
                            .fk_related_model_id);
                        const refTableColumns = refTableMeta.columns;
                        const childFieldColumn = refTableColumns.find((column) => column.id === col.colOptions.fk_rollup_column_id);
                        // extract type and add to res
                        Object.assign(res, yield extractColumnIdentifierType({
                            col: childFieldColumn,
                            columns: refTableColumns,
                            getMeta,
                            clientOrSqlUi,
                        }));
                    }
                }
                break;
            case UITypes.Attachment:
                res.dataType = FormulaDataTypes.STRING;
                break;
            case UITypes.Checkbox:
                if (col.dt === 'boolean' || col.dt === 'bool') {
                    res.dataType = FormulaDataTypes.BOOLEAN;
                }
                else {
                    res.dataType = FormulaDataTypes.NUMERIC;
                }
                break;
            case UITypes.Time:
                res.dataType = FormulaDataTypes.INTERVAL;
                break;
            case UITypes.ID:
            case UITypes.ForeignKey:
            case UITypes.SpecificDBType:
                {
                    if (sqlUI) {
                        const abstractType = sqlUI.getAbstractType(col);
                        if (['integer', 'float', 'decimal'].includes(abstractType)) {
                            res.dataType = FormulaDataTypes.NUMERIC;
                        }
                        else if (['boolean'].includes(abstractType)) {
                            res.dataType = FormulaDataTypes.BOOLEAN;
                        }
                        else if (['date', 'datetime', 'time', 'year'].includes(abstractType)) {
                            res.dataType = FormulaDataTypes.DATE;
                        }
                        else {
                            res.dataType = FormulaDataTypes.STRING;
                        }
                    }
                    else {
                        res.dataType = FormulaDataTypes.UNKNOWN;
                    }
                }
                break;
            // not supported
            case UITypes.Lookup:
            case UITypes.LinkToAnotherRecord:
                res.dataType = FormulaDataTypes.ARRAY;
                break;
            case UITypes.Barcode:
            case UITypes.Button:
            case UITypes.Collaborator:
            case UITypes.QrCode:
            default:
                res.dataType = FormulaDataTypes.UNKNOWN;
                break;
        }
        return res;
    });
}
export function validateFormulaAndExtractTreeWithType(_a) {
    return __awaiter(this, arguments, void 0, function* ({ formula, column, columns, clientOrSqlUi, getMeta, }) {
        const sqlUI = typeof clientOrSqlUi === 'string'
            ? SqlUiFactory.create({ client: clientOrSqlUi })
            : clientOrSqlUi;
        const colAliasToColMap = {};
        const colIdToColMap = {};
        for (const col of columns) {
            colAliasToColMap[col.title] = col;
            colIdToColMap[col.id] = col;
        }
        const validateAndExtract = (parsedTree) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g;
            const res = Object.assign({}, parsedTree);
            if (parsedTree.type === JSEPNode.CALL_EXP) {
                const calleeName = parsedTree.callee.name.toUpperCase();
                // validate function name
                if (!formulas[calleeName]) {
                    throw new FormulaError(FormulaErrorType.INVALID_FUNCTION_NAME, {}, `Function ${calleeName} is not available`);
                }
                else if (sqlUI === null || sqlUI === void 0 ? void 0 : sqlUI.getUnsupportedFnList().includes(calleeName)) {
                    throw new FormulaError(FormulaErrorType.INVALID_FUNCTION_NAME, {}, `Function ${calleeName} is unavailable for your database`);
                }
                // validate arguments
                const validation = formulas[calleeName] && formulas[calleeName].validation;
                if (validation && validation.args) {
                    if (validation.args.rqd !== undefined &&
                        validation.args.rqd !== parsedTree.arguments.length) {
                        throw new FormulaError(FormulaErrorType.INVALID_ARG, {
                            key: 'msg.formula.requiredArgumentsFormula',
                            requiredArguments: validation.args.rqd,
                            calleeName,
                        }, 'Required arguments missing');
                    }
                    else if (validation.args.min !== undefined &&
                        validation.args.min > parsedTree.arguments.length) {
                        throw new FormulaError(FormulaErrorType.MIN_ARG, {
                            key: 'msg.formula.minRequiredArgumentsFormula',
                            minRequiredArguments: validation.args.min,
                            calleeName,
                        }, 'Minimum arguments required');
                    }
                    else if (validation.args.max !== undefined &&
                        validation.args.max < parsedTree.arguments.length) {
                        throw new FormulaError(FormulaErrorType.INVALID_ARG, {
                            key: 'msg.formula.maxRequiredArgumentsFormula',
                            maxRequiredArguments: validation.args.max,
                            calleeName,
                        }, 'Maximum arguments missing');
                    }
                }
                // get args type and validate
                const validateResult = (res.arguments =
                    yield Promise.all(parsedTree.arguments.map((arg) => {
                        return validateAndExtract(arg);
                    })));
                const argTypes = validateResult.map((v) => v.dataType);
                // if validation function is present, call it
                if ((_a = formulas[calleeName].validation) === null || _a === void 0 ? void 0 : _a.custom) {
                    (_b = formulas[calleeName].validation) === null || _b === void 0 ? void 0 : _b.custom(argTypes, parsedTree);
                }
                // validate against expected arg types if present
                else if ((_d = (_c = formulas[calleeName].validation) === null || _c === void 0 ? void 0 : _c.args) === null || _d === void 0 ? void 0 : _d.type) {
                    for (let i = 0; i < validateResult.length; i++) {
                        const argPt = validateResult[i];
                        // if type
                        const expectedArgType = Array.isArray(formulas[calleeName].validation.args.type)
                            ? formulas[calleeName].validation.args.type[i]
                            : formulas[calleeName].validation.args.type;
                        if (argPt.dataType !== expectedArgType &&
                            argPt.dataType !== FormulaDataTypes.NULL &&
                            argPt.dataType !== FormulaDataTypes.UNKNOWN &&
                            expectedArgType !== FormulaDataTypes.STRING) {
                            if (argPt.type === JSEPNode.IDENTIFIER) {
                                const name = ((_e = columns === null || columns === void 0 ? void 0 : columns.find((c) => c.id === argPt.name || c.title === argPt.name)) === null || _e === void 0 ? void 0 : _e.title) || argPt.name;
                                throw new FormulaError(FormulaErrorType.INVALID_ARG, {
                                    key: 'msg.formula.columnWithTypeFoundButExpected',
                                    columnName: name,
                                    columnType: argPt.dataType,
                                    expectedType: expectedArgType,
                                }, `Field ${name} with ${argPt.dataType} type is found but ${expectedArgType} type is expected`);
                            }
                            else {
                                let key = '';
                                const position = i + 1;
                                let type = '';
                                if (expectedArgType === FormulaDataTypes.NUMERIC) {
                                    key = 'msg.formula.typeIsExpected';
                                    type = 'numeric';
                                }
                                else if (expectedArgType === FormulaDataTypes.BOOLEAN) {
                                    key = 'msg.formula.typeIsExpected';
                                    type = 'boolean';
                                }
                                else if (expectedArgType === FormulaDataTypes.DATE) {
                                    key = 'msg.formula.typeIsExpected';
                                    type = 'date';
                                }
                                throw new FormulaError(FormulaErrorType.INVALID_ARG, {
                                    type,
                                    key,
                                    position,
                                    calleeName,
                                }, `${calleeName === null || calleeName === void 0 ? void 0 : calleeName.toUpperCase()} requires a ${type || expectedArgType} at position ${position}`);
                            }
                        }
                        // if expected type is string and arg type is not string, then cast it to string
                        if (expectedArgType === FormulaDataTypes.STRING &&
                            expectedArgType !== argPt.dataType) {
                            argPt.cast = FormulaDataTypes.STRING;
                        }
                    }
                }
                if (typeof formulas[calleeName].returnType === 'function') {
                    res.dataType = (_g = (_f = formulas[calleeName]).returnType) === null || _g === void 0 ? void 0 : _g.call(_f, argTypes);
                }
                else if (formulas[calleeName].returnType) {
                    res.dataType = formulas[calleeName].returnType;
                }
            }
            else if (parsedTree.type === JSEPNode.IDENTIFIER) {
                const col = (colIdToColMap[parsedTree.name] ||
                    colAliasToColMap[parsedTree.name]);
                if (!col) {
                    throw new FormulaError(FormulaErrorType.INVALID_COLUMN, {
                        key: 'msg.formula.columnNotAvailable',
                        columnName: parsedTree.name,
                    }, `Invalid column name/id ${JSON.stringify(parsedTree.name)} in formula`);
                }
                res.name = col.id;
                if ((col === null || col === void 0 ? void 0 : col.uidt) === UITypes.Formula) {
                    if (column) {
                        // check for circular reference when column is present(only available when calling root formula)
                        yield checkForCircularFormulaRef(column, parsedTree, columns, getMeta);
                    }
                    const formulaRes = col.colOptions.parsed_tree ||
                        (yield validateFormulaAndExtractTreeWithType(
                        // formula may include double curly brackets in previous version
                        // convert to single curly bracket here for compatibility
                        {
                            formula: col.colOptions.formula
                                .replaceAll('{{', '{')
                                .replaceAll('}}', '}'),
                            columns,
                            clientOrSqlUi,
                            getMeta,
                        }));
                    res.dataType = formulaRes === null || formulaRes === void 0 ? void 0 : formulaRes.dataType;
                }
                else {
                    if ((col === null || col === void 0 ? void 0 : col.uidt) === UITypes.Lookup ||
                        (col === null || col === void 0 ? void 0 : col.uidt) === UITypes.LinkToAnotherRecord) {
                        // check for circular reference when column is present(only available when calling root formula)
                        if (column) {
                            yield checkForCircularFormulaRef(column, parsedTree, columns, getMeta);
                        }
                    }
                    // extract type and add to res
                    Object.assign(res, yield extractColumnIdentifierType({
                        col,
                        columns,
                        getMeta,
                        clientOrSqlUi,
                    }));
                }
            }
            else if (parsedTree.type === JSEPNode.LITERAL) {
                if (typeof parsedTree.value === 'number') {
                    res.dataType = FormulaDataTypes.NUMERIC;
                }
                else if (typeof parsedTree.value === 'string') {
                    res.dataType = FormulaDataTypes.STRING;
                }
                else if (typeof parsedTree.value === 'boolean') {
                    res.dataType = FormulaDataTypes.BOOLEAN;
                }
                else {
                    res.dataType = FormulaDataTypes.STRING;
                }
            }
            else if (parsedTree.type === JSEPNode.UNARY_EXP) {
                // only support -ve values
                if (['-'].includes(parsedTree.operator) &&
                    parsedTree.argument.type === JSEPNode.LITERAL &&
                    typeof parsedTree.argument.value === 'number') {
                    res.dataType = FormulaDataTypes.NUMERIC;
                }
                else {
                    throw new FormulaError(FormulaErrorType.NOT_SUPPORTED, {}, `Unary expression '${parsedTree.operator}' is not supported`);
                }
            }
            else if (parsedTree.type === JSEPNode.BINARY_EXP) {
                res.left = yield validateAndExtract(parsedTree.left);
                res.right = yield validateAndExtract(parsedTree.right);
                const dateAndTimeParsedNode = handleBinaryExpressionForDateAndTime({
                    sourceBinaryNode: res,
                });
                if (dateAndTimeParsedNode) {
                    Object.assign(res, handleBinaryExpressionForDateAndTime({ sourceBinaryNode: res }));
                    if (res.type !== JSEPNode.BINARY_EXP) {
                        res.left = undefined;
                        res.right = undefined;
                        res.operator = undefined;
                    }
                }
                else if (['==', '<', '>', '<=', '>=', '!='].includes(parsedTree.operator)) {
                    res.dataType = FormulaDataTypes.COND_EXP;
                }
                else if (parsedTree.operator === '+') {
                    res.dataType = FormulaDataTypes.NUMERIC;
                    // if any side is string/date/other type, then the result will be concatenated string
                    // e.g. 1 + '2' = '12'
                    if ([
                        res.left,
                        res.right,
                    ].some((r) => ![
                        FormulaDataTypes.NUMERIC,
                        FormulaDataTypes.BOOLEAN,
                        FormulaDataTypes.NULL,
                        FormulaDataTypes.UNKNOWN,
                    ].includes(r.dataType))) {
                        res.dataType = FormulaDataTypes.STRING;
                    }
                }
                else if (['&'].includes(parsedTree.operator)) {
                    res.dataType = FormulaDataTypes.STRING;
                }
                else {
                    res.dataType = FormulaDataTypes.NUMERIC;
                }
            }
            else if (parsedTree.type === JSEPNode.MEMBER_EXP) {
                throw new FormulaError(FormulaErrorType.NOT_SUPPORTED, {}, 'Bracket notation is not supported');
            }
            else if (parsedTree.type === JSEPNode.ARRAY_EXP) {
                throw new FormulaError(FormulaErrorType.NOT_SUPPORTED, {}, 'Array is not supported');
            }
            else if (parsedTree.type === JSEPNode.COMPOUND) {
                throw new FormulaError(FormulaErrorType.NOT_SUPPORTED, {}, 'Compound statement is not supported');
            }
            return res;
        });
        // register jsep curly hook
        jsep.plugins.register(jsepCurlyHook);
        const parsedFormula = jsep(formula);
        // TODO: better jsep expression handling
        const result = yield validateAndExtract(parsedFormula);
        return result;
    });
}
function handleBinaryExpressionForDateAndTime(params) {
    const { sourceBinaryNode } = params;
    let res;
    if ([FormulaDataTypes.DATE, FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.left.dataType) &&
        [FormulaDataTypes.DATE, FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.right.dataType) &&
        sourceBinaryNode.operator === '-') {
        // when it's interval and interval, we return diff in minute (numeric)
        if ([FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.left.dataType) &&
            [FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.right.dataType)) {
            res = {
                type: JSEPNode.CALL_EXP,
                arguments: [
                    sourceBinaryNode.left,
                    sourceBinaryNode.right,
                    {
                        type: 'Literal',
                        value: 'minutes',
                        raw: '"minutes"',
                        dataType: 'string',
                    },
                ],
                callee: {
                    type: 'Identifier',
                    name: 'DATETIME_DIFF',
                },
                dataType: FormulaDataTypes.NUMERIC,
            };
        }
        // when it's date - date, show the difference in minute
        else if ([FormulaDataTypes.DATE].includes(sourceBinaryNode.left.dataType) &&
            [FormulaDataTypes.DATE].includes(sourceBinaryNode.right.dataType)) {
            res = {
                type: JSEPNode.CALL_EXP,
                arguments: [
                    sourceBinaryNode.left,
                    sourceBinaryNode.right,
                    {
                        type: 'Literal',
                        value: 'minutes',
                        raw: '"minutes"',
                        dataType: 'string',
                    },
                ],
                callee: {
                    type: 'Identifier',
                    name: 'DATETIME_DIFF',
                },
                dataType: FormulaDataTypes.NUMERIC,
            };
        }
        // else interval and date can be addedd seamlessly A - B
        // with result as DATE
        // may be changed if we find other db use case
        else if ([FormulaDataTypes.INTERVAL, FormulaDataTypes.DATE].includes(sourceBinaryNode.left.dataType) &&
            [FormulaDataTypes.INTERVAL, FormulaDataTypes.DATE].includes(sourceBinaryNode.right.dataType) &&
            sourceBinaryNode.left.dataType != sourceBinaryNode.right.dataType) {
            res = {
                type: JSEPNode.BINARY_EXP,
                left: sourceBinaryNode.left,
                right: sourceBinaryNode.right,
                operator: '-',
                dataType: FormulaDataTypes.DATE,
            };
        }
    }
    else if ([FormulaDataTypes.DATE, FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.left.dataType) &&
        [FormulaDataTypes.DATE, FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.right.dataType) &&
        sourceBinaryNode.operator === '+') {
        // when it's interval and interval, we return addition in minute (numeric)
        if ([FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.left.dataType) &&
            [FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.right.dataType)) {
            const left = {
                type: JSEPNode.CALL_EXP,
                arguments: [
                    sourceBinaryNode.left,
                    {
                        type: 'Literal',
                        value: '00:00:00',
                        raw: '"00:00:00"',
                        dataType: FormulaDataTypes.INTERVAL,
                    },
                    {
                        type: 'Literal',
                        value: 'minutes',
                        raw: '"minutes"',
                        dataType: 'string',
                    },
                ],
                callee: {
                    type: 'Identifier',
                    name: 'DATETIME_DIFF',
                },
                dataType: FormulaDataTypes.NUMERIC,
            };
            const right = {
                type: JSEPNode.CALL_EXP,
                arguments: [
                    sourceBinaryNode.right,
                    {
                        type: 'Literal',
                        value: '00:00:00',
                        raw: '"00:00:00"',
                        dataType: FormulaDataTypes.INTERVAL,
                    },
                    {
                        type: 'Literal',
                        value: 'minutes',
                        raw: '"minutes"',
                        dataType: 'string',
                    },
                ],
                callee: {
                    type: 'Identifier',
                    name: 'DATETIME_DIFF',
                },
                dataType: FormulaDataTypes.NUMERIC,
            };
            return {
                type: JSEPNode.BINARY_EXP,
                left,
                right,
                operator: '+',
                dataType: FormulaDataTypes.NUMERIC,
            };
        }
        // else interval and date can be addedd seamlessly A + B
        // with result as DATE
        // may be changed if we find other db use case
        else if ([FormulaDataTypes.INTERVAL, FormulaDataTypes.DATE].includes(sourceBinaryNode.left.dataType) &&
            [FormulaDataTypes.INTERVAL, FormulaDataTypes.DATE].includes(sourceBinaryNode.right.dataType) &&
            sourceBinaryNode.left.dataType != sourceBinaryNode.right.dataType) {
            res = {
                type: JSEPNode.BINARY_EXP,
                left: sourceBinaryNode.left,
                right: sourceBinaryNode.right,
                operator: '+',
                dataType: FormulaDataTypes.DATE,
            };
        }
    }
    return res;
}
function checkForCircularFormulaRef(formulaCol, parsedTree, columns, getMeta) {
    return __awaiter(this, void 0, void 0, function* () {
        // Extract formula references
        const formulaPaths = yield columns.reduce((promiseRes, c) => __awaiter(this, void 0, void 0, function* () {
            const res = yield promiseRes;
            if (c.id !== formulaCol.id && c.uidt === UITypes.Formula) {
                const neighbours = [
                    ...new Set((c.colOptions.formula.match(/c_?\w{14,15}/g) || []).filter((colId) => columns.some((col) => col.id === colId && col.uidt === UITypes.Formula))),
                ];
                if (neighbours.length)
                    res.push({ [c.id]: neighbours });
            }
            else if (c.uidt === UITypes.Lookup ||
                c.uidt === UITypes.LinkToAnotherRecord) {
                const neighbours = yield processLookupOrLTARColumn(c);
                if (neighbours === null || neighbours === void 0 ? void 0 : neighbours.length)
                    res.push({ [c.id]: neighbours });
            }
            return res;
        }), Promise.resolve([]));
        function processLookupFormula(col, columns) {
            return __awaiter(this, void 0, void 0, function* () {
                const neighbours = [];
                if (formulaCol.fk_model_id === col.fk_model_id) {
                    return [col.id];
                }
                // Extract columns used in the formula and check for cycles
                const referencedColumns = col.colOptions.formula.match(/c_?\w{14,15}/g) || [];
                for (const refColId of referencedColumns) {
                    const refCol = columns.find((c) => c.id === refColId);
                    if (refCol.uidt === UITypes.Formula) {
                        neighbours.push(...(yield processLookupFormula(refCol, columns)));
                    }
                    else if (refCol.uidt === UITypes.Lookup ||
                        refCol.uidt === UITypes.LinkToAnotherRecord) {
                        neighbours.push(...(yield processLookupOrLTARColumn(refCol)));
                    }
                }
                return neighbours;
            });
        }
        // Function to process lookup columns recursively
        function processLookupOrLTARColumn(lookupOrLTARCol) {
            return __awaiter(this, void 0, void 0, function* () {
                const neighbours = [];
                let ltarColumn;
                let lookupFilterFn;
                if (lookupOrLTARCol.uidt === UITypes.Lookup) {
                    const relationColId = lookupOrLTARCol.colOptions
                        .fk_relation_column_id;
                    const lookupColId = lookupOrLTARCol.colOptions
                        .fk_lookup_column_id;
                    ltarColumn = columns.find((c) => c.id === relationColId);
                    lookupFilterFn = (column) => column.id === lookupColId;
                }
                else if (lookupOrLTARCol.uidt === UITypes.LinkToAnotherRecord) {
                    ltarColumn = lookupOrLTARCol;
                    lookupFilterFn = (column) => !!column.pv;
                }
                if (ltarColumn) {
                    const relatedTableMeta = yield getMeta(ltarColumn.colOptions.fk_related_model_id);
                    const lookupTarget = relatedTableMeta.columns.find(lookupFilterFn);
                    if (lookupTarget) {
                        if (lookupTarget.uidt === UITypes.Formula) {
                            neighbours.push(...(yield processLookupFormula(lookupTarget, relatedTableMeta.columns)));
                        }
                        else if (lookupTarget.uidt === UITypes.Lookup ||
                            lookupTarget.uidt === UITypes.LinkToAnotherRecord) {
                            neighbours.push(...(yield processLookupOrLTARColumn(lookupTarget)));
                        }
                    }
                }
                return [...new Set(neighbours)];
            });
        }
        // include target formula column (i.e. the one to be saved if applicable)
        const targetFormulaCol = columns.find((c) => c.title === parsedTree.name &&
            [UITypes.Formula, UITypes.LinkToAnotherRecord, UITypes.Lookup].includes(c.uidt));
        if (targetFormulaCol && (formulaCol === null || formulaCol === void 0 ? void 0 : formulaCol.id)) {
            formulaPaths.push({
                [formulaCol === null || formulaCol === void 0 ? void 0 : formulaCol.id]: [targetFormulaCol.id],
            });
        }
        const vertices = formulaPaths.length;
        if (vertices > 0) {
            // perform kahn's algo for cycle detection
            const adj = new Map();
            const inDegrees = new Map();
            // init adjacency list & indegree
            for (const [_, v] of Object.entries(formulaPaths)) {
                const src = Object.keys(v)[0];
                const neighbours = v[src];
                inDegrees.set(src, inDegrees.get(src) || 0);
                for (const neighbour of neighbours) {
                    adj.set(src, (adj.get(src) || new Set()).add(neighbour));
                    inDegrees.set(neighbour, (inDegrees.get(neighbour) || 0) + 1);
                }
            }
            const queue = [];
            // put all vertices with in-degree = 0 (i.e. no incoming edges) to queue
            inDegrees.forEach((inDegree, col) => {
                if (inDegree === 0) {
                    // in-degree = 0 means we start traversing from this node
                    queue.push(col);
                }
            });
            // init count of visited vertices
            let visited = 0;
            // BFS
            while (queue.length !== 0) {
                // remove a vertex from the queue
                const src = queue.shift();
                // if this node has neighbours, increase visited by 1
                const neighbours = adj.get(src) || new Set();
                if (neighbours.size > 0) {
                    visited += 1;
                }
                // iterate each neighbouring nodes
                neighbours.forEach((neighbour) => {
                    // decrease in-degree of its neighbours by 1
                    inDegrees.set(neighbour, inDegrees.get(neighbour) - 1);
                    // if in-degree becomes 0
                    if (inDegrees.get(neighbour) === 0) {
                        // then put the neighboring node to the queue
                        queue.push(neighbour);
                    }
                });
            }
            // vertices not same as visited = cycle found
            if (vertices !== visited) {
                throw new FormulaError(FormulaErrorType.CIRCULAR_REFERENCE, {
                    key: 'msg.formula.cantSaveCircularReference',
                }, 'Circular reference detected');
            }
        }
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybXVsYUhlbHBlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL2Zvcm11bGFIZWxwZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLE9BQU8sSUFBSSxNQUFNLE1BQU0sQ0FBQztBQVV4QixPQUFPLE9BQU8sTUFBTSxXQUFXLENBQUM7QUFDaEMsT0FBTyxLQUFLLE1BQU0sT0FBTyxDQUFDO0FBQzFCLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFDdkMsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBYy9DLE1BQU0sQ0FBQyxNQUFNLGVBQWUsR0FBRyxDQUFDLElBQUksRUFBRSxHQUFHLENBQVUsQ0FBQztBQUNwRCxNQUFNLENBQUMsTUFBTSxtQkFBbUIsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBVSxDQUFDO0FBQ2pFLE1BQU0sQ0FBQyxNQUFNLG1CQUFtQixHQUFHO0lBQ2pDLElBQUk7SUFDSixHQUFHO0lBQ0gsR0FBRztJQUNILEdBQUc7SUFDSCxJQUFJO0lBQ0osSUFBSTtJQUNKLElBQUk7Q0FDSSxDQUFDO0FBbUVYLGtDQUFrQztBQUNsQyxNQUFNLFdBQVcsR0FBRyxHQUFHLENBQUMsQ0FBQyxNQUFNO0FBQy9CLE1BQU0sV0FBVyxHQUFHLEdBQUcsQ0FBQyxDQUFDLE1BQU07QUFFL0IsTUFBTSxDQUFDLE1BQU0sYUFBYSxHQUFHO0lBQzNCLElBQUksRUFBRSxPQUFPO0lBQ2IsSUFBSSxDQUFDLElBQUk7UUFDUCxtREFBbUQ7UUFDbkQsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsY0FBYyxFQUFFLFNBQVMsaUJBQWlCLENBQUMsR0FBRztZQUMzRCx5REFBeUQ7WUFDekQsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLFdBQVcsRUFBRSxDQUFDO2dCQUM5QixNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO2dCQUNoQyxtRUFBbUU7Z0JBQ25FLE9BQU8sSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO29CQUNyQyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUM7b0JBQ2IsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLFdBQVcsRUFBRSxDQUFDO3dCQUM5QixJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLEVBQUUsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7d0JBRTdELGlGQUFpRjt3QkFDakYsdUNBQXVDO3dCQUN2QyxJQUNFLFVBQVUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDOzRCQUMzQixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQzNELENBQUM7NEJBQ0QsVUFBVSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksRUFBRSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQzt3QkFDM0QsQ0FBQzt3QkFDRCxHQUFHLENBQUMsSUFBSSxHQUFHOzRCQUNULElBQUksRUFBRSxJQUFJLENBQUMsVUFBVTs0QkFDckIsSUFBSSxFQUFFLFVBQVUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO2dDQUMvQixDQUFDLENBQUMseURBQXlEO29DQUN6RCxzRUFBc0U7b0NBQ3RFLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dDQUN6QixDQUFDLENBQUMseURBQXlEO29DQUN6RCxvRUFBb0U7b0NBQ3BFLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDOzRCQUMzQixHQUFHLEVBQUUsVUFBVTt5QkFDaEIsQ0FBQzt3QkFFRixpREFBaUQ7d0JBQ2pELE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQztvQkFDbEIsQ0FBQztnQkFDSCxDQUFDO2dCQUNELElBQUksQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDaEMsQ0FBQztRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztDQUNjLENBQUM7QUFFbEIsU0FBUyw2QkFBNkIsQ0FBQyxDQUFTO0lBQzlDLEtBQUssTUFBTSxNQUFNLElBQUksV0FBVyxFQUFFLENBQUM7UUFDakMsSUFBSSxLQUFLLENBQUMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQVMsRUFBRSxDQUFDO1lBQzVDLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUNELEtBQUssTUFBTSxVQUFVLElBQUksQ0FBQyxPQUFPLEVBQUUsVUFBVSxFQUFFLGNBQWMsQ0FBQyxFQUFFLENBQUM7WUFDL0QsSUFBSSxLQUFLLENBQUMsQ0FBQyxFQUFFLEdBQUcsTUFBTSxJQUFJLFVBQVUsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBUyxFQUFFLENBQUM7Z0JBQy9ELE9BQU8sSUFBSSxDQUFDO1lBQ2QsQ0FBQztRQUNILENBQUM7SUFDSCxDQUFDO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBRUQsTUFBTSxVQUFnQixvQ0FBb0MsQ0FDeEQsT0FBTyxFQUNQLE9BQXFCOztRQUVyQixNQUFNLFlBQVksR0FBRyxDQUFPLEVBQU8sRUFBRSxFQUFFO1lBQ3JDLElBQUksRUFBRSxDQUFDLElBQUksS0FBSyxnQkFBZ0IsRUFBRSxDQUFDO2dCQUNqQyxLQUFLLE1BQU0sR0FBRyxJQUFJLEVBQUUsQ0FBQyxTQUFTLElBQUksRUFBRSxFQUFFLENBQUM7b0JBQ3JDLE1BQU0sWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUMxQixDQUFDO1lBQ0gsQ0FBQztpQkFBTSxJQUFJLEVBQUUsQ0FBQyxJQUFJLEtBQUssU0FBUyxFQUFFLENBQUM7Z0JBQ2pDLE9BQU87WUFDVCxDQUFDO2lCQUFNLElBQUksRUFBRSxDQUFDLElBQUksS0FBSyxZQUFZLEVBQUUsQ0FBQztnQkFDcEMsTUFBTSxXQUFXLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQztnQkFDNUIsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FDekIsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUNKLENBQUMsQ0FBQyxFQUFFLEtBQUssV0FBVztvQkFDcEIsQ0FBQyxDQUFDLFdBQVcsS0FBSyxXQUFXO29CQUM3QixDQUFDLENBQUMsS0FBSyxLQUFLLFdBQVcsQ0FDMUIsQ0FBQztnQkFDRixFQUFFLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxNQUFNLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQztZQUNsQyxDQUFDO2lCQUFNLElBQUksRUFBRSxDQUFDLElBQUksS0FBSyxrQkFBa0IsRUFBRSxDQUFDO2dCQUMxQyxNQUFNLFlBQVksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQzVCLE1BQU0sWUFBWSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUMvQixDQUFDO1FBQ0gsQ0FBQyxDQUFBLENBQUM7UUFDRiwyQkFBMkI7UUFDM0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDckMsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3BDLE1BQU0sWUFBWSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ2xDLE9BQU8saUJBQWlCLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDMUMsQ0FBQztDQUFBO0FBRUQsTUFBTSxDQUFOLElBQVksZ0JBYVg7QUFiRCxXQUFZLGdCQUFnQjtJQUMxQixtREFBK0IsQ0FBQTtJQUMvQixtREFBK0IsQ0FBQTtJQUMvQix1Q0FBbUIsQ0FBQTtJQUNuQix1Q0FBbUIsQ0FBQTtJQUNuQixtREFBK0IsQ0FBQTtJQUMvQiwrQ0FBMkIsQ0FBQTtJQUMzQix5REFBcUMsQ0FBQTtJQUNyQywyREFBdUMsQ0FBQTtJQUN2QywyREFBdUMsQ0FBQTtJQUN2Qyw2REFBeUMsQ0FBQTtJQUN6QyxtRUFBK0MsQ0FBQTtJQUMvQyxxREFBaUMsQ0FBQTtBQUNuQyxDQUFDLEVBYlcsZ0JBQWdCLEtBQWhCLGdCQUFnQixRQWEzQjtBQUVELE1BQU0sVUFBVSxvQ0FBb0MsQ0FDbEQsT0FBTyxFQUNQLE9BQXFCLEVBQ3JCLFVBQVc7SUFFWCxNQUFNLFlBQVksR0FBRyxDQUFDLEVBQU8sRUFBRSxLQUFXLEVBQUUsRUFBRTs7UUFDNUMsSUFBSSxFQUFFLENBQUMsSUFBSSxLQUFLLGdCQUFnQixFQUFFLENBQUM7WUFDakMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ1YsS0FBSyxNQUFNLEdBQUcsSUFBSSxFQUFFLENBQUMsU0FBUyxJQUFJLEVBQUUsRUFBRSxDQUFDO2dCQUNyQyxZQUFZLENBQUMsR0FBRyxFQUFFLE1BQUEsS0FBSyxhQUFMLEtBQUssdUJBQUwsS0FBSyxDQUFFLFNBQVMsMENBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQzdDLENBQUM7UUFDSCxDQUFDO2FBQU0sSUFBSSxFQUFFLENBQUMsSUFBSSxLQUFLLFNBQVMsRUFBRSxDQUFDO1lBQ2pDLE9BQU87UUFDVCxDQUFDO2FBQU0sSUFBSSxFQUFFLENBQUMsSUFBSSxLQUFLLFlBQVksRUFBRSxDQUFDO1lBQ3BDLE1BQU0sV0FBVyxHQUFHLEVBQUUsYUFBRixFQUFFLHVCQUFGLEVBQUUsQ0FBRSxJQUFJLENBQUM7WUFDN0IsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FDekIsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUNKLENBQUMsQ0FBQyxFQUFFLEtBQUssV0FBVztnQkFDcEIsQ0FBQyxDQUFDLFdBQVcsS0FBSyxXQUFXO2dCQUM3QixDQUFDLENBQUMsS0FBSyxLQUFLLFdBQVcsQ0FDMUIsQ0FBQztZQUNGLEVBQUUsQ0FBQyxJQUFJLEdBQUcsQ0FBQSxNQUFNLGFBQU4sTUFBTSx1QkFBTixNQUFNLENBQUUsS0FBSyxNQUFJLEtBQUssYUFBTCxLQUFLLHVCQUFMLEtBQUssQ0FBRSxJQUFJLENBQUEsS0FBSSxFQUFFLGFBQUYsRUFBRSx1QkFBRixFQUFFLENBQUUsSUFBSSxDQUFBLENBQUM7UUFDckQsQ0FBQzthQUFNLElBQUksRUFBRSxDQUFDLElBQUksS0FBSyxrQkFBa0IsRUFBRSxDQUFDO1lBQzFDLFlBQVksQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFLEtBQUssYUFBTCxLQUFLLHVCQUFMLEtBQUssQ0FBRSxJQUFJLENBQUMsQ0FBQztZQUNuQyxZQUFZLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxLQUFLLGFBQUwsS0FBSyx1QkFBTCxLQUFLLENBQUUsS0FBSyxDQUFDLENBQUM7UUFDdkMsQ0FBQztJQUNILENBQUMsQ0FBQztJQUVGLDJCQUEyQjtJQUMzQixJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUNyQyxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDcEMsTUFBTSxnQkFBZ0IsR0FBRyxVQUFVLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3hELFlBQVksQ0FBQyxhQUFhLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztJQUM5QyxPQUFPLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQzFDLENBQUM7QUFFRCw0REFBNEQ7QUFDNUQscUZBQXFGO0FBQ3JGLE1BQU0sVUFBVSxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsV0FBVyxHQUFHLEtBQUs7SUFDekQsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLGtCQUFrQixJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssbUJBQW1CLEVBQUUsQ0FBQztRQUMxRSxPQUFPLENBQ0wsR0FBRztZQUNILGlCQUFpQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7WUFDNUIsR0FBRztZQUNILElBQUksQ0FBQyxRQUFRO1lBQ2IsR0FBRztZQUNILGlCQUFpQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7WUFDN0IsR0FBRyxDQUNKLENBQUM7SUFDSixDQUFDO0lBRUQsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLGlCQUFpQixFQUFFLENBQUM7UUFDcEMsT0FBTyxJQUFJLENBQUMsUUFBUSxHQUFHLGlCQUFpQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUMxRCxDQUFDO0lBRUQsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLGtCQUFrQixFQUFFLENBQUM7UUFDckMsT0FBTyxDQUNMLGlCQUFpQixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7WUFDOUIsR0FBRztZQUNILGlCQUFpQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7WUFDaEMsR0FBRyxDQUNKLENBQUM7SUFDSixDQUFDO0lBRUQsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLFlBQVksRUFBRSxDQUFDO1FBQy9CLElBQUksQ0FBQyxXQUFXO1lBQUUsT0FBTyxHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7UUFDL0MsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ25CLENBQUM7SUFFRCxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssU0FBUyxFQUFFLENBQUM7UUFDNUIsSUFBSSxPQUFPLElBQUksQ0FBQyxLQUFLLEtBQUssUUFBUSxFQUFFLENBQUM7WUFDbkMsT0FBTyxNQUFNLENBQUMsR0FBRyxDQUFBLElBQUksYUFBYSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztRQUMvRCxDQUFDO1FBQ0QsT0FBTyxFQUFFLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztJQUN6QixDQUFDO0lBRUQsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLGdCQUFnQixFQUFFLENBQUM7UUFDbkMsT0FBTyxDQUNMLGlCQUFpQixDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDO1lBQ3BDLEdBQUc7WUFDSCxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsaUJBQWlCLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQ2xFLEdBQUcsQ0FDSixDQUFDO0lBQ0osQ0FBQztJQUVELElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3BDLE9BQU8sQ0FDTCxHQUFHO1lBQ0gsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztZQUNqRSxHQUFHLENBQ0osQ0FBQztJQUNKLENBQUM7SUFFRCxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssVUFBVSxFQUFFLENBQUM7UUFDN0IsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDOUQsQ0FBQztJQUVELElBQUksSUFBSSxDQUFDLElBQUksS0FBSyx1QkFBdUIsRUFBRSxDQUFDO1FBQzFDLE9BQU8sQ0FDTCxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQzVCLEtBQUs7WUFDTCxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO1lBQ2xDLEtBQUs7WUFDTCxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQ2xDLENBQUM7SUFDSixDQUFDO0lBRUQsT0FBTyxFQUFFLENBQUM7QUFDWixDQUFDO0FBRUQsU0FBUyxhQUFhLENBQUMsQ0FBUztJQUM5QixPQUFPLENBQ0wsQ0FBQztRQUNDLDJDQUEyQztTQUMxQyxPQUFPLENBQUMsb0JBQW9CLEVBQUUsUUFBUSxDQUFDO1FBQ3hDLGtCQUFrQjtTQUNqQixPQUFPLENBQUMsYUFBYSxFQUFFLE9BQU8sQ0FBQztRQUNoQyxrQkFBa0I7U0FDakIsT0FBTyxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsQ0FDbkMsQ0FBQztBQUNKLENBQUM7QUFFRCxNQUFNLENBQU4sSUFBWSxnQkFXWDtBQVhELFdBQVksZ0JBQWdCO0lBQzFCLHVDQUFtQixDQUFBO0lBQ25CLHFDQUFpQixDQUFBO0lBQ2pCLGlDQUFhLENBQUE7SUFDYix1Q0FBbUIsQ0FBQTtJQUNuQixtQ0FBZSxDQUFBO0lBQ2YsdURBQW1DLENBQUE7SUFDbkMsaUNBQWEsQ0FBQTtJQUNiLHVDQUFtQixDQUFBO0lBQ25CLHlDQUFxQixDQUFBO0lBQ3JCLHVDQUFtQixDQUFBO0FBQ3JCLENBQUMsRUFYVyxnQkFBZ0IsS0FBaEIsZ0JBQWdCLFFBVzNCO0FBRUQsTUFBTSxDQUFOLElBQVksUUFVWDtBQVZELFdBQVksUUFBUTtJQUNsQixpQ0FBcUIsQ0FBQTtJQUNyQixxQ0FBeUIsQ0FBQTtJQUN6QiwyQ0FBK0IsQ0FBQTtJQUMvQiwrQkFBbUIsQ0FBQTtJQUNuQix1Q0FBMkIsQ0FBQTtJQUMzQix1Q0FBMkIsQ0FBQTtJQUMzQix5Q0FBNkIsQ0FBQTtJQUM3QiwyQ0FBK0IsQ0FBQTtJQUMvQix5Q0FBNkIsQ0FBQTtBQUMvQixDQUFDLEVBVlcsUUFBUSxLQUFSLFFBQVEsUUFVbkI7QUFzQkQsTUFBTSxDQUFDLE1BQU0sUUFBUSxHQUFnQztJQUNuRCxHQUFHLEVBQUU7UUFDSCxPQUFPLEVBQ0wsMEVBQTBFO1FBQzVFLFVBQVUsRUFBRTtZQUNWLElBQUksRUFBRTtnQkFDSixHQUFHLEVBQUUsQ0FBQztnQkFDTixJQUFJLEVBQUUsZ0JBQWdCLENBQUMsT0FBTzthQUMvQjtTQUNGO1FBQ0QsV0FBVyxFQUFFLDZCQUE2QjtRQUMxQyxNQUFNLEVBQUUsNEJBQTRCO1FBQ3BDLFFBQVEsRUFBRTtZQUNSLG1CQUFtQjtZQUNuQiwyQkFBMkI7WUFDM0Isc0NBQXNDO1NBQ3ZDO1FBQ0QsVUFBVSxFQUFFLGdCQUFnQixDQUFDLE9BQU87S0FDckM7SUFDRCxHQUFHLEVBQUU7UUFDSCxPQUFPLEVBQ0wsMEVBQTBFO1FBQzVFLFVBQVUsRUFBRTtZQUNWLElBQUksRUFBRTtnQkFDSixHQUFHLEVBQUUsQ0FBQztnQkFDTixJQUFJLEVBQUUsZ0JBQWdCLENBQUMsT0FBTzthQUMvQjtTQUNGO1FBQ0QsV0FBVyxFQUFFLHlCQUF5QjtRQUN0QyxNQUFNLEVBQUUsNEJBQTRCO1FBQ3BDLFFBQVEsRUFBRTtZQUNSLGlCQUFpQjtZQUNqQiwyQkFBMkI7WUFDM0Isc0NBQXNDO1NBQ3ZDO1FBQ0QsVUFBVSxFQUFFLGdCQUFnQixDQUFDLE9BQU87S0FDckM7SUFDRCxPQUFPLEVBQUU7UUFDUCxPQUFPLEVBQ0wsMkVBQTJFO1FBQzdFLFVBQVUsRUFBRTtZQUNWLElBQUksRUFBRTtnQkFDSixHQUFHLEVBQUUsQ0FBQztnQkFDTixJQUFJLEVBQUUsZ0JBQWdCLENBQUMsSUFBSTthQUM1QjtZQUNELE1BQU0sRUFBRSxDQUFDLFNBQTZCLEVBQUUsVUFBZSxFQUFFLEVBQUU7Z0JBQ3pELElBQUksVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDLE9BQU8sRUFBRSxDQUFDO29CQUN0RCxJQUFJLENBQUMsNkJBQTZCLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO3dCQUNsRSxNQUFNLElBQUksWUFBWSxDQUNwQixnQkFBZ0IsQ0FBQyxhQUFhLEVBQzlCLEVBQUUsR0FBRyxFQUFFLHVDQUF1QyxFQUFFLEVBQ2hELDZDQUE2QyxDQUM5QyxDQUFDO29CQUNKLENBQUM7Z0JBQ0gsQ0FBQztnQkFFRCxJQUFJLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyxPQUFPLEVBQUUsQ0FBQztvQkFDdEQsSUFBSSxPQUFPLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxLQUFLLFFBQVEsRUFBRSxDQUFDO3dCQUN0RCxNQUFNLElBQUksWUFBWSxDQUNwQixnQkFBZ0IsQ0FBQyxhQUFhLEVBQzlCLEVBQUUsR0FBRyxFQUFFLDBDQUEwQyxFQUFFLEVBQ25ELGdEQUFnRCxDQUNqRCxDQUFDO29CQUNKLENBQUM7Z0JBQ0gsQ0FBQztnQkFDRCxJQUFJLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyxPQUFPLEVBQUUsQ0FBQztvQkFDdEQsSUFDRSxDQUFDLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUN4QyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FDOUIsRUFDRCxDQUFDO3dCQUNELE1BQU0sSUFBSSxZQUFZLENBQ3BCLGdCQUFnQixDQUFDLGFBQWEsRUFDOUIsRUFBRSxHQUFHLEVBQUUsdUNBQXVDLEVBQUUsRUFDaEQsNEVBQTRFLENBQzdFLENBQUM7b0JBQ0osQ0FBQztnQkFDSCxDQUFDO1lBQ0gsQ0FBQztTQUNGO1FBQ0QsV0FBVyxFQUFFLGlDQUFpQztRQUM5QyxNQUFNLEVBQ0osc0VBQXNFO1FBQ3hFLFFBQVEsRUFBRTtZQUNSLDhCQUE4QjtZQUM5QiwrQkFBK0I7WUFDL0IsK0JBQStCO1lBQy9CLGdDQUFnQztZQUNoQyxnQ0FBZ0M7WUFDaEMsaUNBQWlDO1lBQ2pDLCtCQUErQjtZQUMvQixnQ0FBZ0M7U0FDakM7UUFDRCxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsSUFBSTtLQUNsQztJQUNELE9BQU8sRUFBRTtRQUNQLE9BQU8sRUFDTCwyRUFBMkU7UUFDN0UsVUFBVSxFQUFFO1lBQ1YsSUFBSSxFQUFFO2dCQUNKLEdBQUcsRUFBRSxDQUFDO2FBQ1A7U0FDRjtRQUNELE1BQU0sRUFBRSwwQkFBMEI7UUFDbEMsV0FBVyxFQUFFLDBEQUEwRDtRQUN2RSxRQUFRLEVBQUUsQ0FBQyxvQkFBb0IsQ0FBQztRQUNoQyxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsTUFBTTtLQUNwQztJQUNELEdBQUcsRUFBRTtRQUNILE9BQU8sRUFDTCx1RUFBdUU7UUFDekUsVUFBVSxFQUFFO1lBQ1YsSUFBSSxFQUFFO2dCQUNKLEdBQUcsRUFBRSxDQUFDO2FBQ1A7U0FDRjtRQUNELE1BQU0sRUFBRSxzQkFBc0I7UUFDOUIsV0FBVyxFQUFFLHNDQUFzQztRQUNuRCxRQUFRLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQztRQUM1QixVQUFVLEVBQUUsZ0JBQWdCLENBQUMsTUFBTTtLQUNwQztJQUNELEtBQUssRUFBRTtRQUNMLE9BQU8sRUFDTCx5RUFBeUU7UUFDM0UsVUFBVSxFQUFFO1lBQ1YsSUFBSSxFQUFFO2dCQUNKLEdBQUcsRUFBRSxDQUFDO2FBQ1A7U0FDRjtRQUNELE1BQU0sRUFBRSx3QkFBd0I7UUFDaEMsV0FBVyxFQUFFLHdDQUF3QztRQUNyRCxRQUFRLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQztRQUM5QixVQUFVLEVBQUUsZ0JBQWdCLENBQUMsTUFBTTtLQUNwQztJQUNELElBQUksRUFBRTtRQUNKLE9BQU8sRUFDTCx3RUFBd0U7UUFDMUUsVUFBVSxFQUFFO1lBQ1YsSUFBSSxFQUFFO2dCQUNKLEdBQUcsRUFBRSxDQUFDO2FBQ1A7U0FDRjtRQUNELE1BQU0sRUFBRSx1QkFBdUI7UUFDL0IsV0FBVyxFQUFFLGdDQUFnQztRQUM3QyxRQUFRLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQztRQUM3QixVQUFVLEVBQUUsZ0JBQWdCLENBQUMsTUFBTTtLQUNwQztJQUNELElBQUksRUFBRTtRQUNKLE9BQU8sRUFDTCx3RUFBd0U7UUFDMUUsVUFBVSxFQUFFO1lBQ1YsSUFBSSxFQUFFO2dCQUNKLEdBQUcsRUFBRSxDQUFDO2FBQ1A7U0FDRjtRQUNELE1BQU0sRUFBRSxzQkFBc0I7UUFDOUIsV0FBVyxFQUFFLHVDQUF1QztRQUNwRCxRQUFRLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQztRQUM3QixVQUFVLEVBQUUsZ0JBQWdCLENBQUMsTUFBTTtLQUNwQztJQUNELGFBQWEsRUFBRTtRQUNiLE9BQU8sRUFDTCxpRkFBaUY7UUFFbkYsVUFBVSxFQUFFO1lBQ1YsSUFBSSxFQUFFO2dCQUNKLEdBQUcsRUFBRSxDQUFDO2dCQUNOLEdBQUcsRUFBRSxDQUFDO2dCQUNOLElBQUksRUFBRSxnQkFBZ0IsQ0FBQyxJQUFJO2FBQzVCO1lBQ0QsTUFBTSxFQUFFLENBQUMsU0FBNkIsRUFBRSxVQUFlLEVBQUUsRUFBRTtnQkFDekQsSUFBSSxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxRQUFRLENBQUMsT0FBTyxFQUFFLENBQUM7b0JBQ3RELElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7d0JBQ2xFLE1BQU0sSUFBSSxZQUFZLENBQ3BCLGdCQUFnQixDQUFDLGFBQWEsRUFDOUIsRUFBRSxHQUFHLEVBQUUsd0NBQXdDLEVBQUUsRUFDakQsbURBQW1ELENBQ3BELENBQUM7b0JBQ0osQ0FBQztnQkFDSCxDQUFDO2dCQUVELElBQUksVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDLE9BQU8sRUFBRSxDQUFDO29CQUN0RCxJQUFJLENBQUMsNkJBQTZCLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO3dCQUNsRSxNQUFNLElBQUksWUFBWSxDQUNwQixnQkFBZ0IsQ0FBQyxhQUFhLEVBQzlCLEVBQUUsR0FBRyxFQUFFLHlDQUF5QyxFQUFFLEVBQ2xELG9EQUFvRCxDQUNyRCxDQUFDO29CQUNKLENBQUM7Z0JBQ0gsQ0FBQztnQkFDRCxJQUNFLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO29CQUN2QixVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxRQUFRLENBQUMsT0FBTyxFQUNqRCxDQUFDO29CQUNELElBQ0UsQ0FBQzt3QkFDQyxjQUFjO3dCQUNkLElBQUk7d0JBQ0osU0FBUzt3QkFDVCxHQUFHO3dCQUNILFNBQVM7d0JBQ1QsR0FBRzt3QkFDSCxPQUFPO3dCQUNQLEdBQUc7d0JBQ0gsTUFBTTt3QkFDTixHQUFHO3dCQUNILE9BQU87d0JBQ1AsR0FBRzt3QkFDSCxRQUFRO3dCQUNSLEdBQUc7d0JBQ0gsVUFBVTt3QkFDVixHQUFHO3dCQUNILE9BQU87d0JBQ1AsR0FBRztxQkFDSixDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUN6QyxDQUFDO3dCQUNELE1BQU0sSUFBSSxZQUFZLENBQ3BCLGdCQUFnQixDQUFDLGFBQWEsRUFDOUIsRUFBRSxHQUFHLEVBQUUsd0NBQXdDLEVBQUUsRUFDakQsK0xBQStMLENBQ2hNLENBQUM7b0JBQ0osQ0FBQztnQkFDSCxDQUFDO1lBQ0gsQ0FBQztTQUNGO1FBQ0QsV0FBVyxFQUNULGtGQUFrRjtRQUNwRixNQUFNLEVBQ0osaU5BQWlOO1FBQ25OLFFBQVEsRUFBRTtZQUNSLGdDQUFnQztZQUNoQywyQ0FBMkM7WUFDM0MscUNBQXFDO1lBQ3JDLHlDQUF5QztZQUN6QyxxQ0FBcUM7WUFDckMsMkNBQTJDO1lBQzNDLHFDQUFxQztZQUNyQyx3Q0FBd0M7WUFDeEMscUNBQXFDO1NBQ3RDO1FBQ0QsVUFBVSxFQUFFLGdCQUFnQixDQUFDLE9BQU87S0FDckM7SUFDRCxHQUFHLEVBQUU7UUFDSCxPQUFPLEVBQ0wsZ0ZBQWdGO1FBRWxGLFVBQVUsRUFBRTtZQUNWLElBQUksRUFBRTtnQkFDSixHQUFHLEVBQUUsQ0FBQzthQUNQO1NBQ0Y7UUFDRCxXQUFXLEVBQUUsMENBQTBDO1FBQ3ZELE1BQU0sRUFBRSwwQkFBMEI7UUFDbEMsUUFBUSxFQUFFLENBQUMseUJBQXlCLEVBQUUsb0NBQW9DLENBQUM7UUFDM0UsVUFBVSxFQUFFLGdCQUFnQixDQUFDLFFBQVE7S0FDdEM7SUFDRCxFQUFFLEVBQUU7UUFDRixPQUFPLEVBQ0wsK0VBQStFO1FBRWpGLFVBQVUsRUFBRTtZQUNWLElBQUksRUFBRTtnQkFDSixHQUFHLEVBQUUsQ0FBQzthQUNQO1NBQ0Y7UUFDRCxXQUFXLEVBQUUsaURBQWlEO1FBQzlELE1BQU0sRUFBRSx5QkFBeUI7UUFDakMsUUFBUSxFQUFFLENBQUMsd0JBQXdCLEVBQUUsbUNBQW1DLENBQUM7UUFDekUsVUFBVSxFQUFFLGdCQUFnQixDQUFDLFFBQVE7S0FDdEM7SUFDRCxNQUFNLEVBQUU7UUFDTixPQUFPLEVBQ0wsNEVBQTRFO1FBRTlFLFVBQVUsRUFBRTtZQUNWLElBQUksRUFBRTtnQkFDSixHQUFHLEVBQUUsQ0FBQzthQUNQO1NBQ0Y7UUFDRCxXQUFXLEVBQUUsbURBQW1EO1FBQ2hFLE1BQU0sRUFBRSwyQkFBMkI7UUFDbkMsUUFBUSxFQUFFO1lBQ1Isc0NBQXNDO1lBQ3RDLHlDQUF5QztTQUMxQztRQUNELFVBQVUsRUFBRSxnQkFBZ0IsQ0FBQyxNQUFNO0tBQ3BDO0lBQ0QsSUFBSSxFQUFFO1FBQ0osT0FBTyxFQUNMLDBFQUEwRTtRQUU1RSxVQUFVLEVBQUU7WUFDVixJQUFJLEVBQUU7Z0JBQ0osR0FBRyxFQUFFLENBQUM7Z0JBQ04sSUFBSSxFQUFFLGdCQUFnQixDQUFDLE1BQU07YUFDOUI7U0FDRjtRQUNELFdBQVcsRUFBRSw4REFBOEQ7UUFDM0UsTUFBTSxFQUFFLFdBQVc7UUFDbkIsUUFBUSxFQUFFO1lBQ1IsaURBQWlEO1lBQ2pELGlCQUFpQjtTQUNsQjtRQUNELFVBQVUsRUFBRSxnQkFBZ0IsQ0FBQyxNQUFNO0tBQ3BDO0lBQ0QsS0FBSyxFQUFFO1FBQ0wsT0FBTyxFQUNMLDJFQUEyRTtRQUU3RSxVQUFVLEVBQUU7WUFDVixJQUFJLEVBQUU7Z0JBQ0osR0FBRyxFQUFFLENBQUM7Z0JBQ04sSUFBSSxFQUFFLGdCQUFnQixDQUFDLE1BQU07YUFDOUI7U0FDRjtRQUNELFdBQVcsRUFBRSx1REFBdUQ7UUFDcEUsTUFBTSxFQUFFLFlBQVk7UUFDcEIsUUFBUSxFQUFFLENBQUMsNkJBQTZCLEVBQUUsa0JBQWtCLENBQUM7UUFDN0QsVUFBVSxFQUFFLGdCQUFnQixDQUFDLE1BQU07S0FDcEM7SUFDRCxLQUFLLEVBQUU7UUFDTCxPQUFPLEVBQ0wsMkVBQTJFO1FBRTdFLFVBQVUsRUFBRTtZQUNWLElBQUksRUFBRTtnQkFDSixHQUFHLEVBQUUsQ0FBQztnQkFDTixJQUFJLEVBQUUsZ0JBQWdCLENBQUMsTUFBTTthQUM5QjtTQUNGO1FBQ0QsV0FBVyxFQUFFLHVEQUF1RDtRQUNwRSxNQUFNLEVBQUUsWUFBWTtRQUNwQixRQUFRLEVBQUUsQ0FBQyw2QkFBNkIsRUFBRSxrQkFBa0IsQ0FBQztRQUM3RCxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsTUFBTTtLQUNwQztJQUNELEdBQUcsRUFBRTtRQUNILE9BQU8sRUFDTCx5RUFBeUU7UUFFM0UsVUFBVSxFQUFFO1lBQ1YsSUFBSSxFQUFFO2dCQUNKLEdBQUcsRUFBRSxDQUFDO2dCQUNOLElBQUksRUFBRSxnQkFBZ0IsQ0FBQyxNQUFNO2FBQzlCO1NBQ0Y7UUFDRCxXQUFXLEVBQUUsd0RBQXdEO1FBQ3JFLE1BQU0sRUFBRSxZQUFZO1FBQ3BCLFFBQVEsRUFBRSxDQUFDLG9CQUFvQixFQUFFLGdCQUFnQixDQUFDO1FBQ2xELFVBQVUsRUFBRSxnQkFBZ0IsQ0FBQyxPQUFPO0tBQ3JDO0lBQ0QsR0FBRyxFQUFFO1FBQ0gsT0FBTyxFQUNMLDBFQUEwRTtRQUU1RSxVQUFVLEVBQUU7WUFDVixJQUFJLEVBQUU7Z0JBQ0osR0FBRyxFQUFFLENBQUM7Z0JBQ04sSUFBSSxFQUFFLGdCQUFnQixDQUFDLE9BQU87YUFDL0I7U0FDRjtRQUNELFdBQVcsRUFBRSxvREFBb0Q7UUFDakUsTUFBTSxFQUFFLDRCQUE0QjtRQUNwQyxRQUFRLEVBQUUsQ0FBQyx5QkFBeUIsRUFBRSwyQkFBMkIsQ0FBQztRQUNsRSxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsT0FBTztLQUNyQztJQUNELEdBQUcsRUFBRTtRQUNILE9BQU8sRUFDTCwwRUFBMEU7UUFFNUUsVUFBVSxFQUFFO1lBQ1YsSUFBSSxFQUFFO2dCQUNKLEdBQUcsRUFBRSxDQUFDO2dCQUNOLElBQUksRUFBRSxnQkFBZ0IsQ0FBQyxPQUFPO2FBQy9CO1NBQ0Y7UUFDRCxXQUFXLEVBQUUsb0RBQW9EO1FBQ2pFLE1BQU0sRUFBRSw0QkFBNEI7UUFDcEMsUUFBUSxFQUFFLENBQUMseUJBQXlCLEVBQUUsMkJBQTJCLENBQUM7UUFDbEUsVUFBVSxFQUFFLGdCQUFnQixDQUFDLE9BQU87S0FDckM7SUFDRCxPQUFPLEVBQUU7UUFDUCxPQUFPLEVBQ0wsOEVBQThFO1FBRWhGLFVBQVUsRUFBRTtZQUNWLElBQUksRUFBRTtnQkFDSixHQUFHLEVBQUUsQ0FBQztnQkFDTixJQUFJLEVBQUUsZ0JBQWdCLENBQUMsT0FBTzthQUMvQjtTQUNGO1FBQ0QsV0FBVyxFQUNULCtEQUErRDtRQUNqRSxNQUFNLEVBQUUsZ0JBQWdCO1FBQ3hCLFFBQVEsRUFBRSxDQUFDLG9CQUFvQixFQUFFLG9CQUFvQixDQUFDO1FBQ3RELFVBQVUsRUFBRSxnQkFBZ0IsQ0FBQyxPQUFPO0tBQ3JDO0lBQ0QsS0FBSyxFQUFFO1FBQ0wsT0FBTyxFQUNMLDRFQUE0RTtRQUU5RSxVQUFVLEVBQUU7WUFDVixJQUFJLEVBQUU7Z0JBQ0osR0FBRyxFQUFFLENBQUM7Z0JBQ04sSUFBSSxFQUFFLGdCQUFnQixDQUFDLE9BQU87YUFDL0I7U0FDRjtRQUNELFdBQVcsRUFBRSx3REFBd0Q7UUFDckUsTUFBTSxFQUFFLGNBQWM7UUFDdEIsUUFBUSxFQUFFLENBQUMsb0JBQW9CLEVBQUUsa0JBQWtCLENBQUM7UUFDcEQsVUFBVSxFQUFFLGdCQUFnQixDQUFDLE9BQU87S0FDckM7SUFDRCxLQUFLLEVBQUU7UUFDTCxPQUFPLEVBQ0wsNEVBQTRFO1FBRTlFLFVBQVUsRUFBRTtZQUNWLElBQUksRUFBRTtnQkFDSixHQUFHLEVBQUUsQ0FBQztnQkFDTixHQUFHLEVBQUUsQ0FBQztnQkFDTixJQUFJLEVBQUUsZ0JBQWdCLENBQUMsT0FBTzthQUMvQjtTQUNGO1FBQ0QsV0FBVyxFQUNULHNHQUFzRztRQUN4RyxNQUFNLEVBQUUsdUNBQXVDO1FBQy9DLFFBQVEsRUFBRTtZQUNSLG9CQUFvQjtZQUNwQiwwQkFBMEI7WUFDMUIscUJBQXFCO1NBQ3RCO1FBQ0QsVUFBVSxFQUFFLGdCQUFnQixDQUFDLE9BQU87S0FDckM7SUFDRCxHQUFHLEVBQUU7UUFDSCxPQUFPLEVBQ0wsMEVBQTBFO1FBRTVFLFVBQVUsRUFBRTtZQUNWLElBQUksRUFBRTtnQkFDSixHQUFHLEVBQUUsQ0FBQztnQkFDTixJQUFJLEVBQUUsZ0JBQWdCLENBQUMsT0FBTzthQUMvQjtTQUNGO1FBQ0QsV0FBVyxFQUNULDhFQUE4RTtRQUNoRixNQUFNLEVBQUUscUJBQXFCO1FBQzdCLFFBQVEsRUFBRSxDQUFDLHVCQUF1QixFQUFFLGtCQUFrQixDQUFDO1FBQ3ZELFVBQVUsRUFBRSxnQkFBZ0IsQ0FBQyxPQUFPO0tBQ3JDO0lBQ0QsTUFBTSxFQUFFO1FBQ04sT0FBTyxFQUNMLDRFQUE0RTtRQUU5RSxVQUFVLEVBQUU7WUFDVixJQUFJLEVBQUU7Z0JBQ0osR0FBRyxFQUFFLENBQUM7YUFDUDtZQUNELE1BQU0sQ0FBQyxRQUE0QixFQUFFLFVBQVU7O2dCQUM3QyxJQUFJLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsQ0FBQztvQkFDN0MsTUFBTSxJQUFJLFlBQVksQ0FDcEIsZ0JBQWdCLENBQUMsV0FBVyxFQUM1Qjt3QkFDRSxHQUFHLEVBQUUsNEJBQTRCO3dCQUNqQyxJQUFJLEVBQUUsU0FBUzt3QkFDZixVQUFVLEVBQUUsTUFBQSxNQUFBLFVBQVUsQ0FBQyxNQUFNLDBDQUFFLElBQUksMENBQUUsV0FBVyxFQUFFO3dCQUNsRCxRQUFRLEVBQUUsQ0FBQztxQkFDWixFQUNELHVFQUF1RSxDQUN4RSxDQUFDO2dCQUNKLENBQUM7WUFDSCxDQUFDO1NBQ0Y7UUFDRCxXQUFXLEVBQ1QsMkVBQTJFO1FBQzdFLE1BQU0sRUFBRSxvQkFBb0I7UUFDNUIsUUFBUSxFQUFFLENBQUMsMkJBQTJCLEVBQUUscUJBQXFCLENBQUM7UUFDOUQsVUFBVSxFQUFFLGdCQUFnQixDQUFDLE1BQU07S0FDcEM7SUFDRCxHQUFHLEVBQUU7UUFDSCxPQUFPLEVBQ0wsMEVBQTBFO1FBRTVFLFVBQVUsRUFBRTtZQUNWLElBQUksRUFBRTtnQkFDSixJQUFJLEVBQUUsZ0JBQWdCLENBQUMsT0FBTzthQUMvQjtTQUNGO1FBQ0QsV0FBVyxFQUNULG1GQUFtRjtRQUNyRixNQUFNLEVBQUUsb0JBQW9CO1FBQzVCLFFBQVEsRUFBRSxDQUFDLG9CQUFvQixFQUFFLG1CQUFtQixDQUFDO1FBQ3JELFVBQVUsRUFBRSxnQkFBZ0IsQ0FBQyxPQUFPO0tBQ3JDO0lBQ0QsR0FBRyxFQUFFO1FBQ0gsT0FBTyxFQUNMLDBFQUEwRTtRQUU1RSxVQUFVLEVBQUU7WUFDVixJQUFJLEVBQUU7Z0JBQ0osSUFBSSxFQUFFLGdCQUFnQixDQUFDLE9BQU87YUFDL0I7U0FDRjtRQUNELFdBQVcsRUFDVCx3RkFBd0Y7UUFDMUYsTUFBTSxFQUFFLFlBQVk7UUFDcEIsUUFBUSxFQUFFLENBQUMsNkJBQTZCLEVBQUUsZ0JBQWdCLENBQUM7UUFDM0QsVUFBVSxFQUFFLGdCQUFnQixDQUFDLE9BQU87S0FDckM7SUFDRCxLQUFLLEVBQUU7UUFDTCxPQUFPLEVBQ0wsNEVBQTRFO1FBRTlFLFVBQVUsRUFBRTtZQUNWLElBQUksRUFBRTtnQkFDSixHQUFHLEVBQUUsQ0FBQztnQkFDTixJQUFJLEVBQUUsZ0JBQWdCLENBQUMsT0FBTzthQUMvQjtTQUNGO1FBQ0QsV0FBVyxFQUFFLDRDQUE0QztRQUN6RCxNQUFNLEVBQUUsdUJBQXVCO1FBQy9CLFFBQVEsRUFBRSxDQUFDLHNCQUFzQixFQUFFLHNCQUFzQixDQUFDO1FBQzFELFVBQVUsRUFBRSxnQkFBZ0IsQ0FBQyxPQUFPO0tBQ3JDO0lBQ0QsSUFBSSxFQUFFO1FBQ0osT0FBTyxFQUNMLDJFQUEyRTtRQUU3RSxVQUFVLEVBQUU7WUFDVixJQUFJLEVBQUU7Z0JBQ0osR0FBRyxFQUFFLENBQUM7Z0JBQ04sSUFBSSxFQUFFLGdCQUFnQixDQUFDLE9BQU87YUFDL0I7U0FDRjtRQUNELFdBQVcsRUFBRSxtREFBbUQ7UUFDaEUsTUFBTSxFQUFFLGFBQWE7UUFDckIsUUFBUSxFQUFFLENBQUMsaUJBQWlCLEVBQUUsaUJBQWlCLENBQUM7UUFDaEQsVUFBVSxFQUFFLGdCQUFnQixDQUFDLE9BQU87S0FDckM7SUFDRCxHQUFHLEVBQUU7UUFDSCxPQUFPLEVBQ0wsMEVBQTBFO1FBRTVFLFVBQVUsRUFBRTtZQUNWLElBQUksRUFBRTtnQkFDSixHQUFHLEVBQUUsQ0FBQztnQkFDTixJQUFJLEVBQUUsZ0JBQWdCLENBQUMsT0FBTzthQUMvQjtTQUNGO1FBQ0QsV0FBVyxFQUFFLG1EQUFtRDtRQUNoRSxNQUFNLEVBQUUsWUFBWTtRQUNwQixRQUFRLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQztRQUM1QixVQUFVLEVBQUUsZ0JBQWdCLENBQUMsT0FBTztLQUNyQztJQUNELEdBQUcsRUFBRTtRQUNILE9BQU8sRUFDTCx1RUFBdUU7UUFFekUsVUFBVSxFQUFFO1lBQ1YsSUFBSSxFQUFFO2dCQUNKLEdBQUcsRUFBRSxDQUFDO2dCQUNOLElBQUksRUFBRSxnQkFBZ0IsQ0FBQyxJQUFJO2FBQzVCO1NBQ0Y7UUFDRCxXQUFXLEVBQUUsb0NBQW9DO1FBQ2pELE1BQU0sRUFBRSxPQUFPO1FBQ2YsUUFBUSxFQUFFLENBQUMsOEJBQThCLENBQUM7UUFDMUMsVUFBVSxFQUFFLGdCQUFnQixDQUFDLElBQUk7S0FDbEM7SUFDRCxPQUFPLEVBQUU7UUFDUCxPQUFPLEVBQ0wsNkVBQTZFO1FBRS9FLFVBQVUsRUFBRTtZQUNWLElBQUksRUFBRTtnQkFDSixHQUFHLEVBQUUsQ0FBQztnQkFDTixJQUFJLEVBQUUsZ0JBQWdCLENBQUMsTUFBTTthQUM5QjtTQUNGO1FBQ0QsV0FBVyxFQUNULCtFQUErRTtRQUNqRixNQUFNLEVBQUUscUNBQXFDO1FBQzdDLFFBQVEsRUFBRTtZQUNSLDJDQUEyQztZQUMzQywwQ0FBMEM7U0FDM0M7UUFDRCxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsTUFBTTtLQUNwQztJQUNELE1BQU0sRUFBRTtRQUNOLE9BQU8sRUFDTCw0RUFBNEU7UUFFOUUsVUFBVSxFQUFFO1lBQ1YsSUFBSSxFQUFFO2dCQUNKLEdBQUcsRUFBRSxDQUFDO2dCQUNOLElBQUksRUFBRSxnQkFBZ0IsQ0FBQyxNQUFNO2FBQzlCO1NBQ0Y7UUFDRCxXQUFXLEVBQ1QsaUZBQWlGO1FBQ25GLE1BQU0sRUFBRSx3QkFBd0I7UUFDaEMsUUFBUSxFQUFFO1lBQ1IscUNBQXFDO1lBQ3JDLDBCQUEwQjtTQUMzQjtRQUNELFVBQVUsRUFBRSxnQkFBZ0IsQ0FBQyxPQUFPO0tBQ3JDO0lBQ0QsR0FBRyxFQUFFO1FBQ0gsT0FBTyxFQUNMLDBFQUEwRTtRQUU1RSxVQUFVLEVBQUU7WUFDVixJQUFJLEVBQUU7Z0JBQ0osR0FBRyxFQUFFLENBQUM7Z0JBQ04sSUFBSSxFQUFFLGdCQUFnQixDQUFDLE9BQU87YUFDL0I7U0FDRjtRQUNELFdBQVcsRUFBRSxpREFBaUQ7UUFDOUQsTUFBTSxFQUFFLFlBQVk7UUFDcEIsUUFBUSxFQUFFLENBQUMsa0JBQWtCLEVBQUUsZ0JBQWdCLENBQUM7UUFDaEQsVUFBVSxFQUFFLGdCQUFnQixDQUFDLE9BQU87S0FDckM7SUFDRCxLQUFLLEVBQUU7UUFDTCxPQUFPLEVBQ0wsMkVBQTJFO1FBRTdFLFVBQVUsRUFBRTtZQUNWLElBQUksRUFBRTtnQkFDSixHQUFHLEVBQUUsQ0FBQztnQkFDTixJQUFJLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsZ0JBQWdCLENBQUMsT0FBTyxDQUFDO2FBQzFEO1NBQ0Y7UUFDRCxXQUFXLEVBQUUsdURBQXVEO1FBQ3BFLE1BQU0sRUFBRSxlQUFlO1FBQ3ZCLFFBQVEsRUFBRSxDQUFDLGtDQUFrQyxFQUFFLHFCQUFxQixDQUFDO1FBQ3JFLFVBQVUsRUFBRSxnQkFBZ0IsQ0FBQyxNQUFNO0tBQ3BDO0lBQ0QsSUFBSSxFQUFFO1FBQ0osT0FBTyxFQUNMLDBFQUEwRTtRQUU1RSxVQUFVLEVBQUU7WUFDVixJQUFJLEVBQUU7Z0JBQ0osR0FBRyxFQUFFLENBQUM7Z0JBQ04sSUFBSSxFQUFFLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxFQUFFLGdCQUFnQixDQUFDLE9BQU8sQ0FBQzthQUMxRDtTQUNGO1FBQ0QsV0FBVyxFQUFFLHdEQUF3RDtRQUNyRSxNQUFNLEVBQUUsY0FBYztRQUN0QixRQUFRLEVBQUUsQ0FBQyxvQkFBb0IsRUFBRSx5QkFBeUIsQ0FBQztRQUMzRCxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsTUFBTTtLQUNwQztJQUNELE1BQU0sRUFBRTtRQUNOLE9BQU8sRUFDTCw0RUFBNEU7UUFFOUUsVUFBVSxFQUFFO1lBQ1YsSUFBSSxFQUFFO2dCQUNKLEdBQUcsRUFBRSxDQUFDO2dCQUNOLEdBQUcsRUFBRSxDQUFDO2dCQUNOLElBQUksRUFBRTtvQkFDSixnQkFBZ0IsQ0FBQyxNQUFNO29CQUN2QixnQkFBZ0IsQ0FBQyxPQUFPO29CQUN4QixnQkFBZ0IsQ0FBQyxPQUFPO2lCQUN6QjthQUNGO1NBQ0Y7UUFDRCxXQUFXLEVBQ1QsaUdBQWlHO1FBQ25HLE1BQU0sRUFBRSw0QkFBNEI7UUFDcEMsUUFBUSxFQUFFO1lBQ1IsbUNBQW1DO1lBQ25DLG9DQUFvQztZQUNwQyx5QkFBeUI7U0FDMUI7UUFDRCxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsTUFBTTtLQUNwQztJQUNELEdBQUcsRUFBRTtRQUNILE9BQU8sRUFDTCx5RUFBeUU7UUFFM0UsVUFBVSxFQUFFO1lBQ1YsSUFBSSxFQUFFO2dCQUNKLEdBQUcsRUFBRSxDQUFDO2dCQUNOLElBQUksRUFBRTtvQkFDSixnQkFBZ0IsQ0FBQyxNQUFNO29CQUN2QixnQkFBZ0IsQ0FBQyxPQUFPO29CQUN4QixnQkFBZ0IsQ0FBQyxPQUFPO2lCQUN6QjthQUNGO1NBQ0Y7UUFDRCxXQUFXLEVBQUUsNENBQTRDO1FBQ3pELE1BQU0sRUFBRSw2QkFBNkI7UUFDckMsUUFBUSxFQUFFLENBQUMsNkJBQTZCLEVBQUUsc0JBQXNCLENBQUM7UUFDakUsVUFBVSxFQUFFLGdCQUFnQixDQUFDLE1BQU07S0FDcEM7SUFDRCxPQUFPLEVBQUU7UUFDUCxPQUFPLEVBQ0wsNkVBQTZFO1FBRS9FLFVBQVUsRUFBRTtZQUNWLElBQUksRUFBRTtnQkFDSixHQUFHLEVBQUUsQ0FBQzthQUNQO1NBQ0Y7UUFDRCxXQUFXLEVBQUUsd0NBQXdDO1FBQ3JELE1BQU0sRUFBRSxnQkFBZ0I7UUFDeEIsUUFBUSxFQUFFLENBQUMsNkJBQTZCLEVBQUUscUJBQXFCLENBQUM7UUFDaEUsVUFBVSxFQUFFLGdCQUFnQixDQUFDLE9BQU87S0FDckM7SUFDRCxVQUFVLEVBQUU7UUFDVixPQUFPLEVBQ0wsZ0ZBQWdGO1FBRWxGLFVBQVUsRUFBRTtZQUNWLElBQUksRUFBRTtnQkFDSixHQUFHLEVBQUUsQ0FBQzthQUNQO1NBQ0Y7UUFDRCxXQUFXLEVBQUUsNENBQTRDO1FBQ3pELE1BQU0sRUFBRSxtQkFBbUI7UUFDM0IsUUFBUSxFQUFFLENBQUMsK0JBQStCLEVBQUUseUJBQXlCLENBQUM7UUFDdEUsVUFBVSxFQUFFLGdCQUFnQixDQUFDLE9BQU87S0FDckM7SUFDRCxFQUFFLEVBQUU7UUFDRixPQUFPLEVBQ0wsK0VBQStFO1FBRWpGLFVBQVUsRUFBRTtZQUNWLElBQUksRUFBRTtnQkFDSixHQUFHLEVBQUUsQ0FBQztnQkFDTixHQUFHLEVBQUUsQ0FBQzthQUNQO1NBQ0Y7UUFDRCxXQUFXLEVBQ1QsdUVBQXVFO1FBQ3pFLE1BQU0sRUFBRSxvQ0FBb0M7UUFDNUMsUUFBUSxFQUFFO1lBQ1IsaUNBQWlDO1lBQ2pDLCtCQUErQjtTQUNoQztRQUNELFVBQVUsRUFBRSxDQUFDLFFBQTRCLEVBQUUsRUFBRTtZQUMzQywrRUFBK0U7WUFDL0UsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLEdBQUcsQ0FDOUIsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksS0FBSyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FDbkUsQ0FBQztZQUNGLDhFQUE4RTtZQUM5RSw2Q0FBNkM7WUFDN0MsSUFDRSxnQkFBZ0IsQ0FBQyxJQUFJLEdBQUcsQ0FBQztnQkFDekIsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxFQUM3QyxDQUFDO2dCQUNELE9BQU8sZ0JBQWdCLENBQUMsTUFBTSxDQUFDO1lBQ2pDLENBQUM7aUJBQU0sSUFBSSxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQztnQkFDMUQsT0FBTyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUM7WUFDbEMsQ0FBQztpQkFBTSxJQUFJLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDO2dCQUMxRCxPQUFPLGdCQUFnQixDQUFDLE9BQU8sQ0FBQztZQUNsQyxDQUFDO2lCQUFNLElBQUksZ0JBQWdCLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7Z0JBQ3ZELE9BQU8sZ0JBQWdCLENBQUMsSUFBSSxDQUFDO1lBQy9CLENBQUM7WUFFRCxpRkFBaUY7WUFDakYsT0FBTyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDckIsQ0FBQztLQUNGO0lBQ0QsTUFBTSxFQUFFO1FBQ04sT0FBTyxFQUNMLG1GQUFtRjtRQUVyRixVQUFVLEVBQUU7WUFDVixJQUFJLEVBQUU7Z0JBQ0osR0FBRyxFQUFFLENBQUM7YUFDUDtZQUNELE1BQU0sRUFBRSxDQUFDLFNBQWdCLEVBQUUsVUFBVSxFQUFFLEVBQUU7Z0JBQ3ZDLGtDQUFrQztZQUNwQyxDQUFDO1NBQ0Y7UUFDRCxXQUFXLEVBQ1QsOEZBQThGO1FBQ2hHLE1BQU0sRUFBRSw4Q0FBOEM7UUFDdEQsUUFBUSxFQUFFO1lBQ1IsZ0RBQWdEO1lBQ2hELCtDQUErQztZQUMvQywrQ0FBK0M7WUFDL0MsOENBQThDO1NBQy9DO1FBQ0QsVUFBVSxFQUFFLENBQUMsUUFBNEIsRUFBRSxFQUFFO1lBQzNDLCtFQUErRTtZQUMvRSxNQUFNLGdCQUFnQixHQUFHLElBQUksR0FBRyxDQUM5QixRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQ2hELENBQUM7WUFFRiw4RUFBOEU7WUFDOUUsNkNBQTZDO1lBQzdDLElBQ0UsZ0JBQWdCLENBQUMsSUFBSSxHQUFHLENBQUM7Z0JBQ3pCLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsRUFDN0MsQ0FBQztnQkFDRCxPQUFPLGdCQUFnQixDQUFDLE1BQU0sQ0FBQztZQUNqQyxDQUFDO2lCQUFNLElBQUksZ0JBQWdCLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUM7Z0JBQzFELE9BQU8sZ0JBQWdCLENBQUMsT0FBTyxDQUFDO1lBQ2xDLENBQUM7aUJBQU0sSUFBSSxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQztnQkFDMUQsT0FBTyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUM7WUFDbEMsQ0FBQztpQkFBTSxJQUFJLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO2dCQUN2RCxPQUFPLGdCQUFnQixDQUFDLElBQUksQ0FBQztZQUMvQixDQUFDO1lBRUQsaUZBQWlGO1lBQ2pGLE9BQU8sUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3JCLENBQUM7S0FDRjtJQUNELEdBQUcsRUFBRTtRQUNILE9BQU8sRUFDTCx5RUFBeUU7UUFFM0UsVUFBVSxFQUFFO1lBQ1YsSUFBSSxFQUFFO2dCQUNKLEdBQUcsRUFBRSxDQUFDO2dCQUNOLEdBQUcsRUFBRSxDQUFDO2dCQUNOLElBQUksRUFBRSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxnQkFBZ0IsQ0FBQyxNQUFNLENBQUM7YUFDekQ7U0FDRjtRQUNELFdBQVcsRUFDVCxnRUFBZ0U7UUFDbEUsTUFBTSxFQUFFLHNCQUFzQjtRQUM5QixRQUFRLEVBQUU7WUFDUix5Q0FBeUM7WUFDekMsZ0JBQWdCO1lBQ2hCLG1EQUFtRDtZQUNuRCwyQkFBMkI7U0FDNUI7UUFDRCxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsTUFBTTtLQUNwQztJQUNELFNBQVMsRUFBRTtRQUNULE9BQU8sRUFDTCwrRUFBK0U7UUFFakYsVUFBVSxFQUFFO1lBQ1YsSUFBSSxFQUFFO2dCQUNKLEdBQUcsRUFBRSxDQUFDO2dCQUNOLElBQUksRUFBRSxnQkFBZ0IsQ0FBQyxNQUFNO2FBQzlCO1NBQ0Y7UUFDRCxXQUFXLEVBQUUsb0RBQW9EO1FBQ2pFLE1BQU0sRUFBRSxnQkFBZ0I7UUFDeEIsUUFBUSxFQUFFO1lBQ1IsaURBQWlEO1lBQ2pELHNCQUFzQjtTQUN2QjtRQUNELFVBQVUsRUFBRSxnQkFBZ0IsQ0FBQyxNQUFNO0tBQ3BDO0lBQ0QsT0FBTyxFQUFFO1FBQ1AsT0FBTyxFQUNMLDJFQUEyRTtRQUU3RSxVQUFVLEVBQUU7WUFDVixJQUFJLEVBQUU7Z0JBQ0osR0FBRyxFQUFFLENBQUM7Z0JBQ04sR0FBRyxFQUFFLENBQUM7Z0JBQ04sSUFBSSxFQUFFLGdCQUFnQixDQUFDLE9BQU87YUFDL0I7WUFDRCxNQUFNLENBQUMsU0FBNkIsRUFBRSxVQUFlO2dCQUNuRCxJQUFJLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyxPQUFPLEVBQUUsQ0FBQztvQkFDdEQsSUFBSSxDQUFDLDZCQUE2QixDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQzt3QkFDbEUsTUFBTSxJQUFJLFlBQVksQ0FDcEIsZ0JBQWdCLENBQUMsYUFBYSxFQUM5QixFQUFFLEdBQUcsRUFBRSx1Q0FBdUMsRUFBRSxFQUNoRCw2Q0FBNkMsQ0FDOUMsQ0FBQztvQkFDSixDQUFDO2dCQUNILENBQUM7Z0JBRUQsNkRBQTZEO2dCQUM3RCxJQUNFLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO29CQUN2QixVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxRQUFRLENBQUMsT0FBTyxFQUNqRCxDQUFDO29CQUNELE1BQU0sS0FBSyxHQUFHLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO29CQUM1QyxJQUNFLE9BQU8sS0FBSyxLQUFLLFFBQVE7d0JBQ3pCLENBQUM7NEJBQ0MsUUFBUTs0QkFDUixRQUFROzRCQUNSLFNBQVM7NEJBQ1QsV0FBVzs0QkFDWCxVQUFVOzRCQUNWLFFBQVE7NEJBQ1IsVUFBVTt5QkFDWCxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUMsRUFDL0IsQ0FBQzt3QkFDRCxNQUFNLElBQUksWUFBWSxDQUNwQixnQkFBZ0IsQ0FBQyxhQUFhLEVBQzlCLEVBQUUsR0FBRyxFQUFFLHdDQUF3QyxFQUFFLEVBQ2pELDBEQUEwRCxDQUMzRCxDQUFDO29CQUNKLENBQUM7Z0JBQ0gsQ0FBQztZQUNILENBQUM7U0FDRjtRQUNELFdBQVcsRUFDVCxvRkFBb0Y7UUFDdEYsTUFBTSxFQUFFLGlDQUFpQztRQUN6QyxRQUFRLEVBQUUsQ0FBQyx1QkFBdUIsRUFBRSwwQkFBMEIsQ0FBQztRQUMvRCxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsT0FBTztLQUNyQztJQUVELElBQUksRUFBRTtRQUNKLFVBQVUsRUFBRTtZQUNWLElBQUksRUFBRTtnQkFDSixHQUFHLEVBQUUsQ0FBQzthQUNQO1NBQ0Y7UUFDRCxXQUFXLEVBQUUsV0FBVztRQUN4QixNQUFNLEVBQUUsUUFBUTtRQUNoQixRQUFRLEVBQUUsQ0FBQyxRQUFRLENBQUM7UUFDcEIsVUFBVSxFQUFFLGdCQUFnQixDQUFDLE9BQU87UUFDcEMscUJBQXFCO1FBQ3JCLE9BQU8sRUFDTCwyRUFBMkU7S0FDOUU7SUFFRCxLQUFLLEVBQUU7UUFDTCxVQUFVLEVBQUU7WUFDVixJQUFJLEVBQUU7Z0JBQ0osR0FBRyxFQUFFLENBQUM7YUFDUDtTQUNGO1FBQ0QsV0FBVyxFQUFFLFdBQVc7UUFDeEIsTUFBTSxFQUFFLFNBQVM7UUFDakIsUUFBUSxFQUFFLENBQUMsU0FBUyxDQUFDO1FBQ3JCLFVBQVUsRUFBRSxnQkFBZ0IsQ0FBQyxPQUFPO1FBQ3BDLHFCQUFxQjtRQUNyQixPQUFPLEVBQ0wsNEVBQTRFO0tBQy9FO0lBRUQsV0FBVyxFQUFFO1FBQ1gsVUFBVSxFQUFFO1lBQ1YsSUFBSSxFQUFFO2dCQUNKLEdBQUcsRUFBRSxDQUFDO2dCQUNOLElBQUksRUFBRSxnQkFBZ0IsQ0FBQyxLQUFLO2FBQzdCO1NBQ0Y7UUFDRCxXQUFXLEVBQUUsMENBQTBDO1FBQ3ZELE1BQU0sRUFBRSxvQkFBb0I7UUFDNUIsUUFBUSxFQUFFLENBQUMsdUJBQXVCLENBQUM7UUFDbkMsVUFBVSxFQUFFLGdCQUFnQixDQUFDLEtBQUs7UUFDbEMsT0FBTyxFQUNMLGdGQUFnRjtLQUNuRjtJQUVELFNBQVMsRUFBRTtRQUNULFVBQVUsRUFBRTtZQUNWLElBQUksRUFBRTtnQkFDSixHQUFHLEVBQUUsQ0FBQztnQkFDTixHQUFHLEVBQUUsQ0FBQzthQUNQO1NBQ0Y7UUFDRCxXQUFXLEVBQUUsc0JBQXNCO1FBQ25DLE1BQU0sRUFBRSwrQkFBK0I7UUFDdkMsUUFBUSxFQUFFLENBQUMsNkJBQTZCLENBQUM7UUFDekMsVUFBVSxFQUFFLGdCQUFnQixDQUFDLEtBQUs7UUFDbEMsT0FBTyxFQUNMLDhFQUE4RTtLQUNqRjtJQUVELFlBQVksRUFBRTtRQUNaLFVBQVUsRUFBRTtZQUNWLElBQUksRUFBRTtnQkFDSixHQUFHLEVBQUUsQ0FBQztnQkFDTixJQUFJLEVBQUUsZ0JBQWdCLENBQUMsS0FBSzthQUM3QjtTQUNGO1FBQ0QsV0FBVyxFQUFFLHNEQUFzRDtRQUNuRSxNQUFNLEVBQUUscUJBQXFCO1FBQzdCLFFBQVEsRUFBRSxDQUFDLHdCQUF3QixDQUFDO1FBQ3BDLFVBQVUsRUFBRSxnQkFBZ0IsQ0FBQyxLQUFLO1FBQ2xDLE9BQU8sRUFDTCxpRkFBaUY7S0FDcEY7SUFFRCxVQUFVLEVBQUU7UUFDVixVQUFVLEVBQUU7WUFDVixJQUFJLEVBQUU7Z0JBQ0osR0FBRyxFQUFFLENBQUM7Z0JBQ04sR0FBRyxFQUFFLENBQUM7YUFDUDtTQUNGO1FBQ0QsV0FBVyxFQUFFLHNEQUFzRDtRQUNuRSxNQUFNLEVBQUUsaUNBQWlDO1FBQ3pDLFFBQVEsRUFBRSxDQUFDLHNCQUFzQixDQUFDO1FBQ2xDLFVBQVUsRUFBRSxnQkFBZ0IsQ0FBQyxLQUFLO1FBQ2xDLE9BQU8sRUFDTCwrRUFBK0U7S0FDbEY7SUFFRCxXQUFXLEVBQUU7UUFDWCxVQUFVLEVBQUU7WUFDVixJQUFJLEVBQUU7Z0JBQ0osR0FBRyxFQUFFLENBQUM7Z0JBQ04sSUFBSSxFQUFFLGdCQUFnQixDQUFDLE1BQU07YUFDOUI7U0FDRjtRQUNELFdBQVcsRUFDVCx3R0FBd0c7UUFDMUcsTUFBTSxFQUFFLDRCQUE0QjtRQUNwQyxRQUFRLEVBQUUsQ0FBQywrQkFBK0IsQ0FBQztRQUMzQyxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsT0FBTztRQUNwQyxPQUFPLEVBQ0wsaUZBQWlGO0tBQ3BGO0lBRUQsYUFBYSxFQUFFO1FBQ2IsVUFBVSxFQUFFO1lBQ1YsSUFBSSxFQUFFO2dCQUNKLEdBQUcsRUFBRSxDQUFDO2dCQUNOLElBQUksRUFBRSxnQkFBZ0IsQ0FBQyxNQUFNO2FBQzlCO1NBQ0Y7UUFDRCxXQUFXLEVBQ1QsK0RBQStEO1FBQ2pFLE1BQU0sRUFBRSw4QkFBOEI7UUFDdEMsUUFBUSxFQUFFLENBQUMsaUNBQWlDLENBQUM7UUFDN0MsVUFBVSxFQUFFLGdCQUFnQixDQUFDLE1BQU07UUFDbkMsT0FBTyxFQUNMLG1GQUFtRjtLQUN0RjtJQUNELGFBQWEsRUFBRTtRQUNiLFVBQVUsRUFBRTtZQUNWLElBQUksRUFBRTtnQkFDSixHQUFHLEVBQUUsQ0FBQztnQkFDTixJQUFJLEVBQUUsZ0JBQWdCLENBQUMsTUFBTTthQUM5QjtTQUNGO1FBQ0QsV0FBVyxFQUNULGtHQUFrRztRQUNwRyxNQUFNLEVBQUUseUNBQXlDO1FBQ2pELFFBQVEsRUFBRSxDQUFDLHlDQUF5QyxDQUFDO1FBQ3JELFVBQVUsRUFBRSxnQkFBZ0IsQ0FBQyxNQUFNO1FBQ25DLE9BQU8sRUFDTCxtRkFBbUY7S0FDdEY7SUFDRCxLQUFLLEVBQUU7UUFDTCxVQUFVLEVBQUU7WUFDVixJQUFJLEVBQUU7Z0JBQ0osR0FBRyxFQUFFLENBQUM7YUFDUDtTQUNGO1FBQ0QsV0FBVyxFQUFFLHNCQUFzQjtRQUNuQyxNQUFNLEVBQUUsU0FBUztRQUNqQixRQUFRLEVBQUUsQ0FBQyxTQUFTLENBQUM7UUFDckIsVUFBVSxFQUFFLGdCQUFnQixDQUFDLElBQUk7UUFDakMscUJBQXFCO1FBQ3JCLE9BQU8sRUFDTCw0RUFBNEU7S0FDL0U7SUFDRCxHQUFHLEVBQUU7UUFDSCxVQUFVLEVBQUU7WUFDVixJQUFJLEVBQUU7Z0JBQ0osR0FBRyxFQUFFLENBQUM7YUFDUDtZQUNELCtCQUErQjtTQUNoQztRQUNELFdBQVcsRUFDVCxrR0FBa0c7UUFDcEcsTUFBTSxFQUFFLDhCQUE4QjtRQUN0QyxRQUFRLEVBQUUsQ0FBQyw4QkFBOEIsQ0FBQztRQUMxQyxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsT0FBTztRQUNwQyxxQkFBcUI7UUFDckIsT0FBTyxFQUNMLDBFQUEwRTtLQUM3RTtJQUNELElBQUksRUFBRTtRQUNKLFVBQVUsRUFBRTtZQUNWLElBQUksRUFBRTtnQkFDSixHQUFHLEVBQUUsQ0FBQztnQkFDTixJQUFJLEVBQUUsZ0JBQWdCLENBQUMsT0FBTzthQUMvQjtTQUNGO1FBQ0QsV0FBVyxFQUNULGdIQUFnSDtRQUNsSCxNQUFNLEVBQUUsYUFBYTtRQUNyQixRQUFRLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQztRQUM1QixVQUFVLEVBQUUsZ0JBQWdCLENBQUMsT0FBTztRQUNwQyxPQUFPLEVBQ0wsMkVBQTJFO0tBQzlFO0lBQ0QsR0FBRyxFQUFFO1FBQ0gsVUFBVSxFQUFFO1lBQ1YsSUFBSSxFQUFFO2dCQUNKLEdBQUcsRUFBRSxDQUFDO2dCQUNOLElBQUksRUFBRSxnQkFBZ0IsQ0FBQyxPQUFPO2FBQy9CO1NBQ0Y7UUFDRCxXQUFXLEVBQ1QsK0dBQStHO1FBQ2pILE1BQU0sRUFBRSxZQUFZO1FBQ3BCLFFBQVEsRUFBRSxDQUFDLGVBQWUsQ0FBQztRQUMzQixVQUFVLEVBQUUsZ0JBQWdCLENBQUMsT0FBTztRQUNwQyxPQUFPLEVBQ0wsMEVBQTBFO0tBQzdFO0lBQ0QsU0FBUyxFQUFFO1FBQ1QsVUFBVSxFQUFFO1lBQ1YsSUFBSSxFQUFFO2dCQUNKLEdBQUcsRUFBRSxDQUFDO2FBQ1A7U0FDRjtRQUNELFdBQVcsRUFBRSwrQ0FBK0M7UUFDNUQsTUFBTSxFQUFFLGFBQWE7UUFDckIsUUFBUSxFQUFFLENBQUMsYUFBYSxDQUFDO1FBRXpCLDhDQUE4QztRQUM5QyxVQUFVLEVBQUUsR0FBRyxFQUFFO1lBQ2YsT0FBTyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUM7UUFDakMsQ0FBQztLQUNGO0lBQ0QsTUFBTSxFQUFFO1FBQ04sVUFBVSxFQUFFO1lBQ1YsSUFBSSxFQUFFO2dCQUNKLEdBQUcsRUFBRSxDQUFDO2FBQ1A7U0FDRjtRQUNELFdBQVcsRUFBRSw0QkFBNEI7UUFDekMsTUFBTSxFQUFFLCtCQUErQjtRQUN2QyxRQUFRLEVBQUUsQ0FBQyw0QkFBNEIsQ0FBQztRQUN4QyxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsT0FBTztRQUNwQyxPQUFPLEVBQ0wsNkVBQTZFO0tBQ2hGO0lBQ0QsS0FBSyxFQUFFO1FBQ0wsVUFBVSxFQUFFO1lBQ1YsSUFBSSxFQUFFO2dCQUNKLEdBQUcsRUFBRSxDQUFDO2FBQ1A7U0FDRjtRQUNELFdBQVcsRUFBRSw0QkFBNEI7UUFDekMsTUFBTSxFQUFFLDhCQUE4QjtRQUN0QyxRQUFRLEVBQUUsQ0FBQywyQkFBMkIsQ0FBQztRQUN2QyxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsT0FBTztRQUNwQyxPQUFPLEVBQ0wsNEVBQTRFO0tBQy9FO0lBQ0QsUUFBUSxFQUFFO1FBQ1IsVUFBVSxFQUFFO1lBQ1YsSUFBSSxFQUFFO2dCQUNKLEdBQUcsRUFBRSxDQUFDO2FBQ1A7U0FDRjtRQUNELFdBQVcsRUFBRSxnQ0FBZ0M7UUFDN0MsTUFBTSxFQUFFLGlDQUFpQztRQUN6QyxRQUFRLEVBQUUsQ0FBQyw4QkFBOEIsQ0FBQztRQUMxQyxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsT0FBTztRQUNwQyxPQUFPLEVBQ0wsK0VBQStFO0tBQ2xGO0lBQ0QsU0FBUyxFQUFFO1FBQ1QsVUFBVSxFQUFFO1lBQ1YsSUFBSSxFQUFFO2dCQUNKLEdBQUcsRUFBRSxDQUFDO2dCQUNOLEdBQUcsRUFBRSxDQUFDO2dCQUNOLElBQUksRUFBRSxnQkFBZ0IsQ0FBQyxPQUFPO2FBQy9CO1NBQ0Y7UUFDRCxXQUFXLEVBQ1QsOEhBQThIO1FBQ2hJLE1BQU0sRUFBRSwrQkFBK0I7UUFDdkMsUUFBUSxFQUFFLENBQUMscUJBQXFCLEVBQUUsd0JBQXdCLENBQUM7UUFDM0QsVUFBVSxFQUFFLGdCQUFnQixDQUFDLE9BQU87UUFDcEMsT0FBTyxFQUNMLGdGQUFnRjtLQUNuRjtJQUNELE9BQU8sRUFBRTtRQUNQLFVBQVUsRUFBRTtZQUNWLElBQUksRUFBRTtnQkFDSixHQUFHLEVBQUUsQ0FBQztnQkFDTixHQUFHLEVBQUUsQ0FBQztnQkFDTixJQUFJLEVBQUUsZ0JBQWdCLENBQUMsT0FBTzthQUMvQjtTQUNGO1FBQ0QsV0FBVyxFQUNULDRIQUE0SDtRQUM5SCxNQUFNLEVBQUUsNkJBQTZCO1FBQ3JDLFFBQVEsRUFBRSxDQUFDLG1CQUFtQixFQUFFLHNCQUFzQixDQUFDO1FBQ3ZELFVBQVUsRUFBRSxnQkFBZ0IsQ0FBQyxPQUFPO1FBQ3BDLE9BQU8sRUFDTCw4RUFBOEU7S0FDakY7SUFDRCxLQUFLLEVBQUU7UUFDTCxVQUFVLEVBQUU7WUFDVixJQUFJLEVBQUU7Z0JBQ0osR0FBRyxFQUFFLENBQUM7YUFDUDtTQUNGO1FBQ0QsV0FBVyxFQUNULG1IQUFtSDtRQUNySCxNQUFNLEVBQUUsY0FBYztRQUN0QixRQUFRLEVBQUUsQ0FBQyxnQkFBZ0IsRUFBRSxvQkFBb0IsRUFBRSxpQkFBaUIsQ0FBQztRQUNyRSxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsT0FBTztRQUNwQyxPQUFPLEVBQ0wsNEVBQTRFO0tBQy9FO0lBQ0QsWUFBWSxFQUFFO1FBQ1osT0FBTyxFQUNMLGdGQUFnRjtRQUNsRixVQUFVLEVBQUU7WUFDVixJQUFJLEVBQUU7Z0JBQ0osR0FBRyxFQUFFLENBQUM7Z0JBQ04sR0FBRyxFQUFFLENBQUM7Z0JBQ04sSUFBSSxFQUFFLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxFQUFFLGdCQUFnQixDQUFDLE1BQU0sQ0FBQzthQUN6RDtTQUNGO1FBQ0QsV0FBVyxFQUFFLDREQUE0RDtRQUN6RSxNQUFNLEVBQUUsaUNBQWlDO1FBQ3pDLFFBQVEsRUFBRTtZQUNSLHNEQUFzRDtZQUN0RCxxQ0FBcUM7U0FDdEM7UUFDRCxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsTUFBTTtLQUNwQztJQUNELDBGQUEwRjtJQUMxRixnSEFBZ0g7SUFDaEgsRUFBRTtJQUNGLGtCQUFrQjtJQUNsQixrQkFBa0I7SUFDbEIsY0FBYztJQUNkLGdCQUFnQjtJQUNoQixTQUFTO0lBQ1QsT0FBTztJQUNQLGdGQUFnRjtJQUNoRiw4QkFBOEI7SUFDOUIsa0NBQWtDO0lBQ2xDLEtBQUs7SUFDTCx3QkFBd0I7SUFDeEIsa0JBQWtCO0lBQ2xCLGNBQWM7SUFDZCxnQkFBZ0I7SUFDaEIsU0FBUztJQUNULE9BQU87SUFDUCxzRkFBc0Y7SUFDdEYscUNBQXFDO0lBQ3JDLHlDQUF5QztJQUN6QyxLQUFLO0NBQ04sQ0FBQztBQUVGLE1BQU0sT0FBTyxZQUFhLFNBQVEsS0FBSztJQUlyQyxZQUNFLElBQXNCLEVBQ3RCLEtBRUMsRUFDRCxVQUFrQixlQUFlO1FBRWpDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNmLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0lBQ3JCLENBQUM7Q0FDRjtBQUVELFNBQWUsMkJBQTJCO3lEQUFDLEVBQ3pDLEdBQUcsRUFDSCxPQUFPLEVBQ1AsT0FBTyxFQUNQLGFBQWEsR0FNZDtRQUNDLE1BQU0sR0FBRyxHQUlMLEVBQUUsQ0FBQztRQUNQLE1BQU0sS0FBSyxHQUNULE9BQU8sYUFBYSxLQUFLLFFBQVE7WUFDL0IsQ0FBQyxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsRUFBRSxNQUFNLEVBQUUsYUFBYSxFQUFFLENBQUM7WUFDaEQsQ0FBQyxDQUFDLGFBQWEsQ0FBQztRQUVwQixRQUFRLEdBQUcsYUFBSCxHQUFHLHVCQUFILEdBQUcsQ0FBRSxJQUFJLEVBQUUsQ0FBQztZQUNsQixTQUFTO1lBQ1QsS0FBSyxPQUFPLENBQUMsY0FBYyxDQUFDO1lBQzVCLEtBQUssT0FBTyxDQUFDLFFBQVEsQ0FBQztZQUN0QixLQUFLLE9BQU8sQ0FBQyxXQUFXLENBQUM7WUFDekIsS0FBSyxPQUFPLENBQUMsWUFBWSxDQUFDO1lBQzFCLEtBQUssT0FBTyxDQUFDLFdBQVcsQ0FBQztZQUN6QixLQUFLLE9BQU8sQ0FBQyxLQUFLLENBQUM7WUFDbkIsS0FBSyxPQUFPLENBQUMsR0FBRyxDQUFDO1lBQ2pCLEtBQUssT0FBTyxDQUFDLElBQUksQ0FBQztZQUNsQixLQUFLLE9BQU8sQ0FBQyxTQUFTLENBQUM7WUFDdkIsS0FBSyxPQUFPLENBQUMsY0FBYztnQkFDekIsR0FBRyxDQUFDLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUM7Z0JBQ3ZDLE1BQU07WUFDUixVQUFVO1lBQ1YsS0FBSyxPQUFPLENBQUMsSUFBSSxDQUFDO1lBQ2xCLEtBQUssT0FBTyxDQUFDLE1BQU0sQ0FBQztZQUNwQixLQUFLLE9BQU8sQ0FBQyxPQUFPLENBQUM7WUFDckIsS0FBSyxPQUFPLENBQUMsTUFBTSxDQUFDO1lBQ3BCLEtBQUssT0FBTyxDQUFDLEtBQUssQ0FBQztZQUNuQixLQUFLLE9BQU8sQ0FBQyxVQUFVO2dCQUNyQixHQUFHLENBQUMsUUFBUSxHQUFHLGdCQUFnQixDQUFDLE9BQU8sQ0FBQztnQkFDeEMsTUFBTTtZQUNSLE9BQU87WUFDUCxLQUFLLE9BQU8sQ0FBQyxJQUFJLENBQUM7WUFDbEIsS0FBSyxPQUFPLENBQUMsUUFBUSxDQUFDO1lBQ3RCLEtBQUssT0FBTyxDQUFDLFdBQVcsQ0FBQztZQUN6QixLQUFLLE9BQU8sQ0FBQyxnQkFBZ0I7Z0JBQzNCLEdBQUcsQ0FBQyxRQUFRLEdBQUcsZ0JBQWdCLENBQUMsSUFBSSxDQUFDO2dCQUNyQyxNQUFNO1lBRVIsS0FBSyxPQUFPLENBQUMsUUFBUSxDQUFDO1lBQ3RCLEtBQUssT0FBTyxDQUFDLE9BQU8sQ0FBQztZQUNyQixLQUFLLE9BQU8sQ0FBQyxRQUFRLENBQUM7WUFDdEIsS0FBSyxPQUFPLENBQUMsS0FBSztnQkFDaEIsR0FBRyxDQUFDLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUM7Z0JBQ3hDLE1BQU07WUFFUixLQUFLLE9BQU8sQ0FBQyxNQUFNO2dCQUNqQixDQUFDO29CQUNDLE1BQU0sY0FBYyxHQUFHLEdBQUcsQ0FBQyxVQUFVLENBQUMsZUFBZSxDQUFDO29CQUN0RCxJQUNFO3dCQUNFLE9BQU87d0JBQ1AsS0FBSzt3QkFDTCxLQUFLO3dCQUNMLGVBQWU7d0JBQ2YsYUFBYTt3QkFDYixhQUFhO3FCQUNkLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxFQUMxQixDQUFDO3dCQUNELGtGQUFrRjt3QkFDbEYsR0FBRyxDQUFDLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUM7b0JBQzFDLENBQUM7eUJBQU0sQ0FBQzt3QkFDTixNQUFNLGlCQUFpQixHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQ3BDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FDVCxNQUFNLENBQUMsRUFBRSxLQUFrQixHQUFHLENBQUMsVUFBVyxDQUFDLHFCQUFxQixDQUNuRSxDQUFDO3dCQUVGLHVEQUF1RDt3QkFDdkQsTUFBTSxZQUFZLEdBQUcsTUFBTSxPQUFPLENBQ04saUJBQWlCLENBQUMsVUFBVzs2QkFDcEQsbUJBQW1CLENBQ3ZCLENBQUM7d0JBRUYsTUFBTSxlQUFlLEdBQUcsWUFBWSxDQUFDLE9BQU8sQ0FBQzt3QkFDN0MsTUFBTSxnQkFBZ0IsR0FBRyxlQUFlLENBQUMsSUFBSSxDQUMzQyxDQUFDLE1BQWtCLEVBQUUsRUFBRSxDQUNyQixNQUFNLENBQUMsRUFBRSxLQUFLLEdBQUcsQ0FBQyxVQUFVLENBQUMsbUJBQW1CLENBQ25ELENBQUM7d0JBRUYsOEJBQThCO3dCQUM5QixNQUFNLENBQUMsTUFBTSxDQUNYLEdBQUcsRUFDSCxNQUFNLDJCQUEyQixDQUFDOzRCQUNoQyxHQUFHLEVBQUUsZ0JBQWdCOzRCQUNyQixPQUFPLEVBQUUsZUFBZTs0QkFDeEIsT0FBTzs0QkFDUCxhQUFhO3lCQUNkLENBQUMsQ0FDSCxDQUFDO29CQUNKLENBQUM7Z0JBQ0gsQ0FBQztnQkFDRCxNQUFNO1lBRVIsS0FBSyxPQUFPLENBQUMsVUFBVTtnQkFDckIsR0FBRyxDQUFDLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUM7Z0JBQ3ZDLE1BQU07WUFDUixLQUFLLE9BQU8sQ0FBQyxRQUFRO2dCQUNuQixJQUFJLEdBQUcsQ0FBQyxFQUFFLEtBQUssU0FBUyxJQUFJLEdBQUcsQ0FBQyxFQUFFLEtBQUssTUFBTSxFQUFFLENBQUM7b0JBQzlDLEdBQUcsQ0FBQyxRQUFRLEdBQUcsZ0JBQWdCLENBQUMsT0FBTyxDQUFDO2dCQUMxQyxDQUFDO3FCQUFNLENBQUM7b0JBQ04sR0FBRyxDQUFDLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUM7Z0JBQzFDLENBQUM7Z0JBQ0QsTUFBTTtZQUNSLEtBQUssT0FBTyxDQUFDLElBQUk7Z0JBQ2YsR0FBRyxDQUFDLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUM7Z0JBQ3pDLE1BQU07WUFDUixLQUFLLE9BQU8sQ0FBQyxFQUFFLENBQUM7WUFDaEIsS0FBSyxPQUFPLENBQUMsVUFBVSxDQUFDO1lBQ3hCLEtBQUssT0FBTyxDQUFDLGNBQWM7Z0JBQ3pCLENBQUM7b0JBQ0MsSUFBSSxLQUFLLEVBQUUsQ0FBQzt3QkFDVixNQUFNLFlBQVksR0FBRyxLQUFLLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxDQUFDO3dCQUNoRCxJQUFJLENBQUMsU0FBUyxFQUFFLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQzs0QkFDM0QsR0FBRyxDQUFDLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUM7d0JBQzFDLENBQUM7NkJBQU0sSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDOzRCQUM5QyxHQUFHLENBQUMsUUFBUSxHQUFHLGdCQUFnQixDQUFDLE9BQU8sQ0FBQzt3QkFDMUMsQ0FBQzs2QkFBTSxJQUNMLENBQUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxFQUMzRCxDQUFDOzRCQUNELEdBQUcsQ0FBQyxRQUFRLEdBQUcsZ0JBQWdCLENBQUMsSUFBSSxDQUFDO3dCQUN2QyxDQUFDOzZCQUFNLENBQUM7NEJBQ04sR0FBRyxDQUFDLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUM7d0JBQ3pDLENBQUM7b0JBQ0gsQ0FBQzt5QkFBTSxDQUFDO3dCQUNOLEdBQUcsQ0FBQyxRQUFRLEdBQUcsZ0JBQWdCLENBQUMsT0FBTyxDQUFDO29CQUMxQyxDQUFDO2dCQUNILENBQUM7Z0JBQ0QsTUFBTTtZQUNSLGdCQUFnQjtZQUNoQixLQUFLLE9BQU8sQ0FBQyxNQUFNLENBQUM7WUFDcEIsS0FBSyxPQUFPLENBQUMsbUJBQW1CO2dCQUM5QixHQUFHLENBQUMsUUFBUSxHQUFHLGdCQUFnQixDQUFDLEtBQUssQ0FBQztnQkFDdEMsTUFBTTtZQUNSLEtBQUssT0FBTyxDQUFDLE9BQU8sQ0FBQztZQUNyQixLQUFLLE9BQU8sQ0FBQyxNQUFNLENBQUM7WUFDcEIsS0FBSyxPQUFPLENBQUMsWUFBWSxDQUFDO1lBQzFCLEtBQUssT0FBTyxDQUFDLE1BQU0sQ0FBQztZQUNwQjtnQkFDRSxHQUFHLENBQUMsUUFBUSxHQUFHLGdCQUFnQixDQUFDLE9BQU8sQ0FBQztnQkFDeEMsTUFBTTtRQUNWLENBQUM7UUFFRCxPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7Q0FBQTtBQUVELE1BQU0sVUFBZ0IscUNBQXFDO3lEQUFDLEVBQzFELE9BQU8sRUFDUCxNQUFNLEVBQ04sT0FBTyxFQUNQLGFBQWEsRUFDYixPQUFPLEdBT1I7UUFDQyxNQUFNLEtBQUssR0FDVCxPQUFPLGFBQWEsS0FBSyxRQUFRO1lBQy9CLENBQUMsQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLEVBQUUsTUFBTSxFQUFFLGFBQWEsRUFBRSxDQUFDO1lBQ2hELENBQUMsQ0FBQyxhQUFhLENBQUM7UUFFcEIsTUFBTSxnQkFBZ0IsR0FBRyxFQUFFLENBQUM7UUFDNUIsTUFBTSxhQUFhLEdBQUcsRUFBRSxDQUFDO1FBRXpCLEtBQUssTUFBTSxHQUFHLElBQUksT0FBTyxFQUFFLENBQUM7WUFDMUIsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUNsQyxhQUFhLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQztRQUM5QixDQUFDO1FBRUQsTUFBTSxrQkFBa0IsR0FBRyxDQUN6QixVQUE2QixFQUNELEVBQUU7O1lBQzlCLE1BQU0sR0FBRyxxQkFBMkIsVUFBVSxDQUFFLENBQUM7WUFFakQsSUFBSSxVQUFVLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQztnQkFDMUMsTUFBTSxVQUFVLEdBQ2QsVUFBVSxDQUFDLE1BQ1osQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7Z0JBQ3JCLHlCQUF5QjtnQkFDekIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDO29CQUMxQixNQUFNLElBQUksWUFBWSxDQUNwQixnQkFBZ0IsQ0FBQyxxQkFBcUIsRUFDdEMsRUFBRSxFQUNGLFlBQVksVUFBVSxtQkFBbUIsQ0FDMUMsQ0FBQztnQkFDSixDQUFDO3FCQUFNLElBQUksS0FBSyxhQUFMLEtBQUssdUJBQUwsS0FBSyxDQUFFLG9CQUFvQixHQUFHLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDO29CQUM5RCxNQUFNLElBQUksWUFBWSxDQUNwQixnQkFBZ0IsQ0FBQyxxQkFBcUIsRUFDdEMsRUFBRSxFQUNGLFlBQVksVUFBVSxtQ0FBbUMsQ0FDMUQsQ0FBQztnQkFDSixDQUFDO2dCQUVELHFCQUFxQjtnQkFDckIsTUFBTSxVQUFVLEdBQ2QsUUFBUSxDQUFDLFVBQVUsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQyxVQUFVLENBQUM7Z0JBQzFELElBQUksVUFBVSxJQUFJLFVBQVUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztvQkFDbEMsSUFDRSxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxTQUFTO3dCQUNqQyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxVQUFVLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFDbkQsQ0FBQzt3QkFDRCxNQUFNLElBQUksWUFBWSxDQUNwQixnQkFBZ0IsQ0FBQyxXQUFXLEVBQzVCOzRCQUNFLEdBQUcsRUFBRSxzQ0FBc0M7NEJBQzNDLGlCQUFpQixFQUFFLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRzs0QkFDdEMsVUFBVTt5QkFDWCxFQUNELDRCQUE0QixDQUM3QixDQUFDO29CQUNKLENBQUM7eUJBQU0sSUFDTCxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxTQUFTO3dCQUNqQyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxVQUFVLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFDakQsQ0FBQzt3QkFDRCxNQUFNLElBQUksWUFBWSxDQUNwQixnQkFBZ0IsQ0FBQyxPQUFPLEVBQ3hCOzRCQUNFLEdBQUcsRUFBRSx5Q0FBeUM7NEJBQzlDLG9CQUFvQixFQUFFLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRzs0QkFDekMsVUFBVTt5QkFDWCxFQUNELDRCQUE0QixDQUM3QixDQUFDO29CQUNKLENBQUM7eUJBQU0sSUFDTCxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxTQUFTO3dCQUNqQyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxVQUFVLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFDakQsQ0FBQzt3QkFDRCxNQUFNLElBQUksWUFBWSxDQUNwQixnQkFBZ0IsQ0FBQyxXQUFXLEVBQzVCOzRCQUNFLEdBQUcsRUFBRSx5Q0FBeUM7NEJBQzlDLG9CQUFvQixFQUFFLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRzs0QkFDekMsVUFBVTt5QkFDWCxFQUNELDJCQUEyQixDQUM1QixDQUFDO29CQUNKLENBQUM7Z0JBQ0gsQ0FBQztnQkFDRCw2QkFBNkI7Z0JBQzdCLE1BQU0sY0FBYyxHQUFHLENBQUUsR0FBMEIsQ0FBQyxTQUFTO29CQUMzRCxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQ2YsVUFBVSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTt3QkFDL0IsT0FBTyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFDakMsQ0FBQyxDQUFDLENBQ0gsQ0FBQyxDQUFDO2dCQUVMLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFNLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFFNUQsNkNBQTZDO2dCQUM3QyxJQUFJLE1BQUEsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFVBQVUsMENBQUUsTUFBTSxFQUFFLENBQUM7b0JBQzVDLE1BQUEsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFVBQVUsMENBQUUsTUFBTSxDQUFDLFFBQVEsRUFBRSxVQUFVLENBQUMsQ0FBQztnQkFDaEUsQ0FBQztnQkFDRCxpREFBaUQ7cUJBQzVDLElBQUksTUFBQSxNQUFBLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQyxVQUFVLDBDQUFFLElBQUksMENBQUUsSUFBSSxFQUFFLENBQUM7b0JBQ3JELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxjQUFjLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7d0JBQy9DLE1BQU0sS0FBSyxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFFaEMsVUFBVTt3QkFDVixNQUFNLGVBQWUsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUNuQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQzFDOzRCQUNDLENBQUMsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDOzRCQUM5QyxDQUFDLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO3dCQUU5QyxJQUNFLEtBQUssQ0FBQyxRQUFRLEtBQUssZUFBZTs0QkFDbEMsS0FBSyxDQUFDLFFBQVEsS0FBSyxnQkFBZ0IsQ0FBQyxJQUFJOzRCQUN4QyxLQUFLLENBQUMsUUFBUSxLQUFLLGdCQUFnQixDQUFDLE9BQU87NEJBQzNDLGVBQWUsS0FBSyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQzNDLENBQUM7NEJBQ0QsSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyxVQUFVLEVBQUUsQ0FBQztnQ0FDdkMsTUFBTSxJQUFJLEdBQ1IsQ0FBQSxNQUFBLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxJQUFJLENBQ1gsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsS0FBSyxLQUFLLEtBQUssQ0FBQyxJQUFJLENBQ3JELDBDQUFFLEtBQUssS0FBSSxLQUFLLENBQUMsSUFBSSxDQUFDO2dDQUV6QixNQUFNLElBQUksWUFBWSxDQUNwQixnQkFBZ0IsQ0FBQyxXQUFXLEVBQzVCO29DQUNFLEdBQUcsRUFBRSw0Q0FBNEM7b0NBQ2pELFVBQVUsRUFBRSxJQUFJO29DQUNoQixVQUFVLEVBQUUsS0FBSyxDQUFDLFFBQVE7b0NBQzFCLFlBQVksRUFBRSxlQUFlO2lDQUM5QixFQUNELFNBQVMsSUFBSSxTQUFTLEtBQUssQ0FBQyxRQUFRLHNCQUFzQixlQUFlLG1CQUFtQixDQUM3RixDQUFDOzRCQUNKLENBQUM7aUNBQU0sQ0FBQztnQ0FDTixJQUFJLEdBQUcsR0FBRyxFQUFFLENBQUM7Z0NBQ2IsTUFBTSxRQUFRLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQ0FDdkIsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDO2dDQUVkLElBQUksZUFBZSxLQUFLLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxDQUFDO29DQUNqRCxHQUFHLEdBQUcsNEJBQTRCLENBQUM7b0NBQ25DLElBQUksR0FBRyxTQUFTLENBQUM7Z0NBQ25CLENBQUM7cUNBQU0sSUFBSSxlQUFlLEtBQUssZ0JBQWdCLENBQUMsT0FBTyxFQUFFLENBQUM7b0NBQ3hELEdBQUcsR0FBRyw0QkFBNEIsQ0FBQztvQ0FDbkMsSUFBSSxHQUFHLFNBQVMsQ0FBQztnQ0FDbkIsQ0FBQztxQ0FBTSxJQUFJLGVBQWUsS0FBSyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsQ0FBQztvQ0FDckQsR0FBRyxHQUFHLDRCQUE0QixDQUFDO29DQUNuQyxJQUFJLEdBQUcsTUFBTSxDQUFDO2dDQUNoQixDQUFDO2dDQUVELE1BQU0sSUFBSSxZQUFZLENBQ3BCLGdCQUFnQixDQUFDLFdBQVcsRUFDNUI7b0NBQ0UsSUFBSTtvQ0FDSixHQUFHO29DQUNILFFBQVE7b0NBQ1IsVUFBVTtpQ0FDWCxFQUNELEdBQUcsVUFBVSxhQUFWLFVBQVUsdUJBQVYsVUFBVSxDQUFFLFdBQVcsRUFBRSxlQUMxQixJQUFJLElBQUksZUFDVixnQkFBZ0IsUUFBUSxFQUFFLENBQzNCLENBQUM7NEJBQ0osQ0FBQzt3QkFDSCxDQUFDO3dCQUVELGdGQUFnRjt3QkFDaEYsSUFDRSxlQUFlLEtBQUssZ0JBQWdCLENBQUMsTUFBTTs0QkFDM0MsZUFBZSxLQUFLLEtBQUssQ0FBQyxRQUFRLEVBQ2xDLENBQUM7NEJBQ0QsS0FBSyxDQUFDLElBQUksR0FBRyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUM7d0JBQ3ZDLENBQUM7b0JBQ0gsQ0FBQztnQkFDSCxDQUFDO2dCQUVELElBQUksT0FBTyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUMsVUFBVSxLQUFLLFVBQVUsRUFBRSxDQUFDO29CQUMxRCxHQUFHLENBQUMsUUFBUSxHQUFHLE1BQUMsTUFBQSxRQUFRLENBQUMsVUFBVSxDQUFDLEVBQUMsVUFBa0IsbURBQ3JELFFBQVEsQ0FDVyxDQUFDO2dCQUN4QixDQUFDO3FCQUFNLElBQUksUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFVBQVUsRUFBRSxDQUFDO29CQUMzQyxHQUFHLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQyxVQUE4QixDQUFDO2dCQUNyRSxDQUFDO1lBQ0gsQ0FBQztpQkFBTSxJQUFJLFVBQVUsQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDLFVBQVUsRUFBRSxDQUFDO2dCQUNuRCxNQUFNLEdBQUcsR0FBRyxDQUFDLGFBQWEsQ0FBRSxVQUE2QixDQUFDLElBQUksQ0FBQztvQkFDN0QsZ0JBQWdCLENBQUUsVUFBNkIsQ0FBQyxJQUFJLENBQUMsQ0FHdEQsQ0FBQztnQkFFRixJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7b0JBQ1QsTUFBTSxJQUFJLFlBQVksQ0FDcEIsZ0JBQWdCLENBQUMsY0FBYyxFQUMvQjt3QkFDRSxHQUFHLEVBQUUsZ0NBQWdDO3dCQUNyQyxVQUFVLEVBQUcsVUFBNkIsQ0FBQyxJQUFJO3FCQUNoRCxFQUNELDBCQUEwQixJQUFJLENBQUMsU0FBUyxDQUNyQyxVQUE2QixDQUFDLElBQUksQ0FDcEMsYUFBYSxDQUNmLENBQUM7Z0JBQ0osQ0FBQztnQkFFQSxHQUFzQixDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsRUFBRSxDQUFDO2dCQUV0QyxJQUFJLENBQUEsR0FBRyxhQUFILEdBQUcsdUJBQUgsR0FBRyxDQUFFLElBQUksTUFBSyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7b0JBQ2xDLElBQUksTUFBTSxFQUFFLENBQUM7d0JBQ1gsZ0dBQWdHO3dCQUNoRyxNQUFNLDBCQUEwQixDQUM5QixNQUFNLEVBQ04sVUFBVSxFQUNWLE9BQU8sRUFDUCxPQUFPLENBQ1IsQ0FBQztvQkFDSixDQUFDO29CQUNELE1BQU0sVUFBVSxHQUNiLEdBQUcsQ0FBQyxVQUEwQixDQUFDLFdBQVc7d0JBQzNDLENBQUMsTUFBTSxxQ0FBcUM7d0JBQzFDLGdFQUFnRTt3QkFDaEUseURBQXlEO3dCQUN6RDs0QkFDRSxPQUFPLEVBQUUsR0FBRyxDQUFDLFVBQVUsQ0FBQyxPQUFPO2lDQUM1QixVQUFVLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQztpQ0FDckIsVUFBVSxDQUFDLElBQUksRUFBRSxHQUFHLENBQUM7NEJBQ3hCLE9BQU87NEJBQ1AsYUFBYTs0QkFDYixPQUFPO3lCQUNSLENBQ0YsQ0FBQyxDQUFDO29CQUVMLEdBQUcsQ0FBQyxRQUFRLEdBQUksVUFBZ0MsYUFBaEMsVUFBVSx1QkFBVixVQUFVLENBQXdCLFFBQVEsQ0FBQztnQkFDN0QsQ0FBQztxQkFBTSxDQUFDO29CQUNOLElBQ0UsQ0FBQSxHQUFHLGFBQUgsR0FBRyx1QkFBSCxHQUFHLENBQUUsSUFBSSxNQUFLLE9BQU8sQ0FBQyxNQUFNO3dCQUM1QixDQUFBLEdBQUcsYUFBSCxHQUFHLHVCQUFILEdBQUcsQ0FBRSxJQUFJLE1BQUssT0FBTyxDQUFDLG1CQUFtQixFQUN6QyxDQUFDO3dCQUNELGdHQUFnRzt3QkFDaEcsSUFBSSxNQUFNLEVBQUUsQ0FBQzs0QkFDWCxNQUFNLDBCQUEwQixDQUM5QixNQUFNLEVBQ04sVUFBVSxFQUNWLE9BQU8sRUFDUCxPQUFPLENBQ1IsQ0FBQzt3QkFDSixDQUFDO29CQUNILENBQUM7b0JBRUQsOEJBQThCO29CQUM5QixNQUFNLENBQUMsTUFBTSxDQUNYLEdBQUcsRUFDSCxNQUFNLDJCQUEyQixDQUFDO3dCQUNoQyxHQUFHO3dCQUNILE9BQU87d0JBQ1AsT0FBTzt3QkFDUCxhQUFhO3FCQUNkLENBQUMsQ0FDSCxDQUFDO2dCQUNKLENBQUM7WUFDSCxDQUFDO2lCQUFNLElBQUksVUFBVSxDQUFDLElBQUksS0FBSyxRQUFRLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBQ2hELElBQUksT0FBTyxVQUFVLENBQUMsS0FBSyxLQUFLLFFBQVEsRUFBRSxDQUFDO29CQUN6QyxHQUFHLENBQUMsUUFBUSxHQUFHLGdCQUFnQixDQUFDLE9BQU8sQ0FBQztnQkFDMUMsQ0FBQztxQkFBTSxJQUFJLE9BQU8sVUFBVSxDQUFDLEtBQUssS0FBSyxRQUFRLEVBQUUsQ0FBQztvQkFDaEQsR0FBRyxDQUFDLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUM7Z0JBQ3pDLENBQUM7cUJBQU0sSUFBSSxPQUFPLFVBQVUsQ0FBQyxLQUFLLEtBQUssU0FBUyxFQUFFLENBQUM7b0JBQ2pELEdBQUcsQ0FBQyxRQUFRLEdBQUcsZ0JBQWdCLENBQUMsT0FBTyxDQUFDO2dCQUMxQyxDQUFDO3FCQUFNLENBQUM7b0JBQ04sR0FBRyxDQUFDLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUM7Z0JBQ3pDLENBQUM7WUFDSCxDQUFDO2lCQUFNLElBQUksVUFBVSxDQUFDLElBQUksS0FBSyxRQUFRLENBQUMsU0FBUyxFQUFFLENBQUM7Z0JBQ2xELDBCQUEwQjtnQkFDMUIsSUFDRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDO29CQUNuQyxVQUFVLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSyxRQUFRLENBQUMsT0FBTztvQkFDN0MsT0FBTyxVQUFVLENBQUMsUUFBUSxDQUFDLEtBQUssS0FBSyxRQUFRLEVBQzdDLENBQUM7b0JBQ0QsR0FBRyxDQUFDLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUM7Z0JBQzFDLENBQUM7cUJBQU0sQ0FBQztvQkFDTixNQUFNLElBQUksWUFBWSxDQUNwQixnQkFBZ0IsQ0FBQyxhQUFhLEVBQzlCLEVBQUUsRUFDRixxQkFBcUIsVUFBVSxDQUFDLFFBQVEsb0JBQW9CLENBQzdELENBQUM7Z0JBQ0osQ0FBQztZQUNILENBQUM7aUJBQU0sSUFBSSxVQUFVLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyxVQUFVLEVBQUUsQ0FBQztnQkFDbEQsR0FBNEIsQ0FBQyxJQUFJLEdBQUcsTUFBTSxrQkFBa0IsQ0FDM0QsVUFBVSxDQUFDLElBQUksQ0FDaEIsQ0FBQztnQkFDRCxHQUE0QixDQUFDLEtBQUssR0FBRyxNQUFNLGtCQUFrQixDQUM1RCxVQUFVLENBQUMsS0FBSyxDQUNqQixDQUFDO2dCQUVGLE1BQU0scUJBQXFCLEdBQUcsb0NBQW9DLENBQUM7b0JBQ2pFLGdCQUFnQixFQUFFLEdBQVU7aUJBQzdCLENBQUMsQ0FBQztnQkFDSCxJQUFJLHFCQUFxQixFQUFFLENBQUM7b0JBQzFCLE1BQU0sQ0FBQyxNQUFNLENBQ1gsR0FBRyxFQUNILG9DQUFvQyxDQUFDLEVBQUUsZ0JBQWdCLEVBQUUsR0FBVSxFQUFFLENBQUMsQ0FDdkUsQ0FBQztvQkFDRixJQUFJLEdBQUcsQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDLFVBQVUsRUFBRSxDQUFDO3dCQUNwQyxHQUFXLENBQUMsSUFBSSxHQUFHLFNBQVMsQ0FBQzt3QkFDN0IsR0FBVyxDQUFDLEtBQUssR0FBRyxTQUFTLENBQUM7d0JBQzlCLEdBQVcsQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDO29CQUNwQyxDQUFDO2dCQUNILENBQUM7cUJBQU0sSUFDTCxDQUFDLElBQUksRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsRUFDaEUsQ0FBQztvQkFDRCxHQUFHLENBQUMsUUFBUSxHQUFHLGdCQUFnQixDQUFDLFFBQVEsQ0FBQztnQkFDM0MsQ0FBQztxQkFBTSxJQUFJLFVBQVUsQ0FBQyxRQUFRLEtBQUssR0FBRyxFQUFFLENBQUM7b0JBQ3ZDLEdBQUcsQ0FBQyxRQUFRLEdBQUcsZ0JBQWdCLENBQUMsT0FBTyxDQUFDO29CQUN4QyxxRkFBcUY7b0JBQ3JGLHNCQUFzQjtvQkFDdEIsSUFDRTt3QkFDRyxHQUE0QixDQUFDLElBQUk7d0JBQ2pDLEdBQTRCLENBQUMsS0FBSztxQkFDcEMsQ0FBQyxJQUFJLENBQ0osQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUNKLENBQUM7d0JBQ0MsZ0JBQWdCLENBQUMsT0FBTzt3QkFDeEIsZ0JBQWdCLENBQUMsT0FBTzt3QkFDeEIsZ0JBQWdCLENBQUMsSUFBSTt3QkFDckIsZ0JBQWdCLENBQUMsT0FBTztxQkFDekIsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUN6QixFQUNELENBQUM7d0JBQ0QsR0FBRyxDQUFDLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUM7b0JBQ3pDLENBQUM7Z0JBQ0gsQ0FBQztxQkFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDO29CQUMvQyxHQUFHLENBQUMsUUFBUSxHQUFHLGdCQUFnQixDQUFDLE1BQU0sQ0FBQztnQkFDekMsQ0FBQztxQkFBTSxDQUFDO29CQUNOLEdBQUcsQ0FBQyxRQUFRLEdBQUcsZ0JBQWdCLENBQUMsT0FBTyxDQUFDO2dCQUMxQyxDQUFDO1lBQ0gsQ0FBQztpQkFBTSxJQUFJLFVBQVUsQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDLFVBQVUsRUFBRSxDQUFDO2dCQUNuRCxNQUFNLElBQUksWUFBWSxDQUNwQixnQkFBZ0IsQ0FBQyxhQUFhLEVBQzlCLEVBQUUsRUFDRixtQ0FBbUMsQ0FDcEMsQ0FBQztZQUNKLENBQUM7aUJBQU0sSUFBSSxVQUFVLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBQztnQkFDbEQsTUFBTSxJQUFJLFlBQVksQ0FDcEIsZ0JBQWdCLENBQUMsYUFBYSxFQUM5QixFQUFFLEVBQ0Ysd0JBQXdCLENBQ3pCLENBQUM7WUFDSixDQUFDO2lCQUFNLElBQUksVUFBVSxDQUFDLElBQUksS0FBSyxRQUFRLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQ2pELE1BQU0sSUFBSSxZQUFZLENBQ3BCLGdCQUFnQixDQUFDLGFBQWEsRUFDOUIsRUFBRSxFQUNGLHFDQUFxQyxDQUN0QyxDQUFDO1lBQ0osQ0FBQztZQUNELE9BQU8sR0FBRyxDQUFDO1FBQ2IsQ0FBQyxDQUFBLENBQUM7UUFFRiwyQkFBMkI7UUFDM0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDckMsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3BDLHdDQUF3QztRQUN4QyxNQUFNLE1BQU0sR0FBRyxNQUFNLGtCQUFrQixDQUNyQyxhQUE2QyxDQUM5QyxDQUFDO1FBQ0YsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztDQUFBO0FBRUQsU0FBUyxvQ0FBb0MsQ0FBQyxNQUU3QztJQUNDLE1BQU0sRUFBRSxnQkFBZ0IsRUFBRSxHQUFHLE1BQU0sQ0FBQztJQUNwQyxJQUFJLEdBQThDLENBQUM7SUFFbkQsSUFDRSxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxRQUFRLENBQ3pELGdCQUFnQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQy9CO1FBQ0QsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQUMsUUFBUSxDQUN6RCxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUNoQztRQUNELGdCQUFnQixDQUFDLFFBQVEsS0FBSyxHQUFHLEVBQ2pDLENBQUM7UUFDRCxzRUFBc0U7UUFDdEUsSUFDRSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO1lBQ3BFLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsRUFDckUsQ0FBQztZQUNELEdBQUcsR0FBRztnQkFDSixJQUFJLEVBQUUsUUFBUSxDQUFDLFFBQVE7Z0JBQ3ZCLFNBQVMsRUFBRTtvQkFDVCxnQkFBZ0IsQ0FBQyxJQUFJO29CQUNyQixnQkFBZ0IsQ0FBQyxLQUFLO29CQUN0Qjt3QkFDRSxJQUFJLEVBQUUsU0FBUzt3QkFDZixLQUFLLEVBQUUsU0FBUzt3QkFDaEIsR0FBRyxFQUFFLFdBQVc7d0JBQ2hCLFFBQVEsRUFBRSxRQUFRO3FCQUNuQjtpQkFDRjtnQkFDRCxNQUFNLEVBQUU7b0JBQ04sSUFBSSxFQUFFLFlBQVk7b0JBQ2xCLElBQUksRUFBRSxlQUFlO2lCQUN0QjtnQkFDRCxRQUFRLEVBQUUsZ0JBQWdCLENBQUMsT0FBTzthQUNiLENBQUM7UUFDMUIsQ0FBQztRQUNELHVEQUF1RDthQUNsRCxJQUNILENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7WUFDaEUsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxFQUNqRSxDQUFDO1lBQ0QsR0FBRyxHQUFHO2dCQUNKLElBQUksRUFBRSxRQUFRLENBQUMsUUFBUTtnQkFDdkIsU0FBUyxFQUFFO29CQUNULGdCQUFnQixDQUFDLElBQUk7b0JBQ3JCLGdCQUFnQixDQUFDLEtBQUs7b0JBQ3RCO3dCQUNFLElBQUksRUFBRSxTQUFTO3dCQUNmLEtBQUssRUFBRSxTQUFTO3dCQUNoQixHQUFHLEVBQUUsV0FBVzt3QkFDaEIsUUFBUSxFQUFFLFFBQVE7cUJBQ25CO2lCQUNGO2dCQUNELE1BQU0sRUFBRTtvQkFDTixJQUFJLEVBQUUsWUFBWTtvQkFDbEIsSUFBSSxFQUFFLGVBQWU7aUJBQ3RCO2dCQUNELFFBQVEsRUFBRSxnQkFBZ0IsQ0FBQyxPQUFPO2FBQ2IsQ0FBQztRQUMxQixDQUFDO1FBQ0Qsd0RBQXdEO1FBQ3hELHNCQUFzQjtRQUN0Qiw4Q0FBOEM7YUFDekMsSUFDSCxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQ3pELGdCQUFnQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQy9CO1lBQ0QsQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUN6RCxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUNoQztZQUNELGdCQUFnQixDQUFDLElBQUksQ0FBQyxRQUFRLElBQUksZ0JBQWdCLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFDakUsQ0FBQztZQUNELEdBQUcsR0FBRztnQkFDSixJQUFJLEVBQUUsUUFBUSxDQUFDLFVBQVU7Z0JBQ3pCLElBQUksRUFBRSxnQkFBZ0IsQ0FBQyxJQUFJO2dCQUMzQixLQUFLLEVBQUUsZ0JBQWdCLENBQUMsS0FBSztnQkFDN0IsUUFBUSxFQUFFLEdBQUc7Z0JBQ2IsUUFBUSxFQUFFLGdCQUFnQixDQUFDLElBQUk7YUFDUixDQUFDO1FBQzVCLENBQUM7SUFDSCxDQUFDO1NBQU0sSUFDTCxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxRQUFRLENBQ3pELGdCQUFnQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQy9CO1FBQ0QsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQUMsUUFBUSxDQUN6RCxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUNoQztRQUNELGdCQUFnQixDQUFDLFFBQVEsS0FBSyxHQUFHLEVBQ2pDLENBQUM7UUFDRCwwRUFBMEU7UUFDMUUsSUFDRSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO1lBQ3BFLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsRUFDckUsQ0FBQztZQUNELE1BQU0sSUFBSSxHQUFHO2dCQUNYLElBQUksRUFBRSxRQUFRLENBQUMsUUFBUTtnQkFDdkIsU0FBUyxFQUFFO29CQUNULGdCQUFnQixDQUFDLElBQUk7b0JBQ3JCO3dCQUNFLElBQUksRUFBRSxTQUFTO3dCQUNmLEtBQUssRUFBRSxVQUFVO3dCQUNqQixHQUFHLEVBQUUsWUFBWTt3QkFDakIsUUFBUSxFQUFFLGdCQUFnQixDQUFDLFFBQVE7cUJBQ3BDO29CQUNEO3dCQUNFLElBQUksRUFBRSxTQUFTO3dCQUNmLEtBQUssRUFBRSxTQUFTO3dCQUNoQixHQUFHLEVBQUUsV0FBVzt3QkFDaEIsUUFBUSxFQUFFLFFBQVE7cUJBQ25CO2lCQUNGO2dCQUNELE1BQU0sRUFBRTtvQkFDTixJQUFJLEVBQUUsWUFBWTtvQkFDbEIsSUFBSSxFQUFFLGVBQWU7aUJBQ3RCO2dCQUNELFFBQVEsRUFBRSxnQkFBZ0IsQ0FBQyxPQUFPO2FBQ2IsQ0FBQztZQUN4QixNQUFNLEtBQUssR0FBRztnQkFDWixJQUFJLEVBQUUsUUFBUSxDQUFDLFFBQVE7Z0JBQ3ZCLFNBQVMsRUFBRTtvQkFDVCxnQkFBZ0IsQ0FBQyxLQUFLO29CQUN0Qjt3QkFDRSxJQUFJLEVBQUUsU0FBUzt3QkFDZixLQUFLLEVBQUUsVUFBVTt3QkFDakIsR0FBRyxFQUFFLFlBQVk7d0JBQ2pCLFFBQVEsRUFBRSxnQkFBZ0IsQ0FBQyxRQUFRO3FCQUNwQztvQkFDRDt3QkFDRSxJQUFJLEVBQUUsU0FBUzt3QkFDZixLQUFLLEVBQUUsU0FBUzt3QkFDaEIsR0FBRyxFQUFFLFdBQVc7d0JBQ2hCLFFBQVEsRUFBRSxRQUFRO3FCQUNuQjtpQkFDRjtnQkFDRCxNQUFNLEVBQUU7b0JBQ04sSUFBSSxFQUFFLFlBQVk7b0JBQ2xCLElBQUksRUFBRSxlQUFlO2lCQUN0QjtnQkFDRCxRQUFRLEVBQUUsZ0JBQWdCLENBQUMsT0FBTzthQUNiLENBQUM7WUFDeEIsT0FBTztnQkFDTCxJQUFJLEVBQUUsUUFBUSxDQUFDLFVBQVU7Z0JBQ3pCLElBQUk7Z0JBQ0osS0FBSztnQkFDTCxRQUFRLEVBQUUsR0FBRztnQkFDYixRQUFRLEVBQUUsZ0JBQWdCLENBQUMsT0FBTzthQUNYLENBQUM7UUFDNUIsQ0FBQztRQUNELHdEQUF3RDtRQUN4RCxzQkFBc0I7UUFDdEIsOENBQThDO2FBQ3pDLElBQ0gsQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUN6RCxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUMvQjtZQUNELENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FDekQsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FDaEM7WUFDRCxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxJQUFJLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQ2pFLENBQUM7WUFDRCxHQUFHLEdBQUc7Z0JBQ0osSUFBSSxFQUFFLFFBQVEsQ0FBQyxVQUFVO2dCQUN6QixJQUFJLEVBQUUsZ0JBQWdCLENBQUMsSUFBSTtnQkFDM0IsS0FBSyxFQUFFLGdCQUFnQixDQUFDLEtBQUs7Z0JBQzdCLFFBQVEsRUFBRSxHQUFHO2dCQUNiLFFBQVEsRUFBRSxnQkFBZ0IsQ0FBQyxJQUFJO2FBQ1IsQ0FBQztRQUM1QixDQUFDO0lBQ0gsQ0FBQztJQUNELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQUNELFNBQWUsMEJBQTBCLENBQ3ZDLFVBQXNCLEVBQ3RCLFVBQTZCLEVBQzdCLE9BQXFCLEVBQ3JCLE9BQTRFOztRQUU1RSw2QkFBNkI7UUFDN0IsTUFBTSxZQUFZLEdBQUcsTUFBTSxPQUFPLENBQUMsTUFBTSxDQUFDLENBQU8sVUFBVSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ2hFLE1BQU0sR0FBRyxHQUFHLE1BQU0sVUFBVSxDQUFDO1lBQzdCLElBQUksQ0FBQyxDQUFDLEVBQUUsS0FBSyxVQUFVLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUN6RCxNQUFNLFVBQVUsR0FBRztvQkFDakIsR0FBRyxJQUFJLEdBQUcsQ0FDUixDQUNHLENBQUMsQ0FBQyxVQUEwQixDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsZUFBZSxDQUFDLElBQUksRUFBRSxDQUNuRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQ2pCLE9BQU8sQ0FBQyxJQUFJLENBQ1YsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUssS0FBSyxJQUFJLEdBQUcsQ0FBQyxJQUFJLEtBQUssT0FBTyxDQUFDLE9BQU8sQ0FDMUQsQ0FDRixDQUNGO2lCQUNGLENBQUM7Z0JBQ0YsSUFBSSxVQUFVLENBQUMsTUFBTTtvQkFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsVUFBVSxFQUFFLENBQUMsQ0FBQztZQUMxRCxDQUFDO2lCQUFNLElBQ0wsQ0FBQyxDQUFDLElBQUksS0FBSyxPQUFPLENBQUMsTUFBTTtnQkFDekIsQ0FBQyxDQUFDLElBQUksS0FBSyxPQUFPLENBQUMsbUJBQW1CLEVBQ3RDLENBQUM7Z0JBQ0QsTUFBTSxVQUFVLEdBQUcsTUFBTSx5QkFBeUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDdEQsSUFBSSxVQUFVLGFBQVYsVUFBVSx1QkFBVixVQUFVLENBQUUsTUFBTTtvQkFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsVUFBVSxFQUFFLENBQUMsQ0FBQztZQUMzRCxDQUFDO1lBQ0QsT0FBTyxHQUFHLENBQUM7UUFDYixDQUFDLENBQUEsRUFBRSxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFFeEIsU0FBZSxvQkFBb0IsQ0FBQyxHQUFlLEVBQUUsT0FBcUI7O2dCQUN4RSxNQUFNLFVBQVUsR0FBRyxFQUFFLENBQUM7Z0JBRXRCLElBQUksVUFBVSxDQUFDLFdBQVcsS0FBSyxHQUFHLENBQUMsV0FBVyxFQUFFLENBQUM7b0JBQy9DLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQ2xCLENBQUM7Z0JBRUQsMkRBQTJEO2dCQUMzRCxNQUFNLGlCQUFpQixHQUNwQixHQUFHLENBQUMsVUFBMEIsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztnQkFFdkUsS0FBSyxNQUFNLFFBQVEsSUFBSSxpQkFBaUIsRUFBRSxDQUFDO29CQUN6QyxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLFFBQVEsQ0FBQyxDQUFDO29CQUN0RCxJQUFJLE1BQU0sQ0FBQyxJQUFJLEtBQUssT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO3dCQUNwQyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLG9CQUFvQixDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ3BFLENBQUM7eUJBQU0sSUFDTCxNQUFNLENBQUMsSUFBSSxLQUFLLE9BQU8sQ0FBQyxNQUFNO3dCQUM5QixNQUFNLENBQUMsSUFBSSxLQUFLLE9BQU8sQ0FBQyxtQkFBbUIsRUFDM0MsQ0FBQzt3QkFDRCxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLHlCQUF5QixDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDaEUsQ0FBQztnQkFDSCxDQUFDO2dCQUNELE9BQU8sVUFBVSxDQUFDO1lBQ3BCLENBQUM7U0FBQTtRQUVELGlEQUFpRDtRQUNqRCxTQUFlLHlCQUF5QixDQUN0QyxlQUVDOztnQkFFRCxNQUFNLFVBQVUsR0FBRyxFQUFFLENBQUM7Z0JBRXRCLElBQUksVUFBc0IsQ0FBQztnQkFDM0IsSUFBSSxjQUErQyxDQUFDO2dCQUVwRCxJQUFJLGVBQWUsQ0FBQyxJQUFJLEtBQUssT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDO29CQUM1QyxNQUFNLGFBQWEsR0FBSSxlQUFlLENBQUMsVUFBeUI7eUJBQzdELHFCQUFxQixDQUFDO29CQUN6QixNQUFNLFdBQVcsR0FBSSxlQUFlLENBQUMsVUFBeUI7eUJBQzNELG1CQUFtQixDQUFDO29CQUN2QixVQUFVLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxhQUFhLENBQUMsQ0FBQztvQkFDekQsY0FBYyxHQUFHLENBQUMsTUFBa0IsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsS0FBSyxXQUFXLENBQUM7Z0JBQ3JFLENBQUM7cUJBQU0sSUFBSSxlQUFlLENBQUMsSUFBSSxLQUFLLE9BQU8sQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO29CQUNoRSxVQUFVLEdBQUcsZUFBZSxDQUFDO29CQUM3QixjQUFjLEdBQUcsQ0FBQyxNQUFrQixFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQztnQkFDdkQsQ0FBQztnQkFFRCxJQUFJLFVBQVUsRUFBRSxDQUFDO29CQUNmLE1BQU0sZ0JBQWdCLEdBQUcsTUFBTSxPQUFPLENBQ25DLFVBQVUsQ0FBQyxVQUFzQyxDQUFDLG1CQUFtQixDQUN2RSxDQUFDO29CQUNGLE1BQU0sWUFBWSxHQUFHLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7b0JBRW5FLElBQUksWUFBWSxFQUFFLENBQUM7d0JBQ2pCLElBQUksWUFBWSxDQUFDLElBQUksS0FBSyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7NEJBQzFDLFVBQVUsQ0FBQyxJQUFJLENBQ2IsR0FBRyxDQUFDLE1BQU0sb0JBQW9CLENBQzVCLFlBQVksRUFDWixnQkFBZ0IsQ0FBQyxPQUFPLENBQ3pCLENBQUMsQ0FDSCxDQUFDO3dCQUNKLENBQUM7NkJBQU0sSUFDTCxZQUFZLENBQUMsSUFBSSxLQUFLLE9BQU8sQ0FBQyxNQUFNOzRCQUNwQyxZQUFZLENBQUMsSUFBSSxLQUFLLE9BQU8sQ0FBQyxtQkFBbUIsRUFDakQsQ0FBQzs0QkFDRCxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLHlCQUF5QixDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFDdEUsQ0FBQztvQkFDSCxDQUFDO2dCQUNILENBQUM7Z0JBQ0QsT0FBTyxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztZQUNsQyxDQUFDO1NBQUE7UUFFRCx5RUFBeUU7UUFDekUsTUFBTSxnQkFBZ0IsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUNuQyxDQUFDLENBQWEsRUFBRSxFQUFFLENBQ2hCLENBQUMsQ0FBQyxLQUFLLEtBQU0sVUFBNkIsQ0FBQyxJQUFJO1lBQy9DLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsbUJBQW1CLEVBQUUsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FDckUsQ0FBQyxDQUFDLElBQWUsQ0FDbEIsQ0FDSixDQUFDO1FBRUYsSUFBSSxnQkFBZ0IsS0FBSSxVQUFVLGFBQVYsVUFBVSx1QkFBVixVQUFVLENBQUUsRUFBRSxDQUFBLEVBQUUsQ0FBQztZQUN2QyxZQUFZLENBQUMsSUFBSSxDQUFDO2dCQUNoQixDQUFDLFVBQVUsYUFBVixVQUFVLHVCQUFWLFVBQVUsQ0FBRSxFQUFZLENBQUMsRUFBRSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQzthQUNsRCxDQUFDLENBQUM7UUFDTCxDQUFDO1FBQ0QsTUFBTSxRQUFRLEdBQUcsWUFBWSxDQUFDLE1BQU0sQ0FBQztRQUNyQyxJQUFJLFFBQVEsR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUNqQiwwQ0FBMEM7WUFDMUMsTUFBTSxHQUFHLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQztZQUN0QixNQUFNLFNBQVMsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDO1lBQzVCLGlDQUFpQztZQUVqQyxLQUFLLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDO2dCQUNsRCxNQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUM5QixNQUFNLFVBQVUsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQzFCLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7Z0JBQzVDLEtBQUssTUFBTSxTQUFTLElBQUksVUFBVSxFQUFFLENBQUM7b0JBQ25DLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7b0JBQ3pELFNBQVMsQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDaEUsQ0FBQztZQUNILENBQUM7WUFDRCxNQUFNLEtBQUssR0FBYSxFQUFFLENBQUM7WUFDM0Isd0VBQXdFO1lBQ3hFLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxRQUFRLEVBQUUsR0FBRyxFQUFFLEVBQUU7Z0JBQ2xDLElBQUksUUFBUSxLQUFLLENBQUMsRUFBRSxDQUFDO29CQUNuQix5REFBeUQ7b0JBQ3pELEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ2xCLENBQUM7WUFDSCxDQUFDLENBQUMsQ0FBQztZQUNILGlDQUFpQztZQUNqQyxJQUFJLE9BQU8sR0FBRyxDQUFDLENBQUM7WUFDaEIsTUFBTTtZQUNOLE9BQU8sS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztnQkFDMUIsaUNBQWlDO2dCQUNqQyxNQUFNLEdBQUcsR0FBRyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUM7Z0JBQzFCLHFEQUFxRDtnQkFDckQsTUFBTSxVQUFVLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDO2dCQUM3QyxJQUFJLFVBQVUsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxFQUFFLENBQUM7b0JBQ3hCLE9BQU8sSUFBSSxDQUFDLENBQUM7Z0JBQ2YsQ0FBQztnQkFDRCxrQ0FBa0M7Z0JBQ2xDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxTQUFpQixFQUFFLEVBQUU7b0JBQ3ZDLDRDQUE0QztvQkFDNUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsU0FBUyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztvQkFDdkQseUJBQXlCO29CQUN6QixJQUFJLFNBQVMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7d0JBQ25DLDZDQUE2Qzt3QkFDN0MsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztvQkFDeEIsQ0FBQztnQkFDSCxDQUFDLENBQUMsQ0FBQztZQUNMLENBQUM7WUFDRCw2Q0FBNkM7WUFDN0MsSUFBSSxRQUFRLEtBQUssT0FBTyxFQUFFLENBQUM7Z0JBQ3pCLE1BQU0sSUFBSSxZQUFZLENBQ3BCLGdCQUFnQixDQUFDLGtCQUFrQixFQUNuQztvQkFDRSxHQUFHLEVBQUUsdUNBQXVDO2lCQUM3QyxFQUNELDZCQUE2QixDQUM5QixDQUFDO1lBQ0osQ0FBQztRQUNILENBQUM7SUFDSCxDQUFDO0NBQUEifQ==