import jsep from 'jsep';
import { ColumnType } from './Api';
import { SqlUiFactory } from './sqlUi';
type SqlUI = ReturnType<(typeof SqlUiFactory)['create']>;
type ClientTypeOrSqlUI = 'mysql' | 'pg' | 'sqlite3' | 'mysql2' | 'oracledb' | 'mariadb' | 'sqlite' | 'snowflake' | SqlUI;
export declare const StringOperators: readonly ["||", "&"];
export declare const ArithmeticOperators: readonly ["+", "-", "*", "/"];
export declare const ComparisonOperators: readonly ["==", "=", "<", ">", "<=", ">=", "!="];
export type ArithmeticOperator = (typeof ArithmeticOperators)[number];
export type ComparisonOperator = (typeof ComparisonOperators)[number];
export type StringOperator = (typeof StringOperators)[number];
export type BaseFormulaNode = {
    type: JSEPNode;
    dataType?: FormulaDataTypes;
    cast?: FormulaDataTypes;
    errors?: Set<string>;
};
export interface BinaryExpressionNode extends BaseFormulaNode {
    operator: ArithmeticOperator | ComparisonOperator | StringOperator;
    type: JSEPNode.BINARY_EXP;
    right: ParsedFormulaNode;
    left: ParsedFormulaNode;
}
export interface CallExpressionNode extends BaseFormulaNode {
    type: JSEPNode.CALL_EXP;
    arguments: ParsedFormulaNode[];
    callee: {
        type?: string;
        name: string;
    };
}
export interface IdentifierNode extends BaseFormulaNode {
    type: JSEPNode.IDENTIFIER;
    name: string;
    raw: string;
}
export interface LiteralNode extends BaseFormulaNode {
    type: JSEPNode.LITERAL;
    value: string | number;
    raw: string;
}
export interface UnaryExpressionNode extends BaseFormulaNode {
    type: JSEPNode.UNARY_EXP;
    operator: string;
    argument: ParsedFormulaNode;
}
export interface ArrayExpressionNode extends BaseFormulaNode {
    type: JSEPNode.ARRAY_EXP;
}
export interface MemberExpressionNode extends BaseFormulaNode {
    type: JSEPNode.MEMBER_EXP;
}
export interface CompoundNode extends BaseFormulaNode {
    type: JSEPNode.COMPOUND;
}
export type ParsedFormulaNode = BinaryExpressionNode | CallExpressionNode | IdentifierNode | LiteralNode | MemberExpressionNode | ArrayExpressionNode | UnaryExpressionNode | CompoundNode;
export declare const jsepCurlyHook: jsep.IPlugin;
export declare function substituteColumnAliasWithIdInFormula(formula: any, columns: ColumnType[]): Promise<any>;
export declare enum FormulaErrorType {
    NOT_AVAILABLE = "NOT_AVAILABLE",
    NOT_SUPPORTED = "NOT_SUPPORTED",
    MIN_ARG = "MIN_ARG",
    MAX_ARG = "MAX_ARG",
    TYPE_MISMATCH = "TYPE_MISMATCH",
    INVALID_ARG = "INVALID_ARG",
    INVALID_ARG_TYPE = "INVALID_ARG_TYPE",
    INVALID_ARG_VALUE = "INVALID_ARG_VALUE",
    INVALID_ARG_COUNT = "INVALID_ARG_COUNT",
    CIRCULAR_REFERENCE = "CIRCULAR_REFERENCE",
    INVALID_FUNCTION_NAME = "INVALID_FUNCTION_NAME",
    INVALID_COLUMN = "INVALID_COLUMN"
}
export declare function substituteColumnIdWithAliasInFormula(formula: any, columns: ColumnType[], rawFormula?: any): any;
export declare function jsepTreeToFormula(node: any, isCallExpId?: boolean): any;
export declare enum FormulaDataTypes {
    NUMERIC = "numeric",
    STRING = "string",
    DATE = "date",
    LOGICAL = "logical",
    ARRAY = "array",
    COND_EXP = "conditional_expression",
    NULL = "null",
    BOOLEAN = "boolean",
    INTERVAL = "interval",
    UNKNOWN = "unknown"
}
export declare enum JSEPNode {
    COMPOUND = "Compound",
    IDENTIFIER = "Identifier",
    MEMBER_EXP = "MemberExpression",
    LITERAL = "Literal",
    THIS_EXP = "ThisExpression",
    CALL_EXP = "CallExpression",
    UNARY_EXP = "UnaryExpression",
    BINARY_EXP = "BinaryExpression",
    ARRAY_EXP = "ArrayExpression"
}
interface FormulaMeta {
    validation?: {
        args?: {
            min?: number;
            max?: number;
            rqd?: number;
            type?: FormulaDataTypes | FormulaDataTypes[];
        };
        custom?: (args: FormulaDataTypes[], parseTree: any) => void;
    };
    description?: string;
    syntax?: string;
    examples?: string[];
    returnType?: ((args: any[]) => FormulaDataTypes) | FormulaDataTypes;
    docsUrl?: string;
}
export declare const formulas: Record<string, FormulaMeta>;
export declare class FormulaError extends Error {
    type: FormulaErrorType;
    extra: Record<string, any>;
    constructor(type: FormulaErrorType, extra: {
        [key: string]: any;
    }, message?: string);
}
export declare function validateFormulaAndExtractTreeWithType({ formula, column, columns, clientOrSqlUi, getMeta, }: {
    formula: string;
    columns: ColumnType[];
    clientOrSqlUi: ClientTypeOrSqlUI;
    column?: ColumnType;
    getMeta: (tableId: string) => Promise<any>;
}): Promise<ParsedFormulaNode>;
export {};
