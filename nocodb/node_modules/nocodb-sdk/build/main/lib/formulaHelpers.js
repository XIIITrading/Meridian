"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FormulaError = exports.formulas = exports.JSEPNode = exports.FormulaDataTypes = exports.FormulaErrorType = exports.jsepCurlyHook = exports.ComparisonOperators = exports.ArithmeticOperators = exports.StringOperators = void 0;
exports.substituteColumnAliasWithIdInFormula = substituteColumnAliasWithIdInFormula;
exports.substituteColumnIdWithAliasInFormula = substituteColumnIdWithAliasInFormula;
exports.jsepTreeToFormula = jsepTreeToFormula;
exports.validateFormulaAndExtractTreeWithType = validateFormulaAndExtractTreeWithType;
const jsep_1 = __importDefault(require("jsep"));
const UITypes_1 = __importDefault(require("./UITypes"));
const dayjs_1 = __importDefault(require("dayjs"));
const sqlUi_1 = require("./sqlUi");
const dateTimeHelper_1 = require("./dateTimeHelper");
exports.StringOperators = ['||', '&'];
exports.ArithmeticOperators = ['+', '-', '*', '/'];
exports.ComparisonOperators = [
    '==',
    '=',
    '<',
    '>',
    '<=',
    '>=',
    '!=',
];
// opening and closing string code
const OCURLY_CODE = 123; // '{'
const CCURLY_CODE = 125; // '}'
exports.jsepCurlyHook = {
    name: 'curly',
    init(jsep) {
        // Match identifier in following pattern: {abc-cde}
        jsep.hooks.add('gobble-token', function escapedIdentifier(env) {
            // check if the current token is an opening curly bracket
            if (this.code === OCURLY_CODE) {
                const patternIndex = this.index;
                // move to the next character until we find a closing curly bracket
                while (this.index < this.expr.length) {
                    ++this.index;
                    if (this.code === CCURLY_CODE) {
                        let identifier = this.expr.slice(patternIndex, ++this.index);
                        // if starting with double curley brace then check for ending double curley brace
                        // if found include with the identifier
                        if (identifier.startsWith('{{') &&
                            this.expr.slice(patternIndex, this.index + 1).endsWith('}')) {
                            identifier = this.expr.slice(patternIndex, ++this.index);
                        }
                        env.node = {
                            type: jsep.IDENTIFIER,
                            name: /^{{.*}}$/.test(identifier)
                                ? // start would be the position of the first curly bracket
                                    // add 2 to point to the first character for expressions like {{col1}}
                                    identifier.slice(2, -2)
                                : // start would be the position of the first curly bracket
                                    // add 1 to point to the first character for expressions like {col1}
                                    identifier.slice(1, -1),
                            raw: identifier,
                        };
                        // env.node = this.gobbleTokenProperty(env.node);
                        return env.node;
                    }
                }
                this.throwError('Unclosed }');
            }
        });
    },
};
function validateDateWithUnknownFormat(v) {
    for (const format of dateTimeHelper_1.dateFormats) {
        if ((0, dayjs_1.default)(v, format, true).isValid()) {
            return true;
        }
        for (const timeFormat of ['HH:mm', 'HH:mm:ss', 'HH:mm:ss.SSS']) {
            if ((0, dayjs_1.default)(v, `${format} ${timeFormat}`, true).isValid()) {
                return true;
            }
        }
    }
    return false;
}
async function substituteColumnAliasWithIdInFormula(formula, columns) {
    const substituteId = async (pt) => {
        if (pt.type === 'CallExpression') {
            for (const arg of pt.arguments || []) {
                await substituteId(arg);
            }
        }
        else if (pt.type === 'Literal') {
            return;
        }
        else if (pt.type === 'Identifier') {
            const colNameOrId = pt.name;
            const column = columns.find((c) => c.id === colNameOrId ||
                c.column_name === colNameOrId ||
                c.title === colNameOrId);
            pt.name = '{' + column.id + '}';
        }
        else if (pt.type === 'BinaryExpression') {
            await substituteId(pt.left);
            await substituteId(pt.right);
        }
    };
    // register jsep curly hook
    jsep_1.default.plugins.register(exports.jsepCurlyHook);
    const parsedFormula = (0, jsep_1.default)(formula);
    await substituteId(parsedFormula);
    return jsepTreeToFormula(parsedFormula);
}
var FormulaErrorType;
(function (FormulaErrorType) {
    FormulaErrorType["NOT_AVAILABLE"] = "NOT_AVAILABLE";
    FormulaErrorType["NOT_SUPPORTED"] = "NOT_SUPPORTED";
    FormulaErrorType["MIN_ARG"] = "MIN_ARG";
    FormulaErrorType["MAX_ARG"] = "MAX_ARG";
    FormulaErrorType["TYPE_MISMATCH"] = "TYPE_MISMATCH";
    FormulaErrorType["INVALID_ARG"] = "INVALID_ARG";
    FormulaErrorType["INVALID_ARG_TYPE"] = "INVALID_ARG_TYPE";
    FormulaErrorType["INVALID_ARG_VALUE"] = "INVALID_ARG_VALUE";
    FormulaErrorType["INVALID_ARG_COUNT"] = "INVALID_ARG_COUNT";
    FormulaErrorType["CIRCULAR_REFERENCE"] = "CIRCULAR_REFERENCE";
    FormulaErrorType["INVALID_FUNCTION_NAME"] = "INVALID_FUNCTION_NAME";
    FormulaErrorType["INVALID_COLUMN"] = "INVALID_COLUMN";
})(FormulaErrorType || (exports.FormulaErrorType = FormulaErrorType = {}));
function substituteColumnIdWithAliasInFormula(formula, columns, rawFormula) {
    const substituteId = (pt, ptRaw) => {
        var _a;
        if (pt.type === 'CallExpression') {
            let i = 0;
            for (const arg of pt.arguments || []) {
                substituteId(arg, (_a = ptRaw === null || ptRaw === void 0 ? void 0 : ptRaw.arguments) === null || _a === void 0 ? void 0 : _a[i++]);
            }
        }
        else if (pt.type === 'Literal') {
            return;
        }
        else if (pt.type === 'Identifier') {
            const colNameOrId = pt === null || pt === void 0 ? void 0 : pt.name;
            const column = columns.find((c) => c.id === colNameOrId ||
                c.column_name === colNameOrId ||
                c.title === colNameOrId);
            pt.name = (column === null || column === void 0 ? void 0 : column.title) || (ptRaw === null || ptRaw === void 0 ? void 0 : ptRaw.name) || (pt === null || pt === void 0 ? void 0 : pt.name);
        }
        else if (pt.type === 'BinaryExpression') {
            substituteId(pt.left, ptRaw === null || ptRaw === void 0 ? void 0 : ptRaw.left);
            substituteId(pt.right, ptRaw === null || ptRaw === void 0 ? void 0 : ptRaw.right);
        }
    };
    // register jsep curly hook
    jsep_1.default.plugins.register(exports.jsepCurlyHook);
    const parsedFormula = (0, jsep_1.default)(formula);
    const parsedRawFormula = rawFormula && (0, jsep_1.default)(rawFormula);
    substituteId(parsedFormula, parsedRawFormula);
    return jsepTreeToFormula(parsedFormula);
}
// isCallExpId - is the identifier part of a call expression
// in case of call expression, we don't want to wrap the identifier in curly brackets
function jsepTreeToFormula(node, isCallExpId = false) {
    if (node.type === 'BinaryExpression' || node.type === 'LogicalExpression') {
        return ('(' +
            jsepTreeToFormula(node.left) +
            ' ' +
            node.operator +
            ' ' +
            jsepTreeToFormula(node.right) +
            ')');
    }
    if (node.type === 'UnaryExpression') {
        return node.operator + jsepTreeToFormula(node.argument);
    }
    if (node.type === 'MemberExpression') {
        return (jsepTreeToFormula(node.object) +
            '[' +
            jsepTreeToFormula(node.property) +
            ']');
    }
    if (node.type === 'Identifier') {
        if (!isCallExpId)
            return '{' + node.name + '}';
        return node.name;
    }
    if (node.type === 'Literal') {
        if (typeof node.value === 'string') {
            return String.raw `"${escapeLiteral(node.raw.slice(1, -1))}"`;
        }
        return '' + node.value;
    }
    if (node.type === 'CallExpression') {
        return (jsepTreeToFormula(node.callee, true) +
            '(' +
            node.arguments.map((argPt) => jsepTreeToFormula(argPt)).join(', ') +
            ')');
    }
    if (node.type === 'ArrayExpression') {
        return ('[' +
            node.elements.map((elePt) => jsepTreeToFormula(elePt)).join(', ') +
            ']');
    }
    if (node.type === 'Compound') {
        return node.body.map((e) => jsepTreeToFormula(e)).join(' ');
    }
    if (node.type === 'ConditionalExpression') {
        return (jsepTreeToFormula(node.test) +
            ' ? ' +
            jsepTreeToFormula(node.consequent) +
            ' : ' +
            jsepTreeToFormula(node.alternate));
    }
    return '';
}
function escapeLiteral(v) {
    return (v
        // replace \ to \\, escape only unescaped \
        .replace(/([^\\]|^)\\(?!\\)/g, `$1\\\\`)
        // replace " to \"
        .replace(/([^\\]|^)"/g, `$1\\"`)
        // replace ' to \'
        .replace(/([^\\]|^)'/g, `$1\\'`));
}
var FormulaDataTypes;
(function (FormulaDataTypes) {
    FormulaDataTypes["NUMERIC"] = "numeric";
    FormulaDataTypes["STRING"] = "string";
    FormulaDataTypes["DATE"] = "date";
    FormulaDataTypes["LOGICAL"] = "logical";
    FormulaDataTypes["ARRAY"] = "array";
    FormulaDataTypes["COND_EXP"] = "conditional_expression";
    FormulaDataTypes["NULL"] = "null";
    FormulaDataTypes["BOOLEAN"] = "boolean";
    FormulaDataTypes["INTERVAL"] = "interval";
    FormulaDataTypes["UNKNOWN"] = "unknown";
})(FormulaDataTypes || (exports.FormulaDataTypes = FormulaDataTypes = {}));
var JSEPNode;
(function (JSEPNode) {
    JSEPNode["COMPOUND"] = "Compound";
    JSEPNode["IDENTIFIER"] = "Identifier";
    JSEPNode["MEMBER_EXP"] = "MemberExpression";
    JSEPNode["LITERAL"] = "Literal";
    JSEPNode["THIS_EXP"] = "ThisExpression";
    JSEPNode["CALL_EXP"] = "CallExpression";
    JSEPNode["UNARY_EXP"] = "UnaryExpression";
    JSEPNode["BINARY_EXP"] = "BinaryExpression";
    JSEPNode["ARRAY_EXP"] = "ArrayExpression";
})(JSEPNode || (exports.JSEPNode = JSEPNode = {}));
exports.formulas = {
    AVG: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#avg',
        validation: {
            args: {
                min: 1,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Average of input parameters',
        syntax: 'AVG(value1, [value2, ...])',
        examples: [
            'AVG(10, 5) => 7.5',
            'AVG({column1}, {column2})',
            'AVG({column1}, {column2}, {column3})',
        ],
        returnType: FormulaDataTypes.NUMERIC,
    },
    ADD: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#add',
        validation: {
            args: {
                min: 1,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Sum of input parameters',
        syntax: 'ADD(value1, [value2, ...])',
        examples: [
            'ADD(5, 5) => 10',
            'ADD({column1}, {column2})',
            'ADD({column1}, {column2}, {column3})',
        ],
        returnType: FormulaDataTypes.NUMERIC,
    },
    DATEADD: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/date-functions#dateadd',
        validation: {
            args: {
                rqd: 3,
                type: FormulaDataTypes.DATE,
            },
            custom: (_argTypes, parsedTree) => {
                if (parsedTree.arguments[0].type === JSEPNode.LITERAL) {
                    if (!validateDateWithUnknownFormat(parsedTree.arguments[0].value)) {
                        throw new FormulaError(FormulaErrorType.TYPE_MISMATCH, { key: 'msg.formula.firstParamDateAddHaveDate' }, 'First parameter of DATEADD should be a date');
                    }
                }
                if (parsedTree.arguments[1].type === JSEPNode.LITERAL) {
                    if (typeof parsedTree.arguments[1].value !== 'number') {
                        throw new FormulaError(FormulaErrorType.TYPE_MISMATCH, { key: 'msg.formula.secondParamDateAddHaveNumber' }, 'Second parameter of DATEADD should be a number');
                    }
                }
                if (parsedTree.arguments[2].type === JSEPNode.LITERAL) {
                    if (!['day', 'week', 'month', 'year'].includes(parsedTree.arguments[2].value)) {
                        throw new FormulaError(FormulaErrorType.TYPE_MISMATCH, { key: 'msg.formula.thirdParamDateAddHaveDate' }, "Third parameter of DATEADD should be one of 'day', 'week', 'month', 'year'");
                    }
                }
            },
        },
        description: 'Adds "count" units to Datetime.',
        syntax: 'DATEADD(date | datetime, count, ["day" | "week" | "month" | "year"])',
        examples: [
            'DATEADD({column1}, 2, "day")',
            'DATEADD({column1}, -2, "day")',
            'DATEADD({column1}, 2, "week")',
            'DATEADD({column1}, -2, "week")',
            'DATEADD({column1}, 2, "month")',
            'DATEADD({column1}, -2, "month")',
            'DATEADD({column1}, 2, "year")',
            'DATEADD({column1}, -2, "year")',
        ],
        returnType: FormulaDataTypes.DATE,
    },
    DATESTR: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/date-functions#datestr',
        validation: {
            args: {
                rqd: 1,
            },
        },
        syntax: 'DATESTR(date | datetime)',
        description: 'Formats input field into a string in "YYYY-MM-DD" format',
        examples: ['DATESTR({column1})'],
        returnType: FormulaDataTypes.STRING,
    },
    DAY: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/date-functions#day',
        validation: {
            args: {
                rqd: 1,
            },
        },
        syntax: 'DAY(date | datetime)',
        description: 'Extract day from a date field (1-31)',
        examples: ['DAY({column1})'],
        returnType: FormulaDataTypes.STRING,
    },
    MONTH: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/date-functions#month',
        validation: {
            args: {
                rqd: 1,
            },
        },
        syntax: 'MONTH(date | datetime)',
        description: 'Extract month from a date field (1-12)',
        examples: ['MONTH({column1})'],
        returnType: FormulaDataTypes.STRING,
    },
    YEAR: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/date-functions#year',
        validation: {
            args: {
                rqd: 1,
            },
        },
        syntax: 'YEAR(date | datetime)',
        description: 'Extract year from a date field',
        examples: ['YEAR({column1})'],
        returnType: FormulaDataTypes.STRING,
    },
    HOUR: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/date-functions#hour',
        validation: {
            args: {
                rqd: 1,
            },
        },
        syntax: 'DAY(time | datetime)',
        description: 'Extract hour from a time field (0-23)',
        examples: ['HOUR({column1})'],
        returnType: FormulaDataTypes.STRING,
    },
    DATETIME_DIFF: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/date-functions#datetime_diff',
        validation: {
            args: {
                min: 2,
                max: 3,
                type: FormulaDataTypes.DATE,
            },
            custom: (_argTypes, parsedTree) => {
                if (parsedTree.arguments[0].type === JSEPNode.LITERAL) {
                    if (!validateDateWithUnknownFormat(parsedTree.arguments[0].value)) {
                        throw new FormulaError(FormulaErrorType.TYPE_MISMATCH, { key: 'msg.formula.firstParamDateDiffHaveDate' }, 'First parameter of DATETIME_DIFF should be a date');
                    }
                }
                if (parsedTree.arguments[1].type === JSEPNode.LITERAL) {
                    if (!validateDateWithUnknownFormat(parsedTree.arguments[1].value)) {
                        throw new FormulaError(FormulaErrorType.TYPE_MISMATCH, { key: 'msg.formula.secondParamDateDiffHaveDate' }, 'Second parameter of DATETIME_DIFF should be a date');
                    }
                }
                if (parsedTree.arguments[2] &&
                    parsedTree.arguments[2].type === JSEPNode.LITERAL) {
                    if (![
                        'milliseconds',
                        'ms',
                        'seconds',
                        's',
                        'minutes',
                        'm',
                        'hours',
                        'h',
                        'days',
                        'd',
                        'weeks',
                        'w',
                        'months',
                        'M',
                        'quarters',
                        'Q',
                        'years',
                        'y',
                    ].includes(parsedTree.arguments[2].value)) {
                        throw new FormulaError(FormulaErrorType.TYPE_MISMATCH, { key: 'msg.formula.thirdParamDateDiffHaveDate' }, "Third parameter of DATETIME_DIFF should be one of 'milliseconds', 'ms', 'seconds', 's', 'minutes', 'm', 'hours', 'h', 'days', 'd', 'weeks', 'w', 'months', 'M', 'quarters', 'Q', 'years', 'y'");
                    }
                }
            },
        },
        description: 'Calculate the difference of two given date / datetime fields in specified units.',
        syntax: 'DATETIME_DIFF(date | datetime, date | datetime, ["milliseconds" | "ms" | "seconds" | "s" | "minutes" | "m" | "hours" | "h" | "days" | "d" | "weeks" | "w" | "months" | "M" | "quarters" | "Q" | "years" | "y"])',
        examples: [
            'DATEDIFF({column1}, {column2})',
            'DATEDIFF({column1}, {column2}, "seconds")',
            'DATEDIFF({column1}, {column2}, "s")',
            'DATEDIFF({column1}, {column2}, "years")',
            'DATEDIFF({column1}, {column2}, "y")',
            'DATEDIFF({column1}, {column2}, "minutes")',
            'DATEDIFF({column1}, {column2}, "m")',
            'DATEDIFF({column1}, {column2}, "days")',
            'DATEDIFF({column1}, {column2}, "d")',
        ],
        returnType: FormulaDataTypes.NUMERIC,
    },
    AND: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/conditional-expressions#and',
        validation: {
            args: {
                min: 1,
            },
        },
        description: 'Result is TRUE if all conditions are met',
        syntax: 'AND(expr1, [expr2, ...])',
        examples: ['AND(5 > 2, 5 < 10) => 1', 'AND({column1} > 2, {column2} < 10)'],
        returnType: FormulaDataTypes.COND_EXP,
    },
    OR: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/conditional-expressions#or',
        validation: {
            args: {
                min: 1,
            },
        },
        description: 'Result is TRUE if at least one condition is met',
        syntax: 'OR(expr1, [expr2, ...])',
        examples: ['OR(5 > 2, 5 < 10) => 1', 'OR({column1} > 2, {column2} < 10)'],
        returnType: FormulaDataTypes.COND_EXP,
    },
    CONCAT: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#concat',
        validation: {
            args: {
                min: 1,
            },
        },
        description: 'Concatenate input parameters into a single string',
        syntax: 'CONCAT(str1, [str2, ...])',
        examples: [
            'CONCAT("AA", "BB", "CC") => "AABBCC"',
            'CONCAT({column1}, {column2}, {column3})',
        ],
        returnType: FormulaDataTypes.STRING,
    },
    TRIM: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#trim',
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.STRING,
            },
        },
        description: 'Remove trailing and leading whitespaces from input parameter',
        syntax: 'TRIM(str)',
        examples: [
            'TRIM("         HELLO WORLD  ") => "HELLO WORLD"',
            'TRIM({column1})',
        ],
        returnType: FormulaDataTypes.STRING,
    },
    UPPER: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#upper',
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.STRING,
            },
        },
        description: 'Converts the input parameter to an upper-case string.',
        syntax: 'UPPER(str)',
        examples: ['UPPER("nocodb") => "NOCODB"', 'UPPER({column1})'],
        returnType: FormulaDataTypes.STRING,
    },
    LOWER: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#lower',
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.STRING,
            },
        },
        description: 'Converts the input parameter to an lower-case string.',
        syntax: 'LOWER(str)',
        examples: ['LOWER("NOCODB") => "nocodb"', 'LOWER({column1})'],
        returnType: FormulaDataTypes.STRING,
    },
    LEN: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#len',
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.STRING,
            },
        },
        description: 'Calculate the character length of the input parameter.',
        syntax: 'LEN(value)',
        examples: ['LEN("NocoDB") => 6', 'LEN({column1})'],
        returnType: FormulaDataTypes.NUMERIC,
    },
    MIN: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#min',
        validation: {
            args: {
                min: 1,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Find the minimum value among the input parameters.',
        syntax: 'MIN(value1, [value2, ...])',
        examples: ['MIN(1000, 2000) => 1000', 'MIN({column1}, {column2})'],
        returnType: FormulaDataTypes.NUMERIC,
    },
    MAX: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#max',
        validation: {
            args: {
                min: 1,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Find the maximum value among the input parameters.',
        syntax: 'MAX(value1, [value2, ...])',
        examples: ['MAX(1000, 2000) => 2000', 'MAX({column1}, {column2})'],
        returnType: FormulaDataTypes.NUMERIC,
    },
    CEILING: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#ceiling',
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Rounds the input parameter to the next largest integer value.',
        syntax: 'CEILING(value)',
        examples: ['CEILING(1.01) => 2', 'CEILING({column1})'],
        returnType: FormulaDataTypes.NUMERIC,
    },
    FLOOR: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#floor',
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Round down the input parameter to the nearest integer.',
        syntax: 'FLOOR(value)',
        examples: ['FLOOR(3.1415) => 3', 'FLOOR({column1})'],
        returnType: FormulaDataTypes.NUMERIC,
    },
    ROUND: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#round',
        validation: {
            args: {
                min: 1,
                max: 2,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Rounds the number to a specified decimal places or the nearest integer if precision is not specified',
        syntax: 'ROUND(value, precision), ROUND(value)',
        examples: [
            'ROUND(3.1415) => 3',
            'ROUND(3.1415, 2) => 3.14',
            'ROUND({column1}, 3)',
        ],
        returnType: FormulaDataTypes.NUMERIC,
    },
    MOD: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#mod',
        validation: {
            args: {
                rqd: 2,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Calculate the remainder resulting from integer division of input parameters.',
        syntax: 'MOD(value1, value2)',
        examples: ['MOD(1024, 1000) => 24', 'MOD({column}, 2)'],
        returnType: FormulaDataTypes.NUMERIC,
    },
    REPEAT: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#repeat',
        validation: {
            args: {
                rqd: 2,
            },
            custom(argTypes, parsedTree) {
                var _a, _b;
                if (argTypes[1] !== FormulaDataTypes.NUMERIC) {
                    throw new FormulaError(FormulaErrorType.INVALID_ARG, {
                        key: 'msg.formula.typeIsExpected',
                        type: 'Numeric',
                        calleeName: (_b = (_a = parsedTree.callee) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.toUpperCase(),
                        position: 2,
                    }, 'The REPEAT function requires a numeric as the parameter at position 2');
                }
            },
        },
        description: 'Concatenate the specified number of copies of the input parameter string.',
        syntax: 'REPEAT(str, count)',
        examples: ['REPEAT("A", 5) => "AAAAA"', 'REPEAT({column}, 5)'],
        returnType: FormulaDataTypes.STRING,
    },
    LOG: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#log',
        validation: {
            args: {
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Compute the logarithm of the input parameter to the specified base (default = e).',
        syntax: 'LOG([base], value)',
        examples: ['LOG(2, 1024) => 10', 'LOG(2, {column1})'],
        returnType: FormulaDataTypes.NUMERIC,
    },
    EXP: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#exp',
        validation: {
            args: {
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Compute the exponential value of the input parameter (e raised to the power specified)',
        syntax: 'EXP(power)',
        examples: ['EXP(1) => 2.718281828459045', 'EXP({column1})'],
        returnType: FormulaDataTypes.NUMERIC,
    },
    POWER: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#power',
        validation: {
            args: {
                rqd: 2,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Compute base raised to the exponent power.',
        syntax: 'POWER(base, exponent)',
        examples: ['POWER(2, 10) => 1024', 'POWER({column1}, 10)'],
        returnType: FormulaDataTypes.NUMERIC,
    },
    SQRT: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#sqrt',
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Calculate the square root of the input parameter.',
        syntax: 'SQRT(value)',
        examples: ['SQRT(100) => 10', 'SQRT({column1})'],
        returnType: FormulaDataTypes.NUMERIC,
    },
    ABS: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#abs',
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Obtain the absolute value of the input parameter.',
        syntax: 'ABS(value)',
        examples: ['ABS({column1})'],
        returnType: FormulaDataTypes.NUMERIC,
    },
    NOW: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/date-functions#now',
        validation: {
            args: {
                rqd: 0,
                type: FormulaDataTypes.DATE,
            },
        },
        description: 'Retrieve the current time and day.',
        syntax: 'NOW()',
        examples: ['NOW() => 2022-05-19 17:20:43'],
        returnType: FormulaDataTypes.DATE,
    },
    REPLACE: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#replace',
        validation: {
            args: {
                rqd: 3,
                type: FormulaDataTypes.STRING,
            },
        },
        description: 'Replace all occurrences of "searchStr" with "replaceStr" in the given string.',
        syntax: 'REPLACE(str, searchStr, replaceStr)',
        examples: [
            'REPLACE("AABBCC", "AA", "BB") => "BBBBCC"',
            'REPLACE({column1}, {column2}, {column3})',
        ],
        returnType: FormulaDataTypes.STRING,
    },
    SEARCH: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#search',
        validation: {
            args: {
                rqd: 2,
                type: FormulaDataTypes.STRING,
            },
        },
        description: 'Retrieve the index of the specified "searchStr" if found; otherwise, returns 0.',
        syntax: 'SEARCH(str, searchStr)',
        examples: [
            'SEARCH("HELLO WORLD", "WORLD") => 7',
            'SEARCH({column1}, "abc")',
        ],
        returnType: FormulaDataTypes.NUMERIC,
    },
    INT: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#int',
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Obtain the integer value of the input parameter',
        syntax: 'INT(value)',
        examples: ['INT(3.1415) => 3', 'INT({column1})'],
        returnType: FormulaDataTypes.NUMERIC,
    },
    RIGHT: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#right',
        validation: {
            args: {
                rqd: 2,
                type: [FormulaDataTypes.STRING, FormulaDataTypes.NUMERIC],
            },
        },
        description: 'Retrieve the last n characters from the input string.',
        syntax: 'RIGHT(str, n)',
        examples: ['RIGHT("HELLO WORLD", 5) => WORLD', 'RIGHT({column1}, 3)'],
        returnType: FormulaDataTypes.STRING,
    },
    LEFT: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#left',
        validation: {
            args: {
                rqd: 2,
                type: [FormulaDataTypes.STRING, FormulaDataTypes.NUMERIC],
            },
        },
        description: 'Retrieve the first n characters from the input string.',
        syntax: 'LEFT(str, n)',
        examples: ['LEFT({column1}, 2)', 'LEFT("ABCD", 2) => "AB"'],
        returnType: FormulaDataTypes.STRING,
    },
    SUBSTR: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#substr',
        validation: {
            args: {
                min: 2,
                max: 3,
                type: [
                    FormulaDataTypes.STRING,
                    FormulaDataTypes.NUMERIC,
                    FormulaDataTypes.NUMERIC,
                ],
            },
        },
        description: 'Extracts a substring of length "n" from the input string, starting from the specified position.',
        syntax: '	SUBTR(str, position, [n])',
        examples: [
            'SUBSTR("HELLO WORLD", 7) => WORLD',
            'SUBSTR("HELLO WORLD", 7, 3) => WOR',
            'SUBSTR({column1}, 7, 5)',
        ],
        returnType: FormulaDataTypes.STRING,
    },
    MID: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#mid',
        validation: {
            args: {
                rqd: 3,
                type: [
                    FormulaDataTypes.STRING,
                    FormulaDataTypes.NUMERIC,
                    FormulaDataTypes.NUMERIC,
                ],
            },
        },
        description: 'Extracts a substring; an alias for SUBSTR.',
        syntax: 'MID(str, position, [count])',
        examples: ['MID("NocoDB", 3, 2) => "co"', 'MID({column1}, 3, 2)'],
        returnType: FormulaDataTypes.STRING,
    },
    ISBLANK: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#isblank',
        validation: {
            args: {
                rqd: 1,
            },
        },
        description: 'Check if the input parameter is blank.',
        syntax: 'ISBLANK(value)',
        examples: ['ISBLANK({column1}) => false', 'ISBLANK("") => true'],
        returnType: FormulaDataTypes.BOOLEAN,
    },
    ISNOTBLANK: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#isnotblank',
        validation: {
            args: {
                rqd: 1,
            },
        },
        description: 'Check if the input parameter is not blank.',
        syntax: 'ISNOTBLANK(value)',
        examples: ['ISNOTBLANK({column1}) => true', 'ISNOTBLANK("") => false'],
        returnType: FormulaDataTypes.BOOLEAN,
    },
    IF: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/conditional-expressions#if',
        validation: {
            args: {
                min: 2,
                max: 3,
            },
        },
        description: 'Evaluate successCase if the expression is TRUE, else the failureCase.',
        syntax: 'IF(expr, successCase, failureCase)',
        examples: [
            'IF(5 > 1, "YES", "NO") => "YES"',
            'IF({column} > 1, "YES", "NO")',
        ],
        returnType: (argTypes) => {
            // extract all return types except NULL, since null can be returned by any type
            const returnValueTypes = new Set(argTypes.slice(1).filter((type) => type !== FormulaDataTypes.NULL));
            // if there are more than one return types or if there is a string return type
            // return type as string else return the type
            if (returnValueTypes.size > 1 ||
                returnValueTypes.has(FormulaDataTypes.STRING)) {
                return FormulaDataTypes.STRING;
            }
            else if (returnValueTypes.has(FormulaDataTypes.NUMERIC)) {
                return FormulaDataTypes.NUMERIC;
            }
            else if (returnValueTypes.has(FormulaDataTypes.BOOLEAN)) {
                return FormulaDataTypes.BOOLEAN;
            }
            else if (returnValueTypes.has(FormulaDataTypes.DATE)) {
                return FormulaDataTypes.DATE;
            }
            // if none of the above conditions are met, return the first return argument type
            return argTypes[1];
        },
    },
    SWITCH: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/conditional-expressions#switch',
        validation: {
            args: {
                min: 3,
            },
            custom: (_argTypes, _parseTree) => {
                // Todo: Add validation for switch
            },
        },
        description: 'Evaluate case value based on expression output; if no match is found, evaluate default case.',
        syntax: 'SWITCH(expr, [pattern, value, ..., default])',
        examples: [
            'SWITCH(1, 1, "One", 2, "Two", "N/A") => "One""',
            'SWITCH(2, 1, "One", 2, "Two", "N/A") => "Two"',
            'SWITCH(3, 1, "One", 2, "Two", "N/A") => "N/A"',
            'SWITCH({column1}, 1, "One", 2, "Two", "N/A")',
        ],
        returnType: (argTypes) => {
            // extract all return types except NULL, since null can be returned by any type
            const returnValueTypes = new Set(argTypes.slice(2).filter((_, i) => i % 2 === 0));
            // if there are more than one return types or if there is a string return type
            // return type as string else return the type
            if (returnValueTypes.size > 1 ||
                returnValueTypes.has(FormulaDataTypes.STRING)) {
                return FormulaDataTypes.STRING;
            }
            else if (returnValueTypes.has(FormulaDataTypes.NUMERIC)) {
                return FormulaDataTypes.NUMERIC;
            }
            else if (returnValueTypes.has(FormulaDataTypes.BOOLEAN)) {
                return FormulaDataTypes.BOOLEAN;
            }
            else if (returnValueTypes.has(FormulaDataTypes.DATE)) {
                return FormulaDataTypes.DATE;
            }
            // if none of the above conditions are met, return the first return argument type
            return argTypes[1];
        },
    },
    URL: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#url',
        validation: {
            args: {
                min: 1,
                max: 2,
                type: [FormulaDataTypes.STRING, FormulaDataTypes.STRING],
            },
        },
        description: 'Verify and convert to a hyperlink if the input is a valid URL.',
        syntax: 'URL(string, [label])',
        examples: [
            'URL("https://github.com/nocodb/nocodb")',
            'URL({column1})',
            'URL("https://github.com/nocodb/nocodb", "NocoDB")',
            'URL({column1}, {column1})',
        ],
        returnType: FormulaDataTypes.STRING,
    },
    URLENCODE: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#urlencode',
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.STRING,
            },
        },
        description: 'Percent-encode the input parameter for use in URLs',
        syntax: 'URLENCODE(str)',
        examples: [
            'URLENCODE("Hello, world") => "Hello%2C%20world"',
            'URLENCODE({column1})',
        ],
        returnType: FormulaDataTypes.STRING,
    },
    WEEKDAY: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/date-functions#weekday',
        validation: {
            args: {
                min: 1,
                max: 2,
                type: FormulaDataTypes.NUMERIC,
            },
            custom(_argTypes, parsedTree) {
                if (parsedTree.arguments[0].type === JSEPNode.LITERAL) {
                    if (!validateDateWithUnknownFormat(parsedTree.arguments[0].value)) {
                        throw new FormulaError(FormulaErrorType.TYPE_MISMATCH, { key: 'msg.formula.firstParamWeekDayHaveDate' }, 'First parameter of WEEKDAY should be a date');
                    }
                }
                // if second argument is present and literal then validate it
                if (parsedTree.arguments[1] &&
                    parsedTree.arguments[1].type === JSEPNode.LITERAL) {
                    const value = parsedTree.arguments[1].value;
                    if (typeof value !== 'string' ||
                        ![
                            'sunday',
                            'monday',
                            'tuesday',
                            'wednesday',
                            'thursday',
                            'friday',
                            'saturday',
                        ].includes(value.toLowerCase())) {
                        throw new FormulaError(FormulaErrorType.TYPE_MISMATCH, { key: 'msg.formula.secondParamWeekDayHaveDate' }, 'Second parameter of WEEKDAY should be day of week string');
                    }
                }
            },
        },
        description: 'Retrieve the day of the week as an integer (0-6), starting from Monday by default.',
        syntax: 'WEEKDAY(date, [startDayOfWeek])',
        examples: ['WEEKDAY("2021-06-09")', 'WEEKDAY(NOW(), "sunday")'],
        returnType: FormulaDataTypes.NUMERIC,
    },
    TRUE: {
        validation: {
            args: {
                max: 0,
            },
        },
        description: 'Returns 1',
        syntax: 'TRUE()',
        examples: ['TRUE()'],
        returnType: FormulaDataTypes.NUMERIC,
        // TODO: Add docs url
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/logical-functions#true',
    },
    FALSE: {
        validation: {
            args: {
                max: 0,
            },
        },
        description: 'Returns 0',
        syntax: 'FALSE()',
        examples: ['FALSE()'],
        returnType: FormulaDataTypes.NUMERIC,
        // TODO: Add docs url
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/logical-functions#false',
    },
    ARRAYUNIQUE: {
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.ARRAY,
            },
        },
        description: 'Return unique items from the given array',
        syntax: 'ARRAYUNIQUE(value)',
        examples: ['ARRAYUNIQUE({column})'],
        returnType: FormulaDataTypes.ARRAY,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/array-functions#arrayunique',
    },
    ARRAYSORT: {
        validation: {
            args: {
                min: 1,
                max: 2,
            },
        },
        description: 'Sort an array result',
        syntax: 'ARRAYSORT(value, [direction])',
        examples: ['ARRAYSORT({column}, "desc")'],
        returnType: FormulaDataTypes.ARRAY,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/array-functions#arraysort',
    },
    ARRAYCOMPACT: {
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.ARRAY,
            },
        },
        description: 'Removes empty strings and null values from the array',
        syntax: 'ARRAYCOMPACT(value)',
        examples: ['ARRAYCOMPACT({column})'],
        returnType: FormulaDataTypes.ARRAY,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/array-functions#arraycompact',
    },
    ARRAYSLICE: {
        validation: {
            args: {
                min: 2,
                max: 3,
            },
        },
        description: 'Removes empty strings and null values from the array',
        syntax: 'ARRAYSLICE(value, start, [end])',
        examples: ['ARRAYSLICE({column})'],
        returnType: FormulaDataTypes.ARRAY,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/array-functions#arrayslice',
    },
    REGEX_MATCH: {
        validation: {
            args: {
                rqd: 2,
                type: FormulaDataTypes.STRING,
            },
        },
        description: 'Verifies whether the input text matches a regular expression, returning 1 for a match and 0 otherwise.',
        syntax: 'REGEX_MATCH(string, regex)',
        examples: ['REGEX_MATCH({title}, "abc.*")'],
        returnType: FormulaDataTypes.NUMERIC,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#regex_match',
    },
    REGEX_EXTRACT: {
        validation: {
            args: {
                rqd: 2,
                type: FormulaDataTypes.STRING,
            },
        },
        description: 'Retrieve the first match of a regular expression in a string.',
        syntax: 'REGEX_EXTRACT(string, regex)',
        examples: ['REGEX_EXTRACT({title}, "abc.*")'],
        returnType: FormulaDataTypes.STRING,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#regex_extract',
    },
    REGEX_REPLACE: {
        validation: {
            args: {
                rqd: 3,
                type: FormulaDataTypes.STRING,
            },
        },
        description: 'Replace all occurrences of a regular expression in a string with a specified replacement string.',
        syntax: 'REGEX_MATCH(string, regex, replacement)',
        examples: ['REGEX_EXTRACT({title}, "abc.*", "abcd")'],
        returnType: FormulaDataTypes.STRING,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/string-functions#regex_replace',
    },
    BLANK: {
        validation: {
            args: {
                rqd: 0,
            },
        },
        description: 'Yields a null value.',
        syntax: 'BLANK()',
        examples: ['BLANK()'],
        returnType: FormulaDataTypes.NULL,
        // TODO: Add docs url
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/logical-functions#blank',
    },
    XOR: {
        validation: {
            args: {
                min: 1,
            },
            // todo: validation for boolean
        },
        description: 'Verifies whether an odd number of arguments are true, returning true if so, and false otherwise.',
        syntax: 'XOR(expression, [exp2, ...])',
        examples: ['XOR(TRUE(), FALSE(), TRUE())'],
        returnType: FormulaDataTypes.BOOLEAN,
        // TODO: Add docs url
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/logical-functions#xor',
    },
    EVEN: {
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Rounds up the specified value to the nearest even integer that is greater than or equal to the specified value',
        syntax: 'EVEN(value)',
        examples: ['EVEN({column})'],
        returnType: FormulaDataTypes.NUMERIC,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#even',
    },
    ODD: {
        validation: {
            args: {
                rqd: 1,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Rounds up the specified value to the nearest odd integer that is greater than or equal to the specified value',
        syntax: 'ODD(value)',
        examples: ['ODD({column})'],
        returnType: FormulaDataTypes.NUMERIC,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#odd',
    },
    RECORD_ID: {
        validation: {
            args: {
                rqd: 0,
            },
        },
        description: 'Retrieve the record ID of the current record.',
        syntax: 'RECORD_ID()',
        examples: ['RECORD_ID()'],
        // todo: resolve return type based on the args
        returnType: () => {
            return FormulaDataTypes.STRING;
        },
    },
    COUNTA: {
        validation: {
            args: {
                min: 1,
            },
        },
        description: 'Counts non-empty arguments',
        syntax: 'COUNTA(value1, [value2, ...])',
        examples: ['COUNTA({field1}, {field2})'],
        returnType: FormulaDataTypes.NUMERIC,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#counta',
    },
    COUNT: {
        validation: {
            args: {
                min: 1,
            },
        },
        description: 'Counts numerical arguments',
        syntax: 'COUNT(value1, [value2, ...])',
        examples: ['COUNT({field1}, {field2})'],
        returnType: FormulaDataTypes.NUMERIC,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#count',
    },
    COUNTALL: {
        validation: {
            args: {
                min: 1,
            },
        },
        description: 'Counts the number of arguments',
        syntax: 'COUNTALL(value1, [value2, ...])',
        examples: ['COUNTALL({field1}, {field2})'],
        returnType: FormulaDataTypes.NUMERIC,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#countall',
    },
    ROUNDDOWN: {
        validation: {
            args: {
                min: 1,
                max: 2,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Rounds down the value after the decimal point to the specified number of decimal places given by "precision" (default is 0).',
        syntax: 'ROUNDDOWN(value, [precision])',
        examples: ['ROUNDDOWN({field1})', 'ROUNDDOWN({field1}, 2)'],
        returnType: FormulaDataTypes.NUMERIC,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#rounddown',
    },
    ROUNDUP: {
        validation: {
            args: {
                min: 1,
                max: 2,
                type: FormulaDataTypes.NUMERIC,
            },
        },
        description: 'Rounds up the value after the decimal point to the specified number of decimal places given by "precision" (default is 0).',
        syntax: 'ROUNDUP(value, [precision])',
        examples: ['ROUNDUP({field1})', 'ROUNDUP({field1}, 2)'],
        returnType: FormulaDataTypes.NUMERIC,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#roundup',
    },
    VALUE: {
        validation: {
            args: {
                rqd: 1,
            },
        },
        description: 'Extracts the numeric value from a string, handling % or - appropriately, and returns the resulting numeric value.',
        syntax: 'VALUE(value)',
        examples: ['VALUE({field})', 'VALUE("abc10000%")', 'VALUE("$10000")'],
        returnType: FormulaDataTypes.NUMERIC,
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/numeric-functions#value',
    },
    JSON_EXTRACT: {
        docsUrl: 'https://docs.nocodb.com/fields/field-types/formula/json-functions#json_extract',
        validation: {
            args: {
                min: 2,
                max: 2,
                type: [FormulaDataTypes.STRING, FormulaDataTypes.STRING],
            },
        },
        description: 'Extracts a value from a JSON string using a jq-like syntax',
        syntax: 'JSON_EXTRACT(json_string, path)',
        examples: [
            'JSON_EXTRACT(\'{"a": {"b": "c"}}\', \'.a.b\') => "c"',
            "JSON_EXTRACT({json_column}, '.key')",
        ],
        returnType: FormulaDataTypes.STRING,
    },
    // Disabling these functions for now; these act as alias for CreatedAt & UpdatedAt fields;
    // Issue: Error noticed if CreatedAt & UpdatedAt fields are removed from the table after creating these formulas
    //
    // CREATED_TIME: {
    //   validation: {
    //     args: {
    //       rqd: 0,
    //     },
    //   },
    //   description: 'Returns the created time of the current record if it exists',
    //   syntax: 'CREATED_TIME()',
    //   examples: ['CREATED_TIME()'],
    // },
    // LAST_MODIFIED_TIME: {
    //   validation: {
    //     args: {
    //       rqd: 0,
    //     },
    //   },
    //   description: 'Returns the last modified time of the current record if it exists',
    //   syntax: ' LAST_MODIFIED_TIME()',
    //   examples: [' LAST_MODIFIED_TIME()'],
    // },
};
class FormulaError extends Error {
    constructor(type, extra, message = 'Formula Error') {
        super(message);
        this.type = type;
        this.extra = extra;
    }
}
exports.FormulaError = FormulaError;
async function extractColumnIdentifierType({ col, columns, getMeta, clientOrSqlUi, }) {
    const res = {};
    const sqlUI = typeof clientOrSqlUi === 'string'
        ? sqlUi_1.SqlUiFactory.create({ client: clientOrSqlUi })
        : clientOrSqlUi;
    switch (col === null || col === void 0 ? void 0 : col.uidt) {
        // string
        case UITypes_1.default.SingleLineText:
        case UITypes_1.default.LongText:
        case UITypes_1.default.MultiSelect:
        case UITypes_1.default.SingleSelect:
        case UITypes_1.default.PhoneNumber:
        case UITypes_1.default.Email:
        case UITypes_1.default.URL:
        case UITypes_1.default.User:
        case UITypes_1.default.CreatedBy:
        case UITypes_1.default.LastModifiedBy:
            res.dataType = FormulaDataTypes.STRING;
            break;
        // numeric
        case UITypes_1.default.Year:
        case UITypes_1.default.Number:
        case UITypes_1.default.Decimal:
        case UITypes_1.default.Rating:
        case UITypes_1.default.Count:
        case UITypes_1.default.AutoNumber:
            res.dataType = FormulaDataTypes.NUMERIC;
            break;
        // date
        case UITypes_1.default.Date:
        case UITypes_1.default.DateTime:
        case UITypes_1.default.CreatedTime:
        case UITypes_1.default.LastModifiedTime:
            res.dataType = FormulaDataTypes.DATE;
            break;
        case UITypes_1.default.Currency:
        case UITypes_1.default.Percent:
        case UITypes_1.default.Duration:
        case UITypes_1.default.Links:
            res.dataType = FormulaDataTypes.NUMERIC;
            break;
        case UITypes_1.default.Rollup:
            {
                const rollupFunction = col.colOptions.rollup_function;
                if ([
                    'count',
                    'avg',
                    'sum',
                    'countDistinct',
                    'sumDistinct',
                    'avgDistinct',
                ].includes(rollupFunction)) {
                    // these functions produce a numeric value, which can be used in numeric functions
                    res.dataType = FormulaDataTypes.NUMERIC;
                }
                else {
                    const relationColumnOpt = columns.find((column) => column.id === col.colOptions.fk_relation_column_id);
                    // the value is based on the foreign rollup column type
                    const refTableMeta = await getMeta(relationColumnOpt.colOptions
                        .fk_related_model_id);
                    const refTableColumns = refTableMeta.columns;
                    const childFieldColumn = refTableColumns.find((column) => column.id === col.colOptions.fk_rollup_column_id);
                    // extract type and add to res
                    Object.assign(res, await extractColumnIdentifierType({
                        col: childFieldColumn,
                        columns: refTableColumns,
                        getMeta,
                        clientOrSqlUi,
                    }));
                }
            }
            break;
        case UITypes_1.default.Attachment:
            res.dataType = FormulaDataTypes.STRING;
            break;
        case UITypes_1.default.Checkbox:
            if (col.dt === 'boolean' || col.dt === 'bool') {
                res.dataType = FormulaDataTypes.BOOLEAN;
            }
            else {
                res.dataType = FormulaDataTypes.NUMERIC;
            }
            break;
        case UITypes_1.default.Time:
            res.dataType = FormulaDataTypes.INTERVAL;
            break;
        case UITypes_1.default.ID:
        case UITypes_1.default.ForeignKey:
        case UITypes_1.default.SpecificDBType:
            {
                if (sqlUI) {
                    const abstractType = sqlUI.getAbstractType(col);
                    if (['integer', 'float', 'decimal'].includes(abstractType)) {
                        res.dataType = FormulaDataTypes.NUMERIC;
                    }
                    else if (['boolean'].includes(abstractType)) {
                        res.dataType = FormulaDataTypes.BOOLEAN;
                    }
                    else if (['date', 'datetime', 'time', 'year'].includes(abstractType)) {
                        res.dataType = FormulaDataTypes.DATE;
                    }
                    else {
                        res.dataType = FormulaDataTypes.STRING;
                    }
                }
                else {
                    res.dataType = FormulaDataTypes.UNKNOWN;
                }
            }
            break;
        // not supported
        case UITypes_1.default.Lookup:
        case UITypes_1.default.LinkToAnotherRecord:
            res.dataType = FormulaDataTypes.ARRAY;
            break;
        case UITypes_1.default.Barcode:
        case UITypes_1.default.Button:
        case UITypes_1.default.Collaborator:
        case UITypes_1.default.QrCode:
        default:
            res.dataType = FormulaDataTypes.UNKNOWN;
            break;
    }
    return res;
}
async function validateFormulaAndExtractTreeWithType({ formula, column, columns, clientOrSqlUi, getMeta, }) {
    const sqlUI = typeof clientOrSqlUi === 'string'
        ? sqlUi_1.SqlUiFactory.create({ client: clientOrSqlUi })
        : clientOrSqlUi;
    const colAliasToColMap = {};
    const colIdToColMap = {};
    for (const col of columns) {
        colAliasToColMap[col.title] = col;
        colIdToColMap[col.id] = col;
    }
    const validateAndExtract = async (parsedTree) => {
        var _a, _b, _c, _d, _e, _f, _g;
        const res = Object.assign({}, parsedTree);
        if (parsedTree.type === JSEPNode.CALL_EXP) {
            const calleeName = parsedTree.callee.name.toUpperCase();
            // validate function name
            if (!exports.formulas[calleeName]) {
                throw new FormulaError(FormulaErrorType.INVALID_FUNCTION_NAME, {}, `Function ${calleeName} is not available`);
            }
            else if (sqlUI === null || sqlUI === void 0 ? void 0 : sqlUI.getUnsupportedFnList().includes(calleeName)) {
                throw new FormulaError(FormulaErrorType.INVALID_FUNCTION_NAME, {}, `Function ${calleeName} is unavailable for your database`);
            }
            // validate arguments
            const validation = exports.formulas[calleeName] && exports.formulas[calleeName].validation;
            if (validation && validation.args) {
                if (validation.args.rqd !== undefined &&
                    validation.args.rqd !== parsedTree.arguments.length) {
                    throw new FormulaError(FormulaErrorType.INVALID_ARG, {
                        key: 'msg.formula.requiredArgumentsFormula',
                        requiredArguments: validation.args.rqd,
                        calleeName,
                    }, 'Required arguments missing');
                }
                else if (validation.args.min !== undefined &&
                    validation.args.min > parsedTree.arguments.length) {
                    throw new FormulaError(FormulaErrorType.MIN_ARG, {
                        key: 'msg.formula.minRequiredArgumentsFormula',
                        minRequiredArguments: validation.args.min,
                        calleeName,
                    }, 'Minimum arguments required');
                }
                else if (validation.args.max !== undefined &&
                    validation.args.max < parsedTree.arguments.length) {
                    throw new FormulaError(FormulaErrorType.INVALID_ARG, {
                        key: 'msg.formula.maxRequiredArgumentsFormula',
                        maxRequiredArguments: validation.args.max,
                        calleeName,
                    }, 'Maximum arguments missing');
                }
            }
            // get args type and validate
            const validateResult = (res.arguments =
                await Promise.all(parsedTree.arguments.map((arg) => {
                    return validateAndExtract(arg);
                })));
            const argTypes = validateResult.map((v) => v.dataType);
            // if validation function is present, call it
            if ((_a = exports.formulas[calleeName].validation) === null || _a === void 0 ? void 0 : _a.custom) {
                (_b = exports.formulas[calleeName].validation) === null || _b === void 0 ? void 0 : _b.custom(argTypes, parsedTree);
            }
            // validate against expected arg types if present
            else if ((_d = (_c = exports.formulas[calleeName].validation) === null || _c === void 0 ? void 0 : _c.args) === null || _d === void 0 ? void 0 : _d.type) {
                for (let i = 0; i < validateResult.length; i++) {
                    const argPt = validateResult[i];
                    // if type
                    const expectedArgType = Array.isArray(exports.formulas[calleeName].validation.args.type)
                        ? exports.formulas[calleeName].validation.args.type[i]
                        : exports.formulas[calleeName].validation.args.type;
                    if (argPt.dataType !== expectedArgType &&
                        argPt.dataType !== FormulaDataTypes.NULL &&
                        argPt.dataType !== FormulaDataTypes.UNKNOWN &&
                        expectedArgType !== FormulaDataTypes.STRING) {
                        if (argPt.type === JSEPNode.IDENTIFIER) {
                            const name = ((_e = columns === null || columns === void 0 ? void 0 : columns.find((c) => c.id === argPt.name || c.title === argPt.name)) === null || _e === void 0 ? void 0 : _e.title) || argPt.name;
                            throw new FormulaError(FormulaErrorType.INVALID_ARG, {
                                key: 'msg.formula.columnWithTypeFoundButExpected',
                                columnName: name,
                                columnType: argPt.dataType,
                                expectedType: expectedArgType,
                            }, `Field ${name} with ${argPt.dataType} type is found but ${expectedArgType} type is expected`);
                        }
                        else {
                            let key = '';
                            const position = i + 1;
                            let type = '';
                            if (expectedArgType === FormulaDataTypes.NUMERIC) {
                                key = 'msg.formula.typeIsExpected';
                                type = 'numeric';
                            }
                            else if (expectedArgType === FormulaDataTypes.BOOLEAN) {
                                key = 'msg.formula.typeIsExpected';
                                type = 'boolean';
                            }
                            else if (expectedArgType === FormulaDataTypes.DATE) {
                                key = 'msg.formula.typeIsExpected';
                                type = 'date';
                            }
                            throw new FormulaError(FormulaErrorType.INVALID_ARG, {
                                type,
                                key,
                                position,
                                calleeName,
                            }, `${calleeName === null || calleeName === void 0 ? void 0 : calleeName.toUpperCase()} requires a ${type || expectedArgType} at position ${position}`);
                        }
                    }
                    // if expected type is string and arg type is not string, then cast it to string
                    if (expectedArgType === FormulaDataTypes.STRING &&
                        expectedArgType !== argPt.dataType) {
                        argPt.cast = FormulaDataTypes.STRING;
                    }
                }
            }
            if (typeof exports.formulas[calleeName].returnType === 'function') {
                res.dataType = (_g = (_f = exports.formulas[calleeName]).returnType) === null || _g === void 0 ? void 0 : _g.call(_f, argTypes);
            }
            else if (exports.formulas[calleeName].returnType) {
                res.dataType = exports.formulas[calleeName].returnType;
            }
        }
        else if (parsedTree.type === JSEPNode.IDENTIFIER) {
            const col = (colIdToColMap[parsedTree.name] ||
                colAliasToColMap[parsedTree.name]);
            if (!col) {
                throw new FormulaError(FormulaErrorType.INVALID_COLUMN, {
                    key: 'msg.formula.columnNotAvailable',
                    columnName: parsedTree.name,
                }, `Invalid column name/id ${JSON.stringify(parsedTree.name)} in formula`);
            }
            res.name = col.id;
            if ((col === null || col === void 0 ? void 0 : col.uidt) === UITypes_1.default.Formula) {
                if (column) {
                    // check for circular reference when column is present(only available when calling root formula)
                    await checkForCircularFormulaRef(column, parsedTree, columns, getMeta);
                }
                const formulaRes = col.colOptions.parsed_tree ||
                    (await validateFormulaAndExtractTreeWithType(
                    // formula may include double curly brackets in previous version
                    // convert to single curly bracket here for compatibility
                    {
                        formula: col.colOptions.formula
                            .replaceAll('{{', '{')
                            .replaceAll('}}', '}'),
                        columns,
                        clientOrSqlUi,
                        getMeta,
                    }));
                res.dataType = formulaRes === null || formulaRes === void 0 ? void 0 : formulaRes.dataType;
            }
            else {
                if ((col === null || col === void 0 ? void 0 : col.uidt) === UITypes_1.default.Lookup ||
                    (col === null || col === void 0 ? void 0 : col.uidt) === UITypes_1.default.LinkToAnotherRecord) {
                    // check for circular reference when column is present(only available when calling root formula)
                    if (column) {
                        await checkForCircularFormulaRef(column, parsedTree, columns, getMeta);
                    }
                }
                // extract type and add to res
                Object.assign(res, await extractColumnIdentifierType({
                    col,
                    columns,
                    getMeta,
                    clientOrSqlUi,
                }));
            }
        }
        else if (parsedTree.type === JSEPNode.LITERAL) {
            if (typeof parsedTree.value === 'number') {
                res.dataType = FormulaDataTypes.NUMERIC;
            }
            else if (typeof parsedTree.value === 'string') {
                res.dataType = FormulaDataTypes.STRING;
            }
            else if (typeof parsedTree.value === 'boolean') {
                res.dataType = FormulaDataTypes.BOOLEAN;
            }
            else {
                res.dataType = FormulaDataTypes.STRING;
            }
        }
        else if (parsedTree.type === JSEPNode.UNARY_EXP) {
            // only support -ve values
            if (['-'].includes(parsedTree.operator) &&
                parsedTree.argument.type === JSEPNode.LITERAL &&
                typeof parsedTree.argument.value === 'number') {
                res.dataType = FormulaDataTypes.NUMERIC;
            }
            else {
                throw new FormulaError(FormulaErrorType.NOT_SUPPORTED, {}, `Unary expression '${parsedTree.operator}' is not supported`);
            }
        }
        else if (parsedTree.type === JSEPNode.BINARY_EXP) {
            res.left = await validateAndExtract(parsedTree.left);
            res.right = await validateAndExtract(parsedTree.right);
            const dateAndTimeParsedNode = handleBinaryExpressionForDateAndTime({
                sourceBinaryNode: res,
            });
            if (dateAndTimeParsedNode) {
                Object.assign(res, handleBinaryExpressionForDateAndTime({ sourceBinaryNode: res }));
                if (res.type !== JSEPNode.BINARY_EXP) {
                    res.left = undefined;
                    res.right = undefined;
                    res.operator = undefined;
                }
            }
            else if (['==', '<', '>', '<=', '>=', '!='].includes(parsedTree.operator)) {
                res.dataType = FormulaDataTypes.COND_EXP;
            }
            else if (parsedTree.operator === '+') {
                res.dataType = FormulaDataTypes.NUMERIC;
                // if any side is string/date/other type, then the result will be concatenated string
                // e.g. 1 + '2' = '12'
                if ([
                    res.left,
                    res.right,
                ].some((r) => ![
                    FormulaDataTypes.NUMERIC,
                    FormulaDataTypes.BOOLEAN,
                    FormulaDataTypes.NULL,
                    FormulaDataTypes.UNKNOWN,
                ].includes(r.dataType))) {
                    res.dataType = FormulaDataTypes.STRING;
                }
            }
            else if (['&'].includes(parsedTree.operator)) {
                res.dataType = FormulaDataTypes.STRING;
            }
            else {
                res.dataType = FormulaDataTypes.NUMERIC;
            }
        }
        else if (parsedTree.type === JSEPNode.MEMBER_EXP) {
            throw new FormulaError(FormulaErrorType.NOT_SUPPORTED, {}, 'Bracket notation is not supported');
        }
        else if (parsedTree.type === JSEPNode.ARRAY_EXP) {
            throw new FormulaError(FormulaErrorType.NOT_SUPPORTED, {}, 'Array is not supported');
        }
        else if (parsedTree.type === JSEPNode.COMPOUND) {
            throw new FormulaError(FormulaErrorType.NOT_SUPPORTED, {}, 'Compound statement is not supported');
        }
        return res;
    };
    // register jsep curly hook
    jsep_1.default.plugins.register(exports.jsepCurlyHook);
    const parsedFormula = (0, jsep_1.default)(formula);
    // TODO: better jsep expression handling
    const result = await validateAndExtract(parsedFormula);
    return result;
}
function handleBinaryExpressionForDateAndTime(params) {
    const { sourceBinaryNode } = params;
    let res;
    if ([FormulaDataTypes.DATE, FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.left.dataType) &&
        [FormulaDataTypes.DATE, FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.right.dataType) &&
        sourceBinaryNode.operator === '-') {
        // when it's interval and interval, we return diff in minute (numeric)
        if ([FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.left.dataType) &&
            [FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.right.dataType)) {
            res = {
                type: JSEPNode.CALL_EXP,
                arguments: [
                    sourceBinaryNode.left,
                    sourceBinaryNode.right,
                    {
                        type: 'Literal',
                        value: 'minutes',
                        raw: '"minutes"',
                        dataType: 'string',
                    },
                ],
                callee: {
                    type: 'Identifier',
                    name: 'DATETIME_DIFF',
                },
                dataType: FormulaDataTypes.NUMERIC,
            };
        }
        // when it's date - date, show the difference in minute
        else if ([FormulaDataTypes.DATE].includes(sourceBinaryNode.left.dataType) &&
            [FormulaDataTypes.DATE].includes(sourceBinaryNode.right.dataType)) {
            res = {
                type: JSEPNode.CALL_EXP,
                arguments: [
                    sourceBinaryNode.left,
                    sourceBinaryNode.right,
                    {
                        type: 'Literal',
                        value: 'minutes',
                        raw: '"minutes"',
                        dataType: 'string',
                    },
                ],
                callee: {
                    type: 'Identifier',
                    name: 'DATETIME_DIFF',
                },
                dataType: FormulaDataTypes.NUMERIC,
            };
        }
        // else interval and date can be addedd seamlessly A - B
        // with result as DATE
        // may be changed if we find other db use case
        else if ([FormulaDataTypes.INTERVAL, FormulaDataTypes.DATE].includes(sourceBinaryNode.left.dataType) &&
            [FormulaDataTypes.INTERVAL, FormulaDataTypes.DATE].includes(sourceBinaryNode.right.dataType) &&
            sourceBinaryNode.left.dataType != sourceBinaryNode.right.dataType) {
            res = {
                type: JSEPNode.BINARY_EXP,
                left: sourceBinaryNode.left,
                right: sourceBinaryNode.right,
                operator: '-',
                dataType: FormulaDataTypes.DATE,
            };
        }
    }
    else if ([FormulaDataTypes.DATE, FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.left.dataType) &&
        [FormulaDataTypes.DATE, FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.right.dataType) &&
        sourceBinaryNode.operator === '+') {
        // when it's interval and interval, we return addition in minute (numeric)
        if ([FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.left.dataType) &&
            [FormulaDataTypes.INTERVAL].includes(sourceBinaryNode.right.dataType)) {
            const left = {
                type: JSEPNode.CALL_EXP,
                arguments: [
                    sourceBinaryNode.left,
                    {
                        type: 'Literal',
                        value: '00:00:00',
                        raw: '"00:00:00"',
                        dataType: FormulaDataTypes.INTERVAL,
                    },
                    {
                        type: 'Literal',
                        value: 'minutes',
                        raw: '"minutes"',
                        dataType: 'string',
                    },
                ],
                callee: {
                    type: 'Identifier',
                    name: 'DATETIME_DIFF',
                },
                dataType: FormulaDataTypes.NUMERIC,
            };
            const right = {
                type: JSEPNode.CALL_EXP,
                arguments: [
                    sourceBinaryNode.right,
                    {
                        type: 'Literal',
                        value: '00:00:00',
                        raw: '"00:00:00"',
                        dataType: FormulaDataTypes.INTERVAL,
                    },
                    {
                        type: 'Literal',
                        value: 'minutes',
                        raw: '"minutes"',
                        dataType: 'string',
                    },
                ],
                callee: {
                    type: 'Identifier',
                    name: 'DATETIME_DIFF',
                },
                dataType: FormulaDataTypes.NUMERIC,
            };
            return {
                type: JSEPNode.BINARY_EXP,
                left,
                right,
                operator: '+',
                dataType: FormulaDataTypes.NUMERIC,
            };
        }
        // else interval and date can be addedd seamlessly A + B
        // with result as DATE
        // may be changed if we find other db use case
        else if ([FormulaDataTypes.INTERVAL, FormulaDataTypes.DATE].includes(sourceBinaryNode.left.dataType) &&
            [FormulaDataTypes.INTERVAL, FormulaDataTypes.DATE].includes(sourceBinaryNode.right.dataType) &&
            sourceBinaryNode.left.dataType != sourceBinaryNode.right.dataType) {
            res = {
                type: JSEPNode.BINARY_EXP,
                left: sourceBinaryNode.left,
                right: sourceBinaryNode.right,
                operator: '+',
                dataType: FormulaDataTypes.DATE,
            };
        }
    }
    return res;
}
async function checkForCircularFormulaRef(formulaCol, parsedTree, columns, getMeta) {
    // Extract formula references
    const formulaPaths = await columns.reduce(async (promiseRes, c) => {
        const res = await promiseRes;
        if (c.id !== formulaCol.id && c.uidt === UITypes_1.default.Formula) {
            const neighbours = [
                ...new Set((c.colOptions.formula.match(/c_?\w{14,15}/g) || []).filter((colId) => columns.some((col) => col.id === colId && col.uidt === UITypes_1.default.Formula))),
            ];
            if (neighbours.length)
                res.push({ [c.id]: neighbours });
        }
        else if (c.uidt === UITypes_1.default.Lookup ||
            c.uidt === UITypes_1.default.LinkToAnotherRecord) {
            const neighbours = await processLookupOrLTARColumn(c);
            if (neighbours === null || neighbours === void 0 ? void 0 : neighbours.length)
                res.push({ [c.id]: neighbours });
        }
        return res;
    }, Promise.resolve([]));
    async function processLookupFormula(col, columns) {
        const neighbours = [];
        if (formulaCol.fk_model_id === col.fk_model_id) {
            return [col.id];
        }
        // Extract columns used in the formula and check for cycles
        const referencedColumns = col.colOptions.formula.match(/c_?\w{14,15}/g) || [];
        for (const refColId of referencedColumns) {
            const refCol = columns.find((c) => c.id === refColId);
            if (refCol.uidt === UITypes_1.default.Formula) {
                neighbours.push(...(await processLookupFormula(refCol, columns)));
            }
            else if (refCol.uidt === UITypes_1.default.Lookup ||
                refCol.uidt === UITypes_1.default.LinkToAnotherRecord) {
                neighbours.push(...(await processLookupOrLTARColumn(refCol)));
            }
        }
        return neighbours;
    }
    // Function to process lookup columns recursively
    async function processLookupOrLTARColumn(lookupOrLTARCol) {
        const neighbours = [];
        let ltarColumn;
        let lookupFilterFn;
        if (lookupOrLTARCol.uidt === UITypes_1.default.Lookup) {
            const relationColId = lookupOrLTARCol.colOptions
                .fk_relation_column_id;
            const lookupColId = lookupOrLTARCol.colOptions
                .fk_lookup_column_id;
            ltarColumn = columns.find((c) => c.id === relationColId);
            lookupFilterFn = (column) => column.id === lookupColId;
        }
        else if (lookupOrLTARCol.uidt === UITypes_1.default.LinkToAnotherRecord) {
            ltarColumn = lookupOrLTARCol;
            lookupFilterFn = (column) => !!column.pv;
        }
        if (ltarColumn) {
            const relatedTableMeta = await getMeta(ltarColumn.colOptions.fk_related_model_id);
            const lookupTarget = relatedTableMeta.columns.find(lookupFilterFn);
            if (lookupTarget) {
                if (lookupTarget.uidt === UITypes_1.default.Formula) {
                    neighbours.push(...(await processLookupFormula(lookupTarget, relatedTableMeta.columns)));
                }
                else if (lookupTarget.uidt === UITypes_1.default.Lookup ||
                    lookupTarget.uidt === UITypes_1.default.LinkToAnotherRecord) {
                    neighbours.push(...(await processLookupOrLTARColumn(lookupTarget)));
                }
            }
        }
        return [...new Set(neighbours)];
    }
    // include target formula column (i.e. the one to be saved if applicable)
    const targetFormulaCol = columns.find((c) => c.title === parsedTree.name &&
        [UITypes_1.default.Formula, UITypes_1.default.LinkToAnotherRecord, UITypes_1.default.Lookup].includes(c.uidt));
    if (targetFormulaCol && (formulaCol === null || formulaCol === void 0 ? void 0 : formulaCol.id)) {
        formulaPaths.push({
            [formulaCol === null || formulaCol === void 0 ? void 0 : formulaCol.id]: [targetFormulaCol.id],
        });
    }
    const vertices = formulaPaths.length;
    if (vertices > 0) {
        // perform kahn's algo for cycle detection
        const adj = new Map();
        const inDegrees = new Map();
        // init adjacency list & indegree
        for (const [_, v] of Object.entries(formulaPaths)) {
            const src = Object.keys(v)[0];
            const neighbours = v[src];
            inDegrees.set(src, inDegrees.get(src) || 0);
            for (const neighbour of neighbours) {
                adj.set(src, (adj.get(src) || new Set()).add(neighbour));
                inDegrees.set(neighbour, (inDegrees.get(neighbour) || 0) + 1);
            }
        }
        const queue = [];
        // put all vertices with in-degree = 0 (i.e. no incoming edges) to queue
        inDegrees.forEach((inDegree, col) => {
            if (inDegree === 0) {
                // in-degree = 0 means we start traversing from this node
                queue.push(col);
            }
        });
        // init count of visited vertices
        let visited = 0;
        // BFS
        while (queue.length !== 0) {
            // remove a vertex from the queue
            const src = queue.shift();
            // if this node has neighbours, increase visited by 1
            const neighbours = adj.get(src) || new Set();
            if (neighbours.size > 0) {
                visited += 1;
            }
            // iterate each neighbouring nodes
            neighbours.forEach((neighbour) => {
                // decrease in-degree of its neighbours by 1
                inDegrees.set(neighbour, inDegrees.get(neighbour) - 1);
                // if in-degree becomes 0
                if (inDegrees.get(neighbour) === 0) {
                    // then put the neighboring node to the queue
                    queue.push(neighbour);
                }
            });
        }
        // vertices not same as visited = cycle found
        if (vertices !== visited) {
            throw new FormulaError(FormulaErrorType.CIRCULAR_REFERENCE, {
                key: 'msg.formula.cantSaveCircularReference',
            }, 'Circular reference detected');
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybXVsYUhlbHBlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL2Zvcm11bGFIZWxwZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQXNLQSxvRkE4QkM7QUFpQkQsb0ZBa0NDO0FBSUQsOENBc0VDO0FBcThDRCxzRkFtWEM7QUF6bkVELGdEQUF3QjtBQVV4Qix3REFBZ0M7QUFDaEMsa0RBQTBCO0FBQzFCLG1DQUF1QztBQUN2QyxxREFBK0M7QUFjbEMsUUFBQSxlQUFlLEdBQUcsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFVLENBQUM7QUFDdkMsUUFBQSxtQkFBbUIsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBVSxDQUFDO0FBQ3BELFFBQUEsbUJBQW1CLEdBQUc7SUFDakMsSUFBSTtJQUNKLEdBQUc7SUFDSCxHQUFHO0lBQ0gsR0FBRztJQUNILElBQUk7SUFDSixJQUFJO0lBQ0osSUFBSTtDQUNJLENBQUM7QUFtRVgsa0NBQWtDO0FBQ2xDLE1BQU0sV0FBVyxHQUFHLEdBQUcsQ0FBQyxDQUFDLE1BQU07QUFDL0IsTUFBTSxXQUFXLEdBQUcsR0FBRyxDQUFDLENBQUMsTUFBTTtBQUVsQixRQUFBLGFBQWEsR0FBRztJQUMzQixJQUFJLEVBQUUsT0FBTztJQUNiLElBQUksQ0FBQyxJQUFJO1FBQ1AsbURBQW1EO1FBQ25ELElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLGNBQWMsRUFBRSxTQUFTLGlCQUFpQixDQUFDLEdBQUc7WUFDM0QseURBQXlEO1lBQ3pELElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxXQUFXLEVBQUUsQ0FBQztnQkFDOUIsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztnQkFDaEMsbUVBQW1FO2dCQUNuRSxPQUFPLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztv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