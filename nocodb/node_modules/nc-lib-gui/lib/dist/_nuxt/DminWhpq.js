import{aj as f,kz as Ot,cm as K,r as G,f as Bt,a9 as Ft,u as Nt,as as Lt,W as Ut,U as jt,V as $t,a8 as Gt,S as Wt,J as Jt,gj as Qt,n as W,fp as qt,b7 as Ht,s as Pt,jk as Ye,jl as Ke,i as zt,fS as ke,jm as Xt,a4 as X,hf as Zt,gK as Yt,iE as Kt,a5 as te,il as kt,gW as Vt,gU as bt,aC as eo,he as to,hd as oo,fG as Ve,fF as ro,h2 as no,g1 as so,bW as ao}from"./DOFFjK0_.js";import{e as J,v as be,r as Ie,c as io,p as uo}from"./D2QgEzTv.js";import{u as co}from"./DG2ZEhLK.js";import{a as lo}from"./Dh5zKH8k.js";import{b as wo}from"./C1uRXLg7.js";import{g as fo}from"./D-8_fbld.js";const po=($,m)=>{const w=m?[{text:"Count (9 → 1)",value:"count-desc"},{text:"Count (1 → 9)",value:"count-asc"}]:[];switch($){case f.Year:case f.Number:case f.Decimal:case f.Rating:case f.Count:case f.AutoNumber:case f.Time:case f.Currency:case f.Percent:case f.Duration:case f.PhoneNumber:case f.Date:case f.DateTime:case f.CreatedTime:case f.LastModifiedTime:return[{text:"1 → 9",value:"asc"},{text:"9 → 1",value:"desc"}].concat(w);case f.Checkbox:return[{text:"▢ → ✓",value:"asc"},{text:"✓ → ▢",value:"desc"}].concat(w);default:return[{text:"A → Z",value:"asc"},{text:"Z → A",value:"desc"}].concat(w)}},Te=({uidt:$,a:m,b:w,options:{caseSensitive:T=!0,direction:t}})=>{let U=t!=="asc";if([f.Formula,f.User].includes($)&&(U=!U),m==null)return U?1:-1;if(w==null)return U?-1:1;if(m===""&&w!=="")return U?1:-1;if(w===""&&m!=="")return U?-1:1;let x=0;switch($){case f.Number:case f.Decimal:case f.Currency:case f.Percent:case f.Rating:case f.Duration:case f.ID:case f.Rollup:x=Number(m)-Number(w);break;case f.Links:{const S=E=>E===null?null:typeof E=="number"?E:E&&typeof E=="object"?Object.values(E)[0]:E,_=S(m),F=S(w);typeof _=="number"&&typeof F=="number"?x=_-F:x=String(_).localeCompare(String(F));break}case f.DateTime:case f.CreatedTime:case f.LastModifiedTime:x=K(m).valueOf()-K(w).valueOf();break;case f.Time:{const S=E=>{if(K.isDayjs(E))return K(`1999-01-01 ${E.format("HH:mm:ss")}`);if(typeof E=="string"&&/^\d{2}:\d{2}:\d{2}$/.test(E))return K(`1999-01-01 ${E}`);if(typeof E=="string"&&/^\d{2}:\d{2}$/.test(E))return K(`1999-01-01 ${E}:00`);let k=K(E);return k.isValid()||(k=K(E,"HH:mm:ss")),k.isValid()||(k=K(`1999-01-01 ${E}`)),k},_=S(m),F=S(w);x=_.valueOf()-F.valueOf();break}case f.Year:x=Number(m)-Number(w);break;case f.Checkbox:x=m===w?0:m?-1:1;break;case f.SingleSelect:case f.MultiSelect:x=String(m).localeCompare(String(w));break;case f.Attachment:{const S=_=>Array.isArray(_)&&_.length>0&&(_[0].title||_[0].path)||"";x=S(m).localeCompare(S(w));break}case f.User:case f.CreatedBy:case f.LastModifiedBy:{const S=_=>Array.isArray(_)&&_.length>0?_[0].display_name||_[0].email||"":_&&typeof _=="object"?_.display_name||_.email||"":String(_);x=S(m).localeCompare(S(w));break}case f.SingleLineText:case f.LongText:case f.Email:case f.URL:case f.PhoneNumber:case f.Formula:T?x=String(m).localeCompare(String(w)):x=String(m).toLowerCase().localeCompare(String(w).toLowerCase());break;case f.JSON:x=JSON.stringify(m).localeCompare(JSON.stringify(w));break;default:x=String(m).localeCompare(String(w))}return t==="desc"?-x:x},ho=($,m,w)=>{const T=new Set(m.map(t=>{var U;return(U=w[t.fk_column_id])==null?void 0:U.title}).filter(Boolean));return $.some(t=>T.has(t))},So=($,m)=>{let w={};if(!$||!m||(Array.isArray(m)?w=m.reduce((U,x)=>(x.id&&(U[x.id]=x),U),{}):w=m,!w[$]))return"";const T=w[$];let t=T.uidt;return T.uidt===f.Formula&&(t=Ot({formulaColumn:T})||t),t||""},et=($,m,w,T=[],t)=>{if(m!=null&&m.page&&(m!=null&&m.pageSize))return $.map((x,S)=>{const _=(m.page-1)*m.pageSize+S;return{row:{...x},oldRow:{...x},rowMeta:{rowIndex:_,isLastRow:_===m.totalRows-1,path:T,...(t==null?void 0:t(x))??{}}}});const U=(w==null?void 0:w.offset)??0;return $.map((x,S)=>({row:{...x},oldRow:{...x},rowMeta:{rowIndex:U+S,path:T,...(t==null?void 0:t(x))??{}}}))};function Co($){const m="noco",{meta:w,viewMeta:T,callbacks:t,where:U,disableSmartsheet:x,isPublic:S,groupByColumns:_=G(null)}=$,{$api:F}=Bt(),{t:E}=Ft(),k=Nt(),{isUIAllowed:V}=Lt(),{addUndo:ue,clone:B,defineViewScope:ce}=Ut(),tt=jt(),_e=$t(),{base:O}=Gt(_e),{getBaseType:Ae}=_e,{getMeta:ot,metas:ye}=Wt(),{user:me}=Jt(),{fetchSharedViewData:rt,fetchCount:De,fetchBulkListData:nt}=Qt(),{nestedFilters:b,allFilters:Ee,sorts:z,isExternalSource:de,isAlreadyShownUpgradeModal:Oe,validFiltersFromUrlParams:st,totalRowsWithSearchQuery:at,totalRowsWithoutSearchQuery:Be,fetchTotalRowsWithSearchQuery:it,whereQueryFromUrl:Fe,eventBus:ut}=x?{nestedFilters:G([]),allFilters:G([]),sorts:G([]),isExternalSource:W(()=>!1),isAlreadyShownUpgradeModal:G(!1),totalRowsWithSearchQuery:G(0),totalRowsWithoutSearchQuery:G(0),fetchTotalRowsWithSearchQuery:W(()=>!1),whereQueryFromUrl:W(()=>""),eventBus:qt(Xt.SmartsheetStore)}:co(),{isGroupBy:ct}=x?{isGroupBy:W(()=>!1)}:lo(),{blockExternalSourceRecordVisibility:Me,showUpgradeToSeeMoreRecordsModal:dt}=Ht(),{getEvaluatedRowMetaRowColorInfo:oe}=x?{getEvaluatedRowMetaRowColorInfo:e=>({})}:wo(),lt=G(!1),Ne=G(0),Le=G(0),le=G(new Map),Ue=G([]),we=Pt(new Map),Z=W(()=>k.currentRoute.value.query),je=W(()=>{var e,r,o;return(r=(e=w.value)==null?void 0:e.columns)!=null&&r.length?(o=w.value)==null?void 0:o.columns.reduce((a,n)=>(a[n.title]=n,a),{}):{}}),ne=W(()=>{var e,r,o;return(r=(e=w.value)==null?void 0:e.columns)!=null&&r.length?(o=w.value)==null?void 0:o.columns.reduce((a,n)=>(a[n.id]=n,a),{}):{}}),wt=W(()=>{const{filters:e}=Ye({api_version:Ke.V1},(U==null?void 0:U.value)??"",je.value);return e!=null&&e.length?e==null?void 0:e.map(r=>{var o;return{...r,value:r.value?(o=r.value)==null?void 0:o.toString().replace(/(^%)(.*?)(%$)/,"$2"):r.value}}):[]}),$e=W(()=>Array.from(le.value.values()).filter(e=>{var r;return(r=e.rowMeta)==null?void 0:r.selected})),Ge=W(()=>Array.from(le.value.values()).filter(e=>{var r;return(r=e.rowMeta)==null?void 0:r.isRowOrderUpdated})),D=(e=[])=>{var s;if(e.length===0)return{cachedRows:le,chunkStates:Ue,totalRows:Ne,actualTotalRows:Le,isRowSortRequiredRows:Ge,selectedRows:$e};const r=e.join("-"),o=we.value.get(r);if(o)return o;const a=(s=t==null?void 0:t.getCount)==null?void 0:s.call(t,e),n={cachedRows:G(new Map),chunkStates:G([]),totalRows:W({get:()=>{var u;const c=(u=t==null?void 0:t.findGroupByPath)==null?void 0:u.call(t,e);return c?c.count:0},set:c=>{var i;const u=(i=t==null?void 0:t.findGroupByPath)==null?void 0:i.call(t,e);u&&(u.count=c)}}),actualTotalRows:G(0),selectedRows:W(()=>Array.from(n.cachedRows.value.values()).filter(c=>{var u;return(u=c.rowMeta)==null?void 0:u.selected})),isRowSortRequiredRows:W(()=>Array.from(n.cachedRows.value.values()).filter(c=>{var u;return(u=c.rowMeta)==null?void 0:u.isRowOrderUpdated}))};return a===null&&xe(e),we.value.set(r,n),n},ft=200,H=50,q=e=>Math.floor(e/H);let re=[],se=null;const ht=50,vt=200;async function Rt(e){var a;if(!V("commentCount")||S!=null&&S.value||e.length===0)return;const r=[],o=new Map;for(const{rows:n}of e)for(const s of n){const c=J(s.row,(a=w==null?void 0:w.value)==null?void 0:a.columns);c&&(r.push(c),o.set(c,s))}if(r.length!==0)try{const n=await F.utils.commentCount({ids:r,fk_model_id:w.value.id});n==null||n.forEach(s=>{const c=o.get(s.row_id);c&&(c.rowMeta.commentCount=+s.count||0)})}catch(n){console.error("Failed to load bulk aggregate comment count:",n)}}async function gt(e,r){const o=D(r);o.chunkStates.value[e]="loading";const a=e*H;try{const n=await Se({offset:a,limit:H},!1,r);if(!n){o.chunkStates.value[e]=void 0;return}n.forEach(s=>{o.cachedRows.value.set(s.rowMeta.rowIndex,s)}),o.chunkStates.value[e]="loaded"}catch(n){throw console.error("Error fetching chunk:",n),o.chunkStates.value[e]=void 0,n}}async function We(){var r,o;if(re.length===0)return;se&&(clearTimeout(se),se=null);const e=[...re];re=[];try{const a=[];for(let u=0;u<e.length;u++){const i=e[u],d=await((r=t==null?void 0:t.getWhereFilter)==null?void 0:r.call(t,i.path));a.push({where:d,offset:i.chunkId*H,limit:H,alias:`chunk_${i.chunkId}_${i.path.join("_")}`,...V("sortSync")?{}:{sortArrJson:JSON.stringify(z.value)},...V("filterSync")?{}:{filterArrJson:JSON.stringify(b.value)}})}const n=S!=null&&S.value?await nt({},a):await F.dbDataTableBulkList.dbDataTableBulkList(w.value.id,{viewId:(o=T.value)==null?void 0:o.id},a,{}),s=[],c=[];for(const u of e)try{const i=`chunk_${u.chunkId}_${u.path.join("_")}`,d=n[i],y=D(u.path);if(d&&d.list){const h=et(d.list,d.pageInfo,void 0,u.path,oe);h.forEach(R=>{y.cachedRows.value.set(R.rowMeta.rowIndex,R)}),y.chunkStates.value[u.chunkId]="loaded",s.push({rows:h,path:u.path}),c.push({request:u,rows:h,dataCache:y})}else y.chunkStates.value[u.chunkId]=void 0;u.resolve(void 0)}catch(i){console.error(`Error processing chunk ${u.chunkId}:`,i);const d=D(u.path);d.chunkStates.value[u.chunkId]=void 0,u.reject(i)}await Rt(s);for(const{request:u,rows:i,dataCache:d}of c)try{i.forEach(y=>{d.cachedRows.value.set(y.rowMeta.rowIndex,y)}),d.chunkStates.value[u.chunkId]="loaded",u.resolve(void 0)}catch(y){console.error(`Error caching chunk ${u.chunkId}:`,y),d.chunkStates.value[u.chunkId]=void 0,u.reject(y)}}catch(a){console.error("Bulk chunk request failed, falling back to individual requests:",a);const n=e.map(s=>gt(s.chunkId,s.path).then(()=>s.resolve(void 0)).catch(c=>s.reject(c)));await Promise.allSettled(n)}}const pe=async(e,r=[],o=!1)=>{const a=D(r);if(a.chunkStates.value[e]&&!o)return;const n=re.find(s=>s.chunkId===e&&s.path.join(",")===r.join(","));return n&&!o?new Promise((s,c)=>{const u=n.resolve,i=n.reject;n.resolve=d=>{u(d),s(d)},n.reject=d=>{i(d),c(d)}}):new Promise((s,c)=>{re.push({chunkId:e,path:r,forceFetch:o,resolve:s,reject:c}),a.chunkStates.value[e]="loading",re.length>=ht?We():se||(se=setTimeout(()=>{We()},vt))})},yt=(e,r,o=[])=>{var h,R,l;const a=D(o);if(r===Number.POSITIVE_INFINITY&&e===Number.NEGATIVE_INFINITY){a.cachedRows.value.clear(),a.chunkStates.value=[];return}if(a.cachedRows.value.size<=ft)return;const n=Math.max(0,e),s=Math.min(a.totalRows.value-1,r),c=q(n),u=q(s),i=new Set;let d=0;for(const v of a.cachedRows.value.keys()){const M=q(v);d=Math.max(d,M);const p=a.cachedRows.value.get(v);p&&((h=p.rowMeta)!=null&&h.selected||(R=p.rowMeta)!=null&&R.new||(l=p.rowMeta)!=null&&l.isDragging)&&i.add(M)}const y=new Map;for(let v=0;v<=d;v++)if(v>=c&&v<=u||i.has(v)){const p=v*H,g=p+H;for(let C=p;C<g;C++){const L=a.cachedRows.value.get(C);L&&y.set(C,L)}}a.cachedRows.value=y,a.chunkStates.value=a.chunkStates.value.map((v,M)=>M>=c&&M<=u||i.has(M)?v:void 0)};async function Je(e,r=[]){if(!V("commentCount")||S!=null&&S.value)return;const o=e.filter(({rowMeta:{new:n}})=>!n).map(({row:n})=>{var s;return J(n,(s=w==null?void 0:w.value)==null?void 0:s.columns)}).filter(Boolean);if(!o.length)return;const a=D(r);try{const n=await F.utils.commentCount({ids:o,fk_model_id:w.value.id});e.forEach(s=>{var d,y;const c=Array.from(a.cachedRows.value.values()).find(h=>h.rowMeta.rowIndex===s.rowMeta.rowIndex);if(!c)return;const u=J(s.row,(d=w.value)==null?void 0:d.columns),i=((y=n==null?void 0:n.find(h=>h.row_id===u))==null?void 0:y.count)||0;c.rowMeta.commentCount=+i})}catch(n){console.error("Failed to load aggregate comment count:",n)}}let ae;zt(()=>{clearTimeout(ae)});async function Se(e={},r,o=[]){var n,s,c,u,i,d,y;if((!((n=O==null?void 0:O.value)!=null&&n.id)||!((s=w.value)!=null&&s.id)||!((c=T.value)!=null&&c.id))&&!(S!=null&&S.value))return[];const a=await((u=t==null?void 0:t.getWhereFilter)==null?void 0:u.call(t,o));if(!x&&!o.length&&e.offset&&Me(de.value)&&(!Oe.value&&e.offset>=Yt&&(Oe.value=!0,ae&&clearTimeout(ae),ae=setTimeout(()=>{dt({isExternalSource:de.value}),clearTimeout(ae)},1e3)),e.offset>=Kt))return[];try{const h=S!=null&&S.value?await rt({sortsArr:z.value,filtersArr:b.value,where:a,offset:e.offset,limit:e.limit},{isInfiniteScroll:!0}):await F.dbViewRow.list("noco",O.value.id,w.value.id,T.value.id,{...e,...V("sortSync")?{}:{sortArrJson:JSON.stringify(z.value)},...V("filterSync")?{}:{filterArrJson:JSON.stringify(b.value)},includeSortAndFilterColumns:!0,where:a,include_row_color:!0}),R=et(h.list,h.pageInfo,e,o,oe);return Je(R,o),R}catch(h){return((i=h==null?void 0:h.response)==null?void 0:i.data.error)==="INVALID_OFFSET_VALUE"?[]:((y=(d=h==null?void 0:h.response)==null?void 0:d.data)==null?void 0:y.error)==="FORMULA_ERROR"?(await tt.reloadTableMeta(w.value.id),Se(e)):(console.error(h),X.error(await te(h)),[])}}const mt=async(e,r,o=!1,a=!1,n=[])=>{var g,C,L;const s=D(n),c=s.cachedRows.value.get(e);if(!c)return;const u=J(c.row,(g=w.value)==null?void 0:g.columns),i=new Map(s.cachedRows.value.entries()),d=s.cachedRows.value.get(e+1),y=d?J(d.row,(C=w.value)==null?void 0:C.columns):null;let h=null,R=null,l;if(r===null)l=s.cachedRows.value.size-1;else{if(l=r>e?r-1:r,h=s.cachedRows.value.get(r)??null,!h)return;R=J(h.row,(L=w.value)==null?void 0:L.columns)||null}if(l<e)for(let I=e-1;I>=l;I--){const A=i.get(I);if(A){const j=I+1;A.rowMeta.rowIndex=j,i.set(j,A)}}else for(let I=e+1;I<=l;I++){const A=i.get(I);if(A){const j=I-1;A.rowMeta.rowIndex=j,i.set(j,A)}}c.rowMeta.rowIndex=l,i.set(l,c);const v=new Set;for(const[I,A]of i){if(v.has(A.rowMeta.rowIndex)){console.error("Duplicate index detected:",I,A.rowMeta.rowIndex);break}v.add(A.rowMeta.rowIndex)}const M=q(l),p=q(e);a||F.dbDataTableRow.move(w.value.id,u,{before:r===null?null:R}).then(()=>{var I;(I=t==null?void 0:t.syncVisibleData)==null||I.call(t)}).catch(I=>{var A;(A=t==null?void 0:t.syncVisibleData)==null||A.call(t),X.error(`Failed to update record order: ${I}`)}),o||ue({undo:{fn:async(I,A,j,Y)=>{var Q;await F.dbDataTableRow.move(w.value.id,A,{before:I}),await((Q=t==null?void 0:t.syncVisibleData)==null?void 0:Q.call(t))},args:[y,u,M,p]},redo:{fn:async(I,A,j,Y)=>{var Q;await F.dbDataTableRow.move(w.value.id,A,{before:I}),await((Q=t==null?void 0:t.syncVisibleData)==null?void 0:Q.call(t))},args:[r===null?null:R,u,M,p]},scope:ce({view:T.value})}),s.cachedRows.value=i},Mt=async e=>{var u,i,d,y,h;const r=((i=(u=Z.value)==null?void 0:u.path)==null?void 0:i.length)===0?[]:(((y=(d=Z.value)==null?void 0:d.path)==null?void 0:y.split("-"))??[]).map(R=>+R),o=await At(r);if(o===-1)return;const a=D(r),n=o+(e===Zt.NEXT?1:-1);if(n<0||n>=a.totalRows.value)return X.info(E("msg.info.noMoreRecords"));let s=a.cachedRows.value.get(n);if(s||(await Xe(n,H,r),s=a.cachedRows.value.get(n)),!s)return;const c=J(s.row,(h=w.value)==null?void 0:h.columns);c&&await k.push({query:{...Z.value,rowId:c}})},pt=async(e,r,o=[])=>{const a=Math.floor(e/H),n=Math.floor(r/H),s=D(o),c=Array.from({length:n-a+1},(u,i)=>a+i).filter(u=>!s.chunkStates.value[u]);await Promise.all(c.map(pe,o))};function St(e=[],r){var u,i,d,y,h;const o=D(e),a=Array.from(o.cachedRows.value.entries()).sort(([R],[l])=>R-l),n=a.filter(([R,l])=>l.rowMeta.isValidationFailed||l.rowMeta.isGroupChanged).map(([R])=>R);if(n.length===0)return;for(const R of n){const l=o.cachedRows.value.get(R);if((u=l.rowMeta)!=null&&u.isGroupChanged){const v=_.value[l.rowMeta.changedGroupIndex],M=(i=v==null?void 0:v.column)==null?void 0:i.title;(d=r==null?void 0:r.onGroupRowChange)==null||d.call(r,{row:l,property:M,groupByColumn:v,level:l.rowMeta.changedGroupIndex,path:l.rowMeta.path})}o.cachedRows.value.delete(R)}const s=new Map;for(const[R,l]of a)if(!n.includes(R)){const v=R-n.filter(M=>M<R).length;l.rowMeta.rowIndex=v,s.set(v,l)}o.chunkStates.value[q(Math.max(...n))]=void 0;const c=new Set;for(const[R,l]of s){if(c.has(l.rowMeta.rowIndex)){console.error("Op: clearInvalidRows:  Duplicate index detected:",l.rowMeta.rowIndex);break}c.add(l.rowMeta.rowIndex)}o.cachedRows.value=s,o.totalRows.value=Math.max(0,(o.totalRows.value||0)-n.length),o.actualTotalRows.value=Math.max(0,(o.actualTotalRows.value||0)-n.length),(y=t==null?void 0:t.syncVisibleData)==null||y.call(t),(h=t==null?void 0:t.reloadAggregate)==null||h.call(t,{path:e})}const Qe=({row:e,newData:r,path:o})=>{if(!z.value.length)return!1;const a=e.rowMeta.rowIndex;if(a===void 0)return!0;const n=D(o),s=Array.from(n.cachedRows.value.keys()).sort((y,h)=>y-h),c=s.indexOf(a),u=c>0?n.cachedRows.value.get(s[c-1]):null,i=c<s.length-1?n.cachedRows.value.get(s[c+1]):null,d={...e,row:{...e.row,...r}};if(u){let y=!1,h=!1;for(const R of z.value){const l=ne.value[R.fk_column_id];if(!(l!=null&&l.title))continue;const v=R.direction||"asc",M=Te({uidt:l.uidt,a:d.row[l.title],b:u.row[l.title],options:{direction:v}});if(M!==0){h=!0,y=M<0;break}}if(h&&y)return!0}if(i){let y=!1,h=!1;for(const R of z.value){const l=ne.value[R.fk_column_id];if(!(l!=null&&l.title))continue;const v=R.direction||"asc",M=Te({uidt:l.uidt,a:d.row[l.title],b:i.row[l.title],options:{direction:v}});if(M!==0){h=!0,y=M>0;break}}if(h&&y)return!0}return!1},Ct=e=>{const r=Array.from(e.keys()).sort((s,c)=>s-c),o=[];let a=r[0],n=r[0];for(let s=1;s<=r.length;s++){const c=r[s];c!==n+1&&(o.push({start:a,end:n}),a=c),n=c}return o},qe=(e,r=[])=>{var c;if(!z.value.length)return;const o=D(r),a=z.value.sort((u,i)=>(u.order??0)-(i.order??0)),n=Array.isArray(e)?e:[e],s=Ct(o.cachedRows.value);n.forEach(u=>{const i=u.rowMeta.rowIndex,d=s.find(p=>i>=p.start&&i<=p.end);if(!d)return;const h=Array.from(o.cachedRows.value.entries()).filter(([p])=>p>=d.start&&p<=d.end).map(([p,g])=>{var C;return{currentIndex:p,row:g,pk:J(g.row,((C=w.value)==null?void 0:C.columns)??[])}}).sort((p,g)=>{var C;for(const L of a){const I=(C=ne.value[L.fk_column_id])==null?void 0:C.title;if(!I)continue;const A=L.direction||"asc",j=Te({uidt:ne.value[L.fk_column_id].uidt,a:p.row.row[I],b:g.row.row[I],options:{direction:A}});if(j!==0)return j}return p.currentIndex-g.currentIndex}),R=h.find(p=>{var g;return p.pk===J(u.row,((g=w.value)==null?void 0:g.columns)??[])});if(!R)return;const l=d.start+h.indexOf(R),v=new Map(o.cachedRows.value);if(l!==i){if(l<i)for(let g=i-1;g>=l;g--){const C=v.get(g);C&&(C.rowMeta.rowIndex=g+1,C.rowMeta.isRowOrderUpdated=!1,v.set(g+1,C))}else for(let g=i+1;g<=l;g++){const C=v.get(g);C&&(C.rowMeta.rowIndex=g-1,C.rowMeta.isRowOrderUpdated=!1,v.set(g-1,C))}u.rowMeta.rowIndex=l,u.rowMeta.isRowOrderUpdated=!1,v.set(l,u);const p=q(l);if(l<=d.start||l>=d.end){if(l<=d.start)for(let g=0;g<=p;g++)o.chunkStates.value[g]=void 0;else if(l>=d.end)for(let g=p;g<=q(o.totalRows.value-1);g++)o.chunkStates.value[g]=void 0}}else u.rowMeta.isRowOrderUpdated=!1;const M=new Set;for(const[p,g]of v){if(M.has(g.rowMeta.rowIndex)){console.error("Op: applySorting:  Duplicate index detected:",g.rowMeta.rowIndex);break}M.add(g.rowMeta.rowIndex)}o.cachedRows.value=v}),(c=t==null?void 0:t.syncVisibleData)==null||c.call(t)};function xt(e,r=w.value,o={},a=[]){var u;const n=D(a);if((Ve(e)||ro(e))&&(e=n.totalRows.value),n.cachedRows.value.has(e)){const i=Array.from(n.cachedRows.value.entries()).filter(([d])=>d>=e).sort((d,y)=>y[0]-d[0]);for(const[d,y]of i){const h={...y,rowMeta:{...y.rowMeta,rowIndex:d+1}};n.cachedRows.value.set(d+1,h)}}const s=fo([...Ee.value,...st.value],r==null?void 0:r.columns,{currentUser:me.value??void 0}),c={row:{...io(r==null?void 0:r.columns),...s,...o},oldRow:{},rowMeta:{new:!0,rowIndex:e,path:a}};return n.cachedRows.value.set(e,c),n.totalRows.value++,(u=t==null?void 0:t.syncVisibleData)==null||u.call(t),c}const He=async(e,r,o,a,{metaValue:n=w.value}={},s)=>{var c;try{await F.dbTableRow.nestedAdd(m,(n==null?void 0:n.base_id)??O.value.id,n==null?void 0:n.id,encodeURIComponent(e),a,o.title,encodeURIComponent(r))}catch(u){if(!(s!=null&&s.suppressError)){const i=await te(u);X.error(`Failed to link record: ${i}`)}throw u}(c=t==null?void 0:t.syncVisibleData)==null||c.call(t)},Pe=async(e,{metaValue:r=w.value}={},o)=>{var n,s;const a=J(e,r==null?void 0:r.columns);if(a){for(const c of(r==null?void 0:r.columns)??[]){if(c.uidt!==f.LinkToAnotherRecord)continue;const u=c.colOptions,i=(n=ye.value)==null?void 0:n[u==null?void 0:u.fk_related_model_id];if(kt(c)||Vt(c)){const d=e[c.title]??[];for(const y of d){const h=J(y,i==null?void 0:i.columns);h&&await He(a,h,c,u.type,{metaValue:i},o)}}else if(bt(c)&&e[c.title]){const d=J(e[c.title],i.columns);d&&await He(a,d,c,u.type,{metaValue:i},o)}}(s=t==null?void 0:t.syncVisibleData)==null||s.call(t)}};async function ze(e,r=!1,o=[]){var n,s,c,u,i;const a=D(o);try{const d=a.cachedRows.value.get(e);if(!d)return;if(!d.rowMeta.new){const R=(s=(n=w==null?void 0:w.value)==null?void 0:n.columns)==null?void 0:s.filter(M=>M.pk).map(M=>d.row[M.title]).join("___"),l=await F.dbTableRow.read(m,((c=w.value)==null?void 0:c.base_id)??(O==null?void 0:O.value.id),(u=w.value)==null?void 0:u.id,encodeURIComponent(R),{getHiddenColumn:!0});if(!await Ce(R,void 0,o))return;d.row=l,r||ue({undo:{fn:async(M,p,g)=>{var L;const C=Ie(M.row,(L=w==null?void 0:w.value)==null?void 0:L.columns);M.row={...C,...M.row},await fe(M,p,{},!0,void 0,void 0,g),a.cachedRows.value.clear(),a.chunkStates.value=[];try{await Pe(M.row,void 0,{suppressError:!0})}catch{}},args:[B(d),{},B(o)]},redo:{fn:async(M,p)=>{await ze(M,!1,p)},args:[e,B(o)]},scope:ce({view:T.value})})}a.cachedRows.value.delete(e);const h=Array.from(a.cachedRows.value.entries()).filter(([R])=>R>e);h.sort((R,l)=>R[0]-l[0]);for(const[R,l]of h){const v=R-1;l.rowMeta.rowIndex=v,a.cachedRows.value.delete(R),a.cachedRows.value.set(v,l)}h.length&&(a.chunkStates.value[q(h[h.length-1][0])]=void 0),a.totalRows.value=(a.totalRows.value||0)-1,a.actualTotalRows.value=Math.max(0,(a.actualTotalRows.value||0)-1),await xe(o),(i=t==null?void 0:t.syncVisibleData)==null||i.call(t)}catch(d){console.error(d),X.error(`${E("msg.error.deleteRowFailed")}: ${await te(d)}`)}}async function fe(e,r={},{metaValue:o=w.value,viewMetaValue:a=T.value}={},n=!1,s=!1,c,u=[]){var d,y;if(!e.rowMeta)throw new Error("Row metadata is missing");const i=D(u);e.rowMeta.saving=!0;try{const{missingRequiredColumns:h,insertObj:R}=await uo({meta:o,ltarState:r,getMeta:ot,row:e.row,undo:n});if(h.size)return R;const l=await F.dbViewRow.create(m,(o==null?void 0:o.base_id)??(O==null?void 0:O.value.id),o==null?void 0:o.id,a==null?void 0:a.id,{...R,...r||{}},{before:c,undo:n});e.rowMeta.new=!1,Object.assign(e.row,{...e.row??{},...Ie(l,o==null?void 0:o.columns)});const v=e.rowMeta.rowIndex;if(!n){Object.assign(e.oldRow,l);const M=J(l,o.columns),p=Ie(l,o==null?void 0:o.columns);ue({undo:{fn:async(g,C,L,I,A,j)=>{var Y;i.cachedRows.value=new Map(C),i.totalRows.value=L,i.actualTotalRows.value=j,i.chunkStates.value=I,await Ce(g,void 0,A),i.cachedRows.value.delete(v);for(const[Q,ee]of i.cachedRows.value)Q>v&&(ee.rowMeta.rowIndex=Q-1,i.cachedRows.value.set(Q-1,ee));i.totalRows.value=i.totalRows.value-1,i.actualTotalRows.value=Math.max(0,(i.actualTotalRows.value||0)-1),(Y=t==null?void 0:t.syncVisibleData)==null||Y.call(t)},args:[M,B(new Map(i.cachedRows.value)),B(i.totalRows.value),B(i.chunkStates.value),B(u),B(i.actualTotalRows.value)]},redo:{fn:async(g,C,L,I,A,j,Y,Q)=>{var N;i.cachedRows.value=new Map(L),i.totalRows.value=I,i.actualTotalRows.value=Q,i.chunkStates.value=A,g.row={...p,...g.row};const ee=await fe(g,C,void 0,!0,!0,j),ie=Qe({row:g,newData:ee,path:Y});if(ie){const P=i.cachedRows.value.get(g.rowMeta.rowIndex);P&&(P.rowMeta.isRowOrderUpdated=ie)}(N=t==null?void 0:t.syncVisibleData)==null||N.call(t)},args:[B(e),B(r),B(new Map(i.cachedRows.value)),B(i.totalRows.value),B(i.chunkStates.value),B(c),B(u),B(i.actualTotalRows.value)]},scope:ce({view:T.value})})}if(i.cachedRows.value.has(v)&&!s){const p=Array.from(i.cachedRows.value.entries()).filter(([g])=>g>=v);p.sort((g,C)=>C[0]-g[0]);for(const[g,C]of p)C.rowMeta.rowIndex=g+1,i.cachedRows.value.set(g+1,C)}return i.cachedRows.value.set(v,{row:{...l,...e.row},oldRow:{...l},rowMeta:{...e.rowMeta,rowIndex:v,new:!1,saving:!1,...oe({...l,...e.row})}}),s||i.totalRows.value++,(d=t==null?void 0:t.reloadAggregate)==null||d.call(t,{path:u}),(y=t==null?void 0:t.syncVisibleData)==null||y.call(t),l}catch(h){const R=await te(h);throw X.error(`Failed to insert row: ${R}`),h}finally{e.rowMeta.saving=!1}}async function he(e,r,{metaValue:o=w.value,viewMetaValue:a=T.value}={},n=!1,s=[]){var u,i,d;if(!e.rowMeta)throw new Error("Row metadata is missing");const c=D(s);e.rowMeta.saving=!0;try{const y=J(e.row,o==null?void 0:o.columns),h=await F.dbViewRow.update(m,(o==null?void 0:o.base_id)??(O==null?void 0:O.value.id),o==null?void 0:o.id,a==null?void 0:a.id,encodeURIComponent(y),{[r]:e.row[r]??null});n||ue({undo:{fn:async(l,v,M,p,g,C)=>{c.cachedRows.value=new Map(M),c.totalRows.value=p,c.actualTotalRows.value=C,await he({row:l.oldRow,oldRow:l.row,rowMeta:l.rowMeta},v,void 0,!0,g)},args:[B(e),r,B(new Map(c.cachedRows.value)),B(c.totalRows.value),B(s),B(c.actualTotalRows.value)]},redo:{fn:async(l,v,M)=>{await he(l,v,void 0,!0,M)},args:[B(e),r,B(s)]},scope:ce({view:T.value})});const R=new Set([f.Formula,f.QrCode,f.Barcode,f.Rollup,f.Checkbox,f.User,f.LastModifiedTime,f.LastModifiedBy,f.Lookup,f.Button,f.Attachment,f.DateTime,f.Date]);return Object.assign(e.row,(u=o==null?void 0:o.columns)==null?void 0:u.reduce((l,v)=>(v.title&&v.title in h&&(R.has(v.uidt)||no(v)||v.au||so(v==null?void 0:v.cdf)&&/ on update /i.test(v.cdf))&&(l[v.title]=h[v.title]),l),{})),Object.assign(e.oldRow,h),Object.assign(e.rowMeta,oe(e.row)),e.rowMeta.rowIndex!==void 0&&c.cachedRows.value.set(e.rowMeta.rowIndex,e),(i=t==null?void 0:t.reloadAggregate)==null||i.call(t,{fields:[{title:r}],path:s}),(d=t==null?void 0:t.syncVisibleData)==null||d.call(t),n&&qe(e,s),h}catch(y){e.row[r]=e.oldRow[r];const h=await te(y);throw X.error(`${E("msg.error.rowUpdateFailed")}: ${h}`),y}finally{e.rowMeta.saving=!1}}async function It(e,r,o,a={},n,s=[]){var l,v,M,p,g,C,L,I,A,j,Y,Q,ee,ie;if(!e.rowMeta)throw new Error("Row metadata is missing");const c=D(s);e.rowMeta.changed=!1;let u;await new Promise(N=>{const P=()=>{var Re,ge;u=c.cachedRows.value.get(e.rowMeta.rowIndex),!((Re=u==null?void 0:u.rowMeta)!=null&&Re.saving)||!((ge=u==null?void 0:u.rowMeta)!=null&&ge.new)?N(!0):setTimeout(P,100)};P()});let i;const d=(v=(l=w.value)==null?void 0:l.columns)==null?void 0:v.filter(N=>eo(N)||to(N)||oo(N)||[f.Formula,f.QrCode,f.Barcode,f.Rollup,f.Checkbox,f.User,f.Lookup,f.Button,f.Attachment].includes(N.uidt));e.rowMeta.new?i=await fe(e,o,a,!1,!0,n,s):r&&(u&&(d==null||d.reduce((N,P)=>(Ve(u.row[P.title])||(N[P.title]=u.row[P.title]),N),e.row)),i=await he(e,r,a,!1,s));const y=!be([...Ee.value,...wt.value],i,(M=w.value)==null?void 0:M.columns,Ae((g=(p=T.value)==null?void 0:p.view)==null?void 0:g.source_id),ye.value,{currentUser:me.value}),h=c.cachedRows.value.get(e.rowMeta.rowIndex);if(h&&(h.rowMeta.isValidationFailed=y),(L=(C=e.rowMeta)==null?void 0:C.path)!=null&&L.length&&(_!=null&&_.value)){const N=await((A=t==null?void 0:t.getWhereFilter)==null?void 0:A.call(t,(I=e.rowMeta)==null?void 0:I.path,!0)),P=_.value.findIndex(ge=>ge.column.title===r)??0,{filters:Ze}=Ye({api_version:Ke.V1},N??"",je.value),Re=!be([...Ze??[]],i,(j=w.value)==null?void 0:j.columns,Ae((Q=(Y=T.value)==null?void 0:Y.view)==null?void 0:Q.source_id),ye.value,{currentUser:me.value});e.rowMeta.isGroupChanged=Re,e.rowMeta.changedGroupIndex=P}const R=r?[r]:Object.keys(e.row);if(R.push(...((ee=w.value)==null?void 0:ee.columns.filter(N=>[f.LastModifiedBy,f.LastModifiedTime,f.Formula,f.Lookup,f.Rollup,f.LinkToAnotherRecord].includes(N.uidt)).map(N=>N.title))||[]),ho(R,z.value,ne.value)||h){const N=Qe({row:e,newData:i,sorts:z.value,path:s});h&&(h.rowMeta.isRowOrderUpdated=N)}(ie=t==null?void 0:t.syncVisibleData)==null||ie.call(t)}async function Tt(e,{metaValue:r=w.value,viewMetaValue:o=T.value}={},a=[]){var n,s;if(!o)throw new Error("View meta value is missing");await F.dbTableRow.bulkUpdateAll(m,r==null?void 0:r.base_id,r==null?void 0:r.id,e,{viewId:o.id}),(n=t==null?void 0:t.reloadAggregate)==null||n.call(t,{path:a}),(s=t==null?void 0:t.syncVisibleData)==null||s.call(t)}async function Ce(e,{metaValue:r=w.value,viewMetaValue:o=T.value}={},a=[]){var n;if(!e)throw new Error("Delete not allowed for table which doesn't have primary Key");try{const s=await F.dbViewRow.delete("noco",(r==null?void 0:r.base_id)??O.value.id,r==null?void 0:r.id,o==null?void 0:o.id,encodeURIComponent(e));if((n=t==null?void 0:t.reloadAggregate)==null||n.call(t,{path:a}),s.message){const c=`Unable to delete record with ID ${e} because of the following:
${s.message.join(`
`)}.
Clear the data first & try again`;return X.info(`Record delete failed: ${c}`),!1}return!0}catch(s){const c=await te(s);return X.error(`${E("msg.error.deleteRowFailed")}: ${c}`),!1}}const _t=(e,r=[])=>{var n,s,c;r=((n=e==null?void 0:e.rowMeta)==null?void 0:n.path)??[];const o=D(r),a=(s=Array.from(o.cachedRows.value.entries()).find(([u,i])=>i.rowMeta.rowIndex===e.rowMeta.rowIndex))==null?void 0:s[0];return a!==void 0&&e.rowMeta.new?(o.cachedRows.value.delete(a),o.totalRows.value--,!0):((c=t==null?void 0:t.syncVisibleData)==null||c.call(t),!1)};async function xe(e=[]){var a,n,s,c,u,i,d,y,h;if(!(S!=null&&S.value)&&(!((a=O==null?void 0:O.value)!=null&&a.id)||!((n=w.value)!=null&&n.id)||!((s=T.value)!=null&&s.id)))return;const r=D(e),o=await((c=t==null?void 0:t.getWhereFilter)==null?void 0:c.call(t,e));try{const{count:R}=S!=null&&S.value?await De({filtersArr:b.value,where:o}):await F.dbViewRow.count(m,(u=O==null?void 0:O.value)==null?void 0:u.id,w.value.id,(i=T==null?void 0:T.value)==null?void 0:i.id,{where:o,...V("filterSync")?{}:{filterArrJson:JSON.stringify(b.value)}});if(it.value){const{count:l}=S!=null&&S.value?await De({filtersArr:b.value,where:Fe.value}):await F.dbViewRow.count(m,(d=O==null?void 0:O.value)==null?void 0:d.id,w.value.id,(y=T==null?void 0:T.value)==null?void 0:y.id,{where:Fe.value,...V("filterSync")?{}:{filterArrJson:JSON.stringify(b.value)}});!x&&!e.length&&Me(de.value)?Be.value=Math.max(Math.min(200,l),l):Be.value=l}!x&&!e.length&&Me(de.value)?r.totalRows.value=Math.min(200,R):r.totalRows.value=R,r.actualTotalRows.value=R,at.value=Math.max(r.totalRows.value,r.actualTotalRows.value),(h=t==null?void 0:t.syncVisibleData)==null||h.call(t)}catch(R){const l=await te(R);throw X.error(`Failed to sync count: ${l}`),R}}function ve(e){var a;const r=Z.value.rowId;if(!r)return-1;const o=D(e);for(const[n,s]of o.cachedRows.value.entries())if(J(s.row,(a=w.value)==null?void 0:a.columns)===r)return s.rowMeta.rowIndex;return-1}async function At(e){if(!Z.value.rowId)return-1;const o=D(e);return await ao(()=>{var a;return(a=o.chunkStates.value)==null?void 0:a.every(n=>n!=="loading")}).toBeTruthy({timeout:5e3}),ve(e)}const Dt=W(()=>{var a,n,s,c;const e=(n=(a=Z.value)==null?void 0:a.path)!=null&&n.trim()?(c=(s=Z.value)==null?void 0:s.path)==null?void 0:c.split("-").map(u=>+u):[],r=D(e),o=ve(e);return o===-1?!1:o===r.totalRows.value-1}),Et=W(()=>{var o,a,n,s;const e=(a=(o=Z.value)==null?void 0:o.path)!=null&&a.trim()?(s=(n=Z.value)==null?void 0:n.path)==null?void 0:s.split("-").map(c=>+c):[],r=ve(e);return r===-1?!1:r===0});async function Xe(e,r,o=[]){var i;const a=q(e),n=q(r),s=new Set;for(let d=a;d<=n;d++)s.add(d);await Promise.all([...s].map(d=>pe(d,o)));const c=D(o),u=[];for(let d=e;d<=r;d++)c.cachedRows.value.has(d)&&u.push(c.cachedRows.value.get(d));return(i=t==null?void 0:t.syncVisibleData)==null||i.call(t),u}return ut.on(e=>{if([ke.TRIGGER_RE_RENDER,ke.ON_ROW_COLOUR_INFO_UPDATE].includes(e))if(ct.value)we.value.forEach(r=>{r.cachedRows.value.forEach(o=>{Object.assign(o.rowMeta,oe(o.row))})});else{const{cachedRows:r}=D();r.value.forEach(o=>{Object.assign(o.rowMeta,oe(o.row))})}}),{getDataCache:D,insertRow:fe,updateRowProperty:he,addEmptyRow:xt,deleteRow:ze,deleteRowById:Ce,getChunkIndex:q,fetchMissingChunks:pt,fetchChunk:pe,updateOrSaveRow:It,bulkUpdateView:Tt,removeRowIfNew:_t,cachedRows:le,recoverLTARRefs:Pe,totalRows:Ne,actualTotalRows:Le,clearCache:yt,syncCount:xe,selectedRows:$e,chunkStates:Ue,isRowSortRequiredRows:Ge,clearInvalidRows:St,applySorting:qe,CHUNK_SIZE:H,loadData:Se,isLastRow:Dt,isFirstRow:Et,getExpandedRowIndex:ve,loadAggCommentsCount:Je,navigateToSiblingRow:Mt,updateRecordOrder:mt,selectedAllRecords:lt,getRows:Xe,groupDataCache:we}}export{So as a,po as g,Co as u};
