/*
    CONFLUENCE ZONES ACSIL STUDY - NEW DEBUG VERSION
    
    THIS IS THE UPDATED VERSION - CHECK FOR THIS COMMENT
    
    Displays confluence zones from the Meridian Trading System
    Reads zone data from JSON files generated by the confluence system
    
    Author: XIII Trading Systems
    Version: 2.0.0-DEBUG-NEW
    Compatible: Sierra Chart 2400+
*/

#include "sierrachart.h"
#include <fstream>
#include <string>
#include <vector>
#include <sstream>

// Zone data structure
struct ConfluenceZone {
    float High;
    float Low;
    float Center;
    float Score;
    int SourceCount;
    float ColorIntensity;
    int ZoneId;
    COLORREF Color;
    SCString Level;
    bool IsValid;
    
    ConfluenceZone() : High(0), Low(0), Center(0), Score(0), SourceCount(0), 
                       ColorIntensity(0.5f), ZoneId(0), Color(RGB(128,128,128)), 
                       IsValid(false) {}
};

// Forward declarations
void LoadZonesFromFile(SCStudyInterfaceRef sc, const SCString& filePath, 
                      std::vector<ConfluenceZone>& zones);
bool ParseZoneFromJson(const std::string& jsonStr, ConfluenceZone& zone);
float ExtractFloatValue(const std::string& json, const std::string& key);
SCString ExtractStringValue(const std::string& json, const std::string& key);
void DrawConfluenceZones(SCStudyInterfaceRef sc, const std::vector<ConfluenceZone>& zones,
                        bool showLabels, int transparency, float minScore,
                        bool showL1, bool showL2, bool showL3, bool showL4, bool showL5);
void ClearZoneDrawings(SCStudyInterfaceRef sc);

// Study configuration inputs
SCDLLName("Confluence Zones NEW")

/*==========================================================================*/
SCSFExport scsf_ConfluenceZonesNEW(SCStudyInterfaceRef sc)
{
    // Configuration references
    SCSubgraphRef Subgraph_Zones = sc.Subgraph[0];
    SCInputRef Input_ShowZones = sc.Input[0];
    SCInputRef Input_ShowLabels = sc.Input[1];
    SCInputRef Input_Transparency = sc.Input[2];
    SCInputRef Input_MinConfluenceScore = sc.Input[3];
    SCInputRef Input_ShowL1Zones = sc.Input[4];
    SCInputRef Input_ShowL2Zones = sc.Input[5];
    SCInputRef Input_ShowL3Zones = sc.Input[6];
    SCInputRef Input_ShowL4Zones = sc.Input[7];
    SCInputRef Input_ShowL5Zones = sc.Input[8];
    SCInputRef Input_ZoneFilePath = sc.Input[9];
    SCInputRef Input_RefreshInterval = sc.Input[10];

    // Study initialization
    if (sc.SetDefaults)
    {
        sc.GraphName = "Confluence Zones NEW";
        sc.GraphRegion = 0; // Main price graph
        sc.AutoLoop = 1;    // Enable auto loop
        sc.CalculationPrecedence = LOW_PREC_LEVEL;
        sc.FreeDLL = 0;     // Keep DLL loaded
        
        // Subgraph setup
        Subgraph_Zones.Name = "Confluence Zones";
        Subgraph_Zones.DrawStyle = DRAWSTYLE_IGNORE;
        Subgraph_Zones.PrimaryColor = RGB(0, 200, 0);
        Subgraph_Zones.DrawZeros = false;

        // Input configurations
        Input_ShowZones.Name = "Show Zones";
        Input_ShowZones.SetYesNo(true);

        Input_ShowLabels.Name = "Show Zone Labels";
        Input_ShowLabels.SetYesNo(true);

        Input_Transparency.Name = "Zone Transparency (0-100)";
        Input_Transparency.SetInt(30);
        Input_Transparency.SetIntLimits(0, 100);

        Input_MinConfluenceScore.Name = "Minimum Confluence Score";
        Input_MinConfluenceScore.SetFloat(0.0f);
        Input_MinConfluenceScore.SetFloatLimits(0.0f, 10.0f);

        Input_ShowL1Zones.Name = "Show L1 (Gray) Zones";
        Input_ShowL1Zones.SetYesNo(true);

        Input_ShowL2Zones.Name = "Show L2 (Blue) Zones";
        Input_ShowL2Zones.SetYesNo(true);

        Input_ShowL3Zones.Name = "Show L3 (Green) Zones";
        Input_ShowL3Zones.SetYesNo(true);

        Input_ShowL4Zones.Name = "Show L4 (Orange) Zones";
        Input_ShowL4Zones.SetYesNo(true);

        Input_ShowL5Zones.Name = "Show L5 (Red) Zones";
        Input_ShowL5Zones.SetYesNo(true);

        Input_ZoneFilePath.Name = "Zone File Path (leave empty for auto)";
        Input_ZoneFilePath.SetString("");

        Input_RefreshInterval.Name = "Refresh Interval (seconds)";
        Input_RefreshInterval.SetInt(30);
        Input_RefreshInterval.SetIntLimits(5, 300);

        // VERY OBVIOUS initialization message
        sc.AddMessageToLog("*** CONFLUENCE ZONES NEW v2.0.0-DEBUG-NEW INITIALIZED ***", 0);
        return;
    }

    // VERY OBVIOUS runtime message - shows every time
    sc.AddMessageToLog("*** CONFLUENCE ZONES NEW: STUDY IS RUNNING ***", 0);

    // Static variables for zone management
    static std::vector<ConfluenceZone> LoadedZones;
    static SCDateTime LastFileCheck = 0;
    static SCDateTime LastFileModTime = 0;

    // Get refresh interval
    int RefreshIntervalSeconds = Input_RefreshInterval.GetInt();
    SCDateTime CurrentTime = sc.CurrentSystemDateTime;

    // Check if we need to reload the file
    bool NeedReload = false;
    if (LastFileCheck == 0 || 
        (CurrentTime - LastFileCheck).GetTimeInSeconds() >= RefreshIntervalSeconds)
    {
        NeedReload = true;
        LastFileCheck = CurrentTime;
    }

    // Build zone file path - Use Zones subdirectory
    SCString ZoneFilePath = Input_ZoneFilePath.GetString();
    if (ZoneFilePath.GetLength() == 0)
    {
        SCString Symbol = sc.GetChartSymbol(sc.ChartNumber);
        ZoneFilePath.Format("%s\\Zones\\%s_zones.json", 
            sc.DataFilesFolder().GetChars(), Symbol.GetChars());
    }
    
    // VERY OBVIOUS debug message showing file path
    SCString debugMsg;
    debugMsg.Format("*** LOOKING FOR ZONE FILE: %s ***", ZoneFilePath.GetChars());
    sc.AddMessageToLog(debugMsg, 0);

    // Load zones from file if needed
    if (NeedReload)
    {
        std::ifstream file(ZoneFilePath.GetChars());
        if (!file.good())
        {
            SCString errorMsg;
            errorMsg.Format("*** ZONE FILE NOT FOUND: %s ***", ZoneFilePath.GetChars());
            sc.AddMessageToLog(errorMsg, 1);
        }
        else
        {
            file.close();
            sc.AddMessageToLog("*** ZONE FILE FOUND - LOADING ZONES ***", 0);
            
            WIN32_FILE_ATTRIBUTE_DATA fileInfo;
            if (GetFileAttributesEx(ZoneFilePath.GetChars(), GetFileExInfoStandard, &fileInfo))
            {
                SYSTEMTIME st;
                FileTimeToSystemTime(&fileInfo.ftLastWriteTime, &st);
                SCDateTime FileModTime = SCDateTime(st.wYear, st.wMonth, st.wDay, 
                                                   st.wHour, st.wMinute, st.wSecond);
                
                if (FileModTime != LastFileModTime)
                {
                    LastFileModTime = FileModTime;
                    LoadZonesFromFile(sc, ZoneFilePath, LoadedZones);
                }
            }
        }
    }

    // Skip if zones not enabled
    if (!Input_ShowZones.GetYesNo())
    {
        ClearZoneDrawings(sc);
        return;
    }

    // Draw zones
    DrawConfluenceZones(sc, LoadedZones, Input_ShowLabels.GetYesNo(), 
                       Input_Transparency.GetInt(), Input_MinConfluenceScore.GetFloat(),
                       Input_ShowL1Zones.GetYesNo(), Input_ShowL2Zones.GetYesNo(),
                       Input_ShowL3Zones.GetYesNo(), Input_ShowL4Zones.GetYesNo(),
                       Input_ShowL5Zones.GetYesNo());
}

/*==========================================================================*/
void LoadZonesFromFile(SCStudyInterfaceRef sc, const SCString& filePath, 
                      std::vector<ConfluenceZone>& zones)
{
    zones.clear();
    sc.AddMessageToLog("*** LOADING ZONES FROM FILE ***", 0);

    std::ifstream file(filePath.GetChars());
    if (!file.is_open())
    {
        SCString msg;
        msg.Format("*** CANNOT OPEN ZONE FILE: %s ***", filePath.GetChars());
        sc.AddMessageToLog(msg, 1);
        return;
    }

    // Read entire file content
    std::stringstream buffer;
    buffer << file.rdbuf();
    file.close();
    
    std::string content = buffer.str();
    sc.AddMessageToLog("*** FILE CONTENT READ SUCCESSFULLY ***", 0);
    
    // Simple JSON parsing for zone data
    size_t zonesStart = content.find("\"zones\":");
    if (zonesStart == std::string::npos)
    {
        sc.AddMessageToLog("*** NO ZONES ARRAY FOUND IN JSON ***", 1);
        return;
    }

    size_t arrayStart = content.find("[", zonesStart);
    if (arrayStart == std::string::npos) return;

    size_t pos = arrayStart + 1;
    int zoneCount = 0;

    // Parse each zone object
    while (pos < content.length())
    {
        size_t objStart = content.find("{", pos);
        if (objStart == std::string::npos) break;

        size_t objEnd = content.find("}", objStart);
        if (objEnd == std::string::npos) break;

        std::string zoneJson = content.substr(objStart, objEnd - objStart + 1);
        
        ConfluenceZone zone;
        if (ParseZoneFromJson(zoneJson, zone))
        {
            zones.push_back(zone);
            zoneCount++;
        }

        pos = objEnd + 1;

        size_t nextComma = content.find(",", pos);
        size_t arrayEnd = content.find("]", pos);
        if (arrayEnd != std::string::npos && (nextComma == std::string::npos || arrayEnd < nextComma))
        {
            break;
        }
    }

    SCString msg;
    msg.Format("*** LOADED %d CONFLUENCE ZONES FROM FILE ***", zoneCount);
    sc.AddMessageToLog(msg, 0);
}

/*==========================================================================*/
bool ParseZoneFromJson(const std::string& jsonStr, ConfluenceZone& zone)
{
    zone.High = ExtractFloatValue(jsonStr, "high");
    zone.Low = ExtractFloatValue(jsonStr, "low");
    zone.Center = ExtractFloatValue(jsonStr, "center");
    zone.Score = ExtractFloatValue(jsonStr, "score");
    zone.SourceCount = (int)ExtractFloatValue(jsonStr, "source_count");
    zone.ColorIntensity = ExtractFloatValue(jsonStr, "color_intensity");
    zone.ZoneId = (int)ExtractFloatValue(jsonStr, "zone_id");
    zone.Level = ExtractStringValue(jsonStr, "level");

    // Extract RGB color
    size_t colorStart = jsonStr.find("\"color_rgb\":");
    if (colorStart != std::string::npos)
    {
        int r = (int)ExtractFloatValue(jsonStr.substr(colorStart), "r");
        int g = (int)ExtractFloatValue(jsonStr.substr(colorStart), "g");
        int b = (int)ExtractFloatValue(jsonStr.substr(colorStart), "b");
        zone.Color = RGB(r, g, b);
    }
    else
    {
        if (zone.Level == "L5") zone.Color = RGB(255, 0, 0);
        else if (zone.Level == "L4") zone.Color = RGB(255, 128, 0);
        else if (zone.Level == "L3") zone.Color = RGB(0, 200, 0);
        else if (zone.Level == "L2") zone.Color = RGB(0, 128, 255);
        else zone.Color = RGB(128, 128, 128);
    }

    zone.IsValid = (zone.High > zone.Low && zone.High > 0 && zone.Low > 0);
    return zone.IsValid;
}

/*==========================================================================*/
float ExtractFloatValue(const std::string& json, const std::string& key)
{
    std::string searchKey = "\"" + key + "\":";
    size_t pos = json.find(searchKey);
    if (pos == std::string::npos) return 0.0f;

    pos += searchKey.length();
    
    while (pos < json.length() && (json[pos] == ' ' || json[pos] == '\t')) pos++;
    
    size_t endPos = pos;
    while (endPos < json.length() && 
           (std::isdigit(json[endPos]) || json[endPos] == '.' || json[endPos] == '-')) 
    {
        endPos++;
    }

    if (endPos > pos)
    {
        std::string numStr = json.substr(pos, endPos - pos);
        return (float)std::atof(numStr.c_str());
    }

    return 0.0f;
}

/*==========================================================================*/
SCString ExtractStringValue(const std::string& json, const std::string& key)
{
    std::string searchKey = "\"" + key + "\":";
    size_t pos = json.find(searchKey);
    if (pos == std::string::npos) return SCString("");

    pos += searchKey.length();
    
    while (pos < json.length() && json[pos] != '"') pos++;
    if (pos >= json.length()) return SCString("");

    pos++;
    size_t endPos = json.find('"', pos);
    if (endPos == std::string::npos) return SCString("");

    std::string value = json.substr(pos, endPos - pos);
    return SCString(value.c_str());
}

/*==========================================================================*/
void DrawConfluenceZones(SCStudyInterfaceRef sc, const std::vector<ConfluenceZone>& zones,
                        bool showLabels, int transparency, float minScore,
                        bool showL1, bool showL2, bool showL3, bool showL4, bool showL5)
{
    ClearZoneDrawings(sc);

    if (zones.empty()) 
    {
        sc.AddMessageToLog("*** NO ZONES TO DRAW ***", 1);
        return;
    }

    if (sc.ArraySize < 1) return;
    
    SCDateTime ChartStartTime = sc.BaseDateTimeIn[0];
    SCDateTime ChartEndTime = sc.BaseDateTimeIn[sc.ArraySize - 1];
    
    int BarsToExtend = max(20, sc.ArraySize / 10);
    SCDateTime ExtendedEndTime = ChartEndTime + SCDateTime::MINUTES(BarsToExtend * 15);

    int drawnZones = 0;

    for (size_t i = 0; i < zones.size(); i++)
    {
        const ConfluenceZone& zone = zones[i];
        
        if (!zone.IsValid) continue;
        if (zone.Score < minScore) continue;

        bool drawThis = false;
        if (zone.Level == "L1" && showL1) drawThis = true;
        else if (zone.Level == "L2" && showL2) drawThis = true;
        else if (zone.Level == "L3" && showL3) drawThis = true;
        else if (zone.Level == "L4" && showL4) drawThis = true;
        else if (zone.Level == "L5" && showL5) drawThis = true;

        if (!drawThis) continue;

        s_UseTool Rectangle;
        Rectangle.Clear();
        Rectangle.ChartNumber = sc.ChartNumber;
        Rectangle.DrawingType = DRAWING_RECTANGLEHIGHLIGHT;
        Rectangle.AddAsUserDrawnDrawing = 0;
        Rectangle.BeginDateTime = ChartStartTime;
        Rectangle.EndDateTime = ExtendedEndTime;
        Rectangle.BeginValue = zone.High;
        Rectangle.EndValue = zone.Low;
        Rectangle.Color = zone.Color;
        Rectangle.SecondaryColor = zone.Color;
        Rectangle.LineWidth = 1;
        Rectangle.TransparencyLevel = transparency;
        Rectangle.LineNumber = 1000 + (int)i;

        sc.UseTool(Rectangle);

        if (showLabels)
        {
            s_UseTool Text;
            Text.Clear();
            Text.ChartNumber = sc.ChartNumber;
            Text.DrawingType = DRAWING_TEXT;
            Text.AddAsUserDrawnDrawing = 0;
            Text.BeginDateTime = ChartStartTime + SCDateTime::MINUTES(30);
            Text.BeginValue = zone.Center;
            Text.Color = zone.Color;
            Text.FontBold = 1;
            Text.FontSize = 8;
            Text.LineNumber = 2000 + (int)i;

            SCString labelText;
            labelText.Format("%s (%.1f)", zone.Level.GetChars(), zone.Score);
            Text.Text = labelText;

            sc.UseTool(Text);
        }

        drawnZones++;
    }

    SCString msg;
    msg.Format("*** DREW %d CONFLUENCE ZONES ***", drawnZones);
    sc.AddMessageToLog(msg, 0);
}

/*==========================================================================*/
void ClearZoneDrawings(SCStudyInterfaceRef sc)
{
    for (int i = 1000; i < 2000; i++)
    {
        sc.DeleteACSChartDrawing(sc.ChartNumber, TOOL_DELETE_CHARTDRAWING, i);
    }

    for (int i = 2000; i < 3000; i++)
    {
        sc.DeleteACSChartDrawing(sc.ChartNumber, TOOL_DELETE_CHARTDRAWING, i);
    }
}